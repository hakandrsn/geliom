This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursor/
  rules/
    definiions.mdc
    generally.mdc
api/
  events.ts
  groups.ts
  index.ts
  moods.ts
  muted.ts
  nicknames.ts
  notifications.ts
  provider-auth.ts
  README.md
  statuses.ts
  subscriptions.ts
  supabase.ts
  users.ts
app/
  (auth)/
    login.tsx
  (drawer)/
    (group)/
      _layout.tsx
      create-group.tsx
      join-group.tsx
      join-requests.tsx
      manage-members.tsx
      search-user.tsx
    _layout.tsx
    home.tsx
    showroom.tsx
  _layout.tsx
  index.tsx
  Provider.tsx
assets/
  fonts/
    Comfortaa-Bold.ttf
    Comfortaa-Light.ttf
    Comfortaa-Medium.ttf
    Comfortaa-Regular.ttf
    Comfortaa-SemiBold.ttf
  images/
    android-icon-background.png
    android-icon-foreground.png
    android-icon-monochrome.png
    favicon.png
    icon.png
    partial-react-logo.png
    react-logo.png
    react-logo@2x.png
    react-logo@3x.png
    splash-icon.png
    t-icon.png
components/
  anim/
    AnimatedComponents.tsx
  dashboard/
    DashboardView.tsx
    EmptyStateView.tsx
    index.ts
    MemberCard.tsx
    StatusSelector.tsx
  shared/
    BaseLayout.tsx
    BlurButton.tsx
    Button.tsx
    GeliomButton.tsx
    GroupHeader.tsx
    GroupListBottomSheet.tsx
    index.ts
    Popover.tsx
    Text.tsx
    Typography.tsx
  ui/
    index.ts
    NetworkToast.tsx
  CustomDrawerContent.tsx
  index.ts
  KeyboardAwareView.tsx
  NotificationHandler.tsx
constants/
  adapty.ts
contexts/
  AuthContext.tsx
  BottomSheetContext.tsx
  GroupContext.tsx
  NetworkToastContext.tsx
  PayContext.tsx
  ThemeContext.tsx
docs/
  BaseLayout-usage.md
  bildirim-sistemi.md
  Component-Showroom.md
  cron-job-setup.md
  database-function-update.sql
  database-migration-group-based-status-mood.sql
  database-migration-status-notifications.sql
  database-rate-limiting-migration.sql
  edge-function-secrets-setup.md
  expo-notifications-kullanim.md
  faz2-todo.md
  future-packages.md
  GeliomButton-Documentation.md
  Login-System-usage.md
  Mock-Development-Setup.md
  onesignal-api-key-setup.md
  onesignal-fix-checklist.md
  onesignal-ios-fix-checklist.md
  onesignal-player-id-test.md
  onesignal-test-notification.md
  onesignal-troubleshooting.md
  prebuild-checklist.md
  Professional-Auth-System.md
  project-flow.md
  project-mermaid.md
  rate-limiting-implementation.md
  rate-limiting-plan.md
  realtime-join-requests.md
  realtime-tables-list.md
  realtime-troubleshooting.md
  status-notification-system.md
  supabase-oauth-setup.md
  Theme-Typography-usage.md
hooks/
  useNetworkStatus.ts
localization/
  en.json
  tr.json
services/
  notification-handler.ts
  onesignal.ts
supabase/
  functions/
    process-pending-notifications/
      index.ts
    send-notification/
      index.ts
theme/
  colors.ts
  typography.ts
types/
  auth.ts
  database.ts
  user.ts
.gitignore
app.json
eas.json
eslint.config.js
google-services.json
GoogleService-Info.plist
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="api/muted.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import type { MutedNotification } from '../types/database';
import { supabase } from './supabase';

// Query Keys
export const mutedKeys = {
  all: ['muted-notifications'] as const,
  user: (userId: string) => [...mutedKeys.all, 'user', userId] as const,
  check: (muterUserId: string, mutedUserId: string) => 
    [...mutedKeys.all, 'check', muterUserId, mutedUserId] as const,
};

// Queries
export const useMutedNotifications = (userId: string) => {
  return useQuery({
    queryKey: mutedKeys.user(userId),
    queryFn: async (): Promise<MutedNotification[]> => {
      const { data, error } = await supabase
        .from('muted_notifications')
        .select('*')
        .eq('muter_user_id', userId);
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!userId,
  });
};

export const useIsMuted = (muterUserId: string, mutedUserId: string) => {
  return useQuery({
    queryKey: mutedKeys.check(muterUserId, mutedUserId),
    queryFn: async (): Promise<boolean> => {
      const { data, error } = await supabase
        .from('muted_notifications')
        .select('muted_user_id')
        .eq('muter_user_id', muterUserId)
        .eq('muted_user_id', mutedUserId)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      return !!data;
    },
    enabled: !!(muterUserId && mutedUserId),
  });
};

// Mutations
export const useMuteUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ muterUserId, mutedUserId }: { muterUserId: string; mutedUserId: string }): Promise<MutedNotification> => {
      const { data, error } = await supabase
        .from('muted_notifications')
        .insert({ muter_user_id: muterUserId, muted_user_id: mutedUserId })
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: mutedKeys.all });
      queryClient.invalidateQueries({ queryKey: mutedKeys.user(data.muter_user_id) });
      queryClient.invalidateQueries({ queryKey: mutedKeys.check(data.muter_user_id, data.muted_user_id) });
    },
  });
};

export const useUnmuteUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ muterUserId, mutedUserId }: { muterUserId: string; mutedUserId: string }): Promise<void> => {
      const { error } = await supabase
        .from('muted_notifications')
        .delete()
        .eq('muter_user_id', muterUserId)
        .eq('muted_user_id', mutedUserId);
      
      if (error) throw error;
    },
    onSuccess: (_, { muterUserId, mutedUserId }) => {
      queryClient.invalidateQueries({ queryKey: mutedKeys.all });
      queryClient.invalidateQueries({ queryKey: mutedKeys.user(muterUserId) });
      queryClient.invalidateQueries({ queryKey: mutedKeys.check(muterUserId, mutedUserId) });
    },
  });
};

export const useToggleMuteUser = () => {
  const queryClient = useQueryClient();
  const muteUser = useMuteUser();
  const unmuteUser = useUnmuteUser();
  
  return useMutation({
    mutationFn: async ({ muterUserId, mutedUserId, isCurrentlyMuted }: { 
      muterUserId: string; 
      mutedUserId: string; 
      isCurrentlyMuted: boolean;
    }): Promise<void> => {
      if (isCurrentlyMuted) {
        await unmuteUser.mutateAsync({ muterUserId, mutedUserId });
      } else {
        await muteUser.mutateAsync({ muterUserId, mutedUserId });
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: mutedKeys.all });
    },
  });
};
</file>

<file path="app/(drawer)/(group)/join-group.tsx">
import { useCreateJoinRequest, useGroupByInviteCode } from '@/api/groups';
import KeyboardAwareView from '@/components/KeyboardAwareView';
import { BaseLayout, GeliomButton, Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useTheme } from '@/contexts/ThemeContext';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useState } from 'react';
import { Alert, StyleSheet, TextInput, View } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function JoinGroupScreen() {
  const { user } = useAuth();
  const { colors } = useTheme();
  const router = useRouter();
  const insets = useSafeAreaInsets();
  const headerHeight = 56 + insets.top;

  const [inviteCode, setInviteCode] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [codeError, setCodeError] = useState<string | null>(null);

  // Davet kodu ile grubu bul
  const { data: group, isLoading: isLoadingGroup, refetch: refetchGroup } = useGroupByInviteCode(
    inviteCode.trim().toUpperCase()
  );

  const createJoinRequest = useCreateJoinRequest();

  const handleJoinRequest = async () => {
    if (!inviteCode.trim()) {
      setCodeError('Davet kodu gerekli');
      return;
    }

    if (!user?.id) {
      Alert.alert('Hata', 'Kullanƒ±cƒ± bilgisi bulunamadƒ±');
      return;
    }

    if (!group) {
      setCodeError('Ge√ßersiz davet kodu');
      return;
    }

    try {
      setIsSubmitting(true);
      setCodeError(null);

      await createJoinRequest.mutateAsync({
        group_id: group.id,
        requester_id: user.id,
      });

      Alert.alert(
        'ƒ∞stek G√∂nderildi',
        `${group.name} grubuna katƒ±lma isteƒüiniz g√∂nderildi. Grup kurucusu onayladƒ±ƒüƒ±nda gruba katƒ±lacaksƒ±nƒ±z.`,
        [
          {
            text: 'Tamam',
            onPress: () => router.back(),
          },
        ]
      );
    } catch (error: any) {
      setCodeError(error.message || 'ƒ∞stek g√∂nderilemedi');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleCodeChange = (text: string) => {
    // Sadece b√ºy√ºk harf ve rakam kabul et
    const cleaned = text.toUpperCase().replace(/[^A-Z0-9]/g, '');
    setInviteCode(cleaned);
    setCodeError(null);
    
    // Eƒüer kod 8 karakter ise otomatik arama yap
    if (cleaned.length === 8) {
      refetchGroup();
    }
  };

  return (
    <BaseLayout
      headerShow={true}
      header={{
        leftIcon: {
          icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
          onPress: () => router.back(),
        },
        title: <Typography variant="h5" color={colors.text}>Gruba Katƒ±l</Typography>,
        backgroundColor: colors.background,
      }}
    >
      <KeyboardAwareView contentContainerStyle={styles.contentContainer} keyboardVerticalOffset={headerHeight}>
        <View style={styles.headerSection}>
          <View style={[styles.iconContainer, { backgroundColor: colors.primary + '20' }]}>
            <Ionicons name="people" size={48} color={colors.primary} />
          </View>
          <Typography variant="h3" color={colors.text} style={{ marginTop: 24, marginBottom: 8 }}>
            Davet Kodu ile Katƒ±l
          </Typography>
          <Typography variant="body" color={colors.secondaryText} style={{ textAlign: 'center' }}>
            Grup kurucusundan aldƒ±ƒüƒ±nƒ±z 8 haneli davet kodunu girin
          </Typography>
        </View>

        <View style={styles.form}>
          <View style={styles.inputGroup}>
            <Typography variant="label" color={colors.text} style={{ marginBottom: 8 }}>
              Davet Kodu
            </Typography>
            <TextInput
              style={[
                styles.input,
                {
                  backgroundColor: colors.cardBackground,
                  color: colors.text,
                  borderColor: codeError ? colors.error : group ? colors.success : colors.stroke,
                },
              ]}
              placeholder="ABC12345"
              placeholderTextColor={colors.secondaryText + '80'}
              value={inviteCode}
              onChangeText={handleCodeChange}
              maxLength={8}
              autoCapitalize="characters"
              autoCorrect={false}
            />
            {codeError && (
              <Typography variant="caption" color={colors.error} style={{ marginTop: 4 }}>
                {codeError}
              </Typography>
            )}
            {group && !codeError && (
              <Typography variant="caption" color={colors.success} style={{ marginTop: 4 }}>
                ‚úì {group.name} grubu bulundu
              </Typography>
            )}
          </View>

          {group && (
            <View style={[styles.groupInfo, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}>
              <View style={styles.groupInfoHeader}>
                <View style={[styles.groupIcon, { backgroundColor: colors.primary + '20' }]}>
                  <Ionicons
                    name={group.type === 'family' ? 'home' : group.type === 'work' ? 'briefcase' : 'people'}
                    size={24}
                    color={colors.primary}
                  />
                </View>
                <View style={styles.groupInfoText}>
                  <Typography variant="h5" color={colors.text} numberOfLines={1}>
                    {group.name}
                  </Typography>
                  <Typography variant="caption" color={colors.secondaryText}>
                    {group.type === 'family' ? 'Aile' : group.type === 'friends' ? 'Arkada≈ülar' : group.type === 'work' ? 'ƒ∞≈ü' : 'Diƒüer'} ‚Ä¢ Kurucu: {group.owner?.display_name || 'Bilinmiyor'}
                  </Typography>
                </View>
              </View>
            </View>
          )}

          <GeliomButton
            state={isSubmitting ? 'loading' : group ? 'active' : 'disabled'}
            layout="full-width"
            size="large"
            icon="send"
            onPress={handleJoinRequest}
            disabled={!group || isSubmitting}
          >
            {isSubmitting ? 'G√∂nderiliyor...' : 'Katƒ±lma ƒ∞steƒüi G√∂nder'}
          </GeliomButton>
        </View>
      </KeyboardAwareView>
    </BaseLayout>
  );
}

const styles = StyleSheet.create({
  contentContainer: {
    padding: 24,
    paddingBottom: 100,
  },
  headerSection: {
    alignItems: 'center',
    marginBottom: 32,
    paddingHorizontal: 20,
  },
  iconContainer: {
    width: 96,
    height: 96,
    borderRadius: 48,
    justifyContent: 'center',
    alignItems: 'center',
  },
  form: {
    gap: 24,
  },
  inputGroup: {
    gap: 4,
  },
  input: {
    borderWidth: 1.5,
    borderRadius: 16,
    paddingHorizontal: 16,
    paddingVertical: 16,
    fontSize: 20,
    fontFamily: 'Comfortaa-Bold',
    letterSpacing: 2,
    textAlign: 'center',
  },
  groupInfo: {
    borderRadius: 16,
    borderWidth: 1.5,
    padding: 16,
  },
  groupInfoHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  groupIcon: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  groupInfoText: {
    flex: 1,
  },
});
</file>

<file path="app/(drawer)/(group)/join-requests.tsx">
import { useApproveJoinRequest, useGroupJoinRequests, useGroupJoinRequestsRealtime, useRejectJoinRequest } from '@/api/groups';
import { BaseLayout, Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useGroupContext } from '@/contexts/GroupContext';
import { useTheme } from '@/contexts/ThemeContext';
import type { GroupJoinRequestWithDetails } from '@/types/database';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useState } from 'react';
import { Alert, RefreshControl, ScrollView, StyleSheet, TouchableOpacity, View } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function JoinRequestsScreen() {
  const { user } = useAuth();
  const { selectedGroup } = useGroupContext();
  const { colors } = useTheme();
  const router = useRouter();
  const insets = useSafeAreaInsets();
  const headerHeight = 56 + insets.top;

  const [refreshing, setRefreshing] = useState(false);

  // Sadece owner ise istekleri g√∂ster
  const isOwner = selectedGroup?.owner_id === user?.id;
  const groupId = selectedGroup?.id || '';

  const {
    data: requests = [],
    isLoading,
    refetch,
  } = useGroupJoinRequests(groupId, 'pending');

  // Realtime subscription - Grup i√ßin isteklerin anlƒ±k g√ºncellenmesi
  useGroupJoinRequestsRealtime(groupId);

  const approveRequest = useApproveJoinRequest();
  const rejectRequest = useRejectJoinRequest();

  const handleRefresh = async () => {
    setRefreshing(true);
    await refetch();
    setRefreshing(false);
  };

  const handleApprove = async (request: GroupJoinRequestWithDetails) => {
    Alert.alert(
      'ƒ∞steƒüi Onayla',
      `${request.requester?.display_name || request.requester?.custom_user_id || 'Kullanƒ±cƒ±'} gruba katƒ±lacak. Onaylƒ±yor musunuz?`,
      [
        { text: 'ƒ∞ptal', style: 'cancel' },
        {
          text: 'Onayla',
          onPress: async () => {
            try {
              await approveRequest.mutateAsync({
                requestId: request.id,
                groupId: request.group_id,
              });
              Alert.alert('Ba≈üarƒ±lƒ±', 'Kullanƒ±cƒ± gruba eklendi');
            } catch (error: any) {
              Alert.alert('Hata', error.message || 'ƒ∞stek onaylanamadƒ±');
            }
          },
        },
      ]
    );
  };

  const handleReject = async (request: GroupJoinRequestWithDetails) => {
    Alert.alert(
      'ƒ∞steƒüi Reddet',
      `${request.requester?.display_name || request.requester?.custom_user_id || 'Kullanƒ±cƒ±'}nƒ±n isteƒüini reddetmek istediƒüinize emin misiniz?`,
      [
        { text: 'ƒ∞ptal', style: 'cancel' },
        {
          text: 'Reddet',
          style: 'destructive',
          onPress: async () => {
            try {
              await rejectRequest.mutateAsync({
                requestId: request.id,
                groupId: request.group_id,
              });
            } catch (error: any) {
              Alert.alert('Hata', error.message || 'ƒ∞stek reddedilemedi');
            }
          },
        },
      ]
    );
  };

  if (!selectedGroup) {
    return (
      <BaseLayout
        headerShow={true}
        header={{
          leftIcon: {
            icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
            onPress: () => router.back(),
          },
          title: <Typography variant="h5" color={colors.text}>Katƒ±lma ƒ∞stekleri</Typography>,
          backgroundColor: colors.background,
        }}
      >
        <View style={[styles.emptyContainer, { backgroundColor: colors.background }]}>
          <Ionicons name="people-outline" size={64} color={colors.secondaryText} />
          <Typography variant="h4" color={colors.text} style={{ marginTop: 16, marginBottom: 8 }}>
            Grup Se√ßilmedi
          </Typography>
          <Typography variant="body" color={colors.secondaryText} style={{ textAlign: 'center' }}>
            Katƒ±lma isteklerini g√∂rmek i√ßin bir grup se√ßmelisiniz.
          </Typography>
        </View>
      </BaseLayout>
    );
  }

  if (!isOwner) {
    return (
      <BaseLayout
        headerShow={true}
        header={{
          leftIcon: {
            icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
            onPress: () => router.back(),
          },
          title: <Typography variant="h5" color={colors.text}>Katƒ±lma ƒ∞stekleri</Typography>,
          backgroundColor: colors.background,
        }}
      >
        <View style={[styles.emptyContainer, { backgroundColor: colors.background }]}>
          <Ionicons name="lock-closed-outline" size={64} color={colors.secondaryText} />
          <Typography variant="h4" color={colors.text} style={{ marginTop: 16, marginBottom: 8 }}>
            Yetki Gerekli
          </Typography>
          <Typography variant="body" color={colors.secondaryText} style={{ textAlign: 'center' }}>
            Sadece grup kurucusu katƒ±lma isteklerini g√∂rebilir.
          </Typography>
        </View>
      </BaseLayout>
    );
  }

  return (
    <BaseLayout
      headerShow={true}
      header={{
        leftIcon: {
          icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
          onPress: () => router.back(),
        },
        title: <Typography variant="h5" color={colors.text}>Katƒ±lma ƒ∞stekleri</Typography>,
        backgroundColor: colors.background,
      }}
    >
      <ScrollView
        style={styles.container}
        contentContainerStyle={styles.contentContainer}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} tintColor={colors.primary} />
        }
      >
        {isLoading ? (
          <View style={styles.loadingContainer}>
            <Typography variant="body" color={colors.secondaryText}>
              Y√ºkleniyor...
            </Typography>
          </View>
        ) : requests.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Ionicons name="checkmark-circle-outline" size={64} color={colors.secondaryText} />
            <Typography variant="h4" color={colors.text} style={{ marginTop: 16, marginBottom: 8 }}>
              Bekleyen ƒ∞stek Yok
            </Typography>
            <Typography variant="body" color={colors.secondaryText} style={{ textAlign: 'center' }}>
              ≈ûu anda {selectedGroup.name} grubuna katƒ±lmak isteyen kimse yok.
            </Typography>
          </View>
        ) : (
          <View style={styles.requestsList}>
            <Typography variant="label" color={colors.secondaryText} style={{ marginBottom: 12 }}>
              {requests.length} Bekleyen ƒ∞stek
            </Typography>
            {requests.map((request) => (
              <View
                key={request.id}
                style={[styles.requestCard, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}
              >
                <View style={styles.requestHeader}>
                  <View style={[styles.avatar, { backgroundColor: colors.primary + '20' }]}>
                    {request.requester?.photo_url ? (
                      <Ionicons name="person" size={24} color={colors.primary} />
                    ) : (
                      <Ionicons name="person-outline" size={24} color={colors.primary} />
                    )}
                  </View>
                  <View style={styles.requestInfo}>
                    <Typography variant="h5" color={colors.text} numberOfLines={1}>
                      {request.requester?.display_name || 'ƒ∞simsiz Kullanƒ±cƒ±'}
                    </Typography>
                    <Typography variant="caption" color={colors.secondaryText}>
                      @{request.requester?.custom_user_id || 'N/A'}
                    </Typography>
                    <Typography variant="caption" color={colors.secondaryText} style={{ marginTop: 4 }}>
                      {request.created_at
                        ? new Date(request.created_at).toLocaleDateString('tr-TR', {
                            day: 'numeric',
                            month: 'long',
                            hour: '2-digit',
                            minute: '2-digit',
                          })
                        : 'Tarih bilinmiyor'}
                    </Typography>
                  </View>
                </View>

                <View style={styles.requestActions}>
                  <TouchableOpacity
                    style={[styles.actionButton, styles.rejectButton, { borderColor: colors.error }]}
                    onPress={() => handleReject(request)}
                    disabled={rejectRequest.isPending}
                  >
                    <Ionicons name="close-circle" size={20} color={colors.error} />
                    <Typography variant="button" color={colors.error} style={{ marginLeft: 4 }}>
                      Reddet
                    </Typography>
                  </TouchableOpacity>

                  <TouchableOpacity
                    style={[styles.actionButton, styles.approveButton, { backgroundColor: colors.primary }]}
                    onPress={() => handleApprove(request)}
                    disabled={approveRequest.isPending}
                  >
                    <Ionicons name="checkmark-circle" size={20} color={colors.white} />
                    <Typography variant="button" color={colors.white} style={{ marginLeft: 4 }}>
                      Onayla
                    </Typography>
                  </TouchableOpacity>
                </View>
              </View>
            ))}
          </View>
        )}
      </ScrollView>
    </BaseLayout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  contentContainer: {
    padding: 24,
    paddingBottom: 100,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 40,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 60,
    paddingHorizontal: 24,
  },
  requestsList: {
    gap: 16,
  },
  requestCard: {
    borderRadius: 16,
    borderWidth: 1.5,
    padding: 16,
    gap: 12,
  },
  requestHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  avatar: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  requestInfo: {
    flex: 1,
  },
  requestActions: {
    flexDirection: 'row',
    gap: 12,
    marginTop: 4,
  },
  actionButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 12,
  },
  rejectButton: {
    borderWidth: 1.5,
    backgroundColor: 'transparent',
  },
  approveButton: {
    // backgroundColor will be set inline
  },
});
</file>

<file path="app/(drawer)/(group)/manage-members.tsx">
import { useMutedNotificationsList, useToggleMuteUser } from '@/api';
import { useGroupMembers, useLeaveGroup, useTransferGroupOwnership } from '@/api/groups';
import { useDeleteNickname, useGroupNicknames, useUpsertNickname } from '@/api/nicknames';
import { GeliomButton, Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useGroupContext } from '@/contexts/GroupContext';
import { useTheme } from '@/contexts/ThemeContext';
import type { GroupMemberWithUser, User } from '@/types/database';
import { Header } from '@react-navigation/elements';
import { useRouter } from 'expo-router';
import React, { useState } from 'react';
import {
    ActivityIndicator,
    Alert,
    FlatList,
    Modal,
    StyleSheet,
    TextInput,
    TouchableOpacity,
    View
} from 'react-native';

export default function ManageMembersScreen() {
  const { colors } = useTheme();
  const { user } = useAuth();
  const { selectedGroup } = useGroupContext();
  const router = useRouter();
  
  const [selectedMember, setSelectedMember] = useState<GroupMemberWithUser | null>(null);
  const [nicknameModalVisible, setNicknameModalVisible] = useState(false);
  const [nicknameText, setNicknameText] = useState('');
  const [transferOwnerModalVisible, setTransferOwnerModalVisible] = useState(false);
  
  const { data: members = [], isLoading: membersLoading } = useGroupMembers(selectedGroup?.id || '');
  const { data: nicknames = [] } = useGroupNicknames(selectedGroup?.id || '');
  const { data: mutedUsers = [] } = useMutedNotificationsList(user?.id || '');
  
  const upsertNickname = useUpsertNickname();
  const deleteNickname = useDeleteNickname();
  const toggleMute = useToggleMuteUser();
  const transferOwnership = useTransferGroupOwnership();
  const leaveGroup = useLeaveGroup();
  
  const isOwner = selectedGroup?.owner_id === user?.id;
  const mutedUserIds = new Set(mutedUsers.map(m => m.muted_user_id));
  
  // Kullanƒ±cƒ±nƒ±n nickname'ini bul (mevcut kullanƒ±cƒ± i√ßin)
  const getNicknameForUser = (targetUserId: string) => {
    const nickname = nicknames.find(
      n => n.setter_user_id === user?.id && n.target_user_id === targetUserId
    );
    return nickname?.nickname;
  };
  
  // Kullanƒ±cƒ± sessize alƒ±nmƒ±≈ü mƒ±?
  const isMuted = (targetUserId: string) => {
    return mutedUserIds.has(targetUserId);
  };
  
  const handleNicknamePress = (member: GroupMemberWithUser) => {
    const currentNickname = getNicknameForUser(member.user_id);
    setSelectedMember(member);
    setNicknameText(currentNickname || '');
    setNicknameModalVisible(true);
  };
  
  const handleSaveNickname = async () => {
    if (!selectedMember || !user?.id || !selectedGroup?.id) return;
    
    if (nicknameText.trim()) {
      try {
        await upsertNickname.mutateAsync({
          group_id: selectedGroup.id,
          setter_user_id: user.id,
          target_user_id: selectedMember.user_id,
          nickname: nicknameText.trim(),
        });
        setNicknameModalVisible(false);
        setNicknameText('');
        setSelectedMember(null);
      } catch (error) {
        console.error('Nickname kaydetme hatasƒ±:', error);
        Alert.alert('Hata', 'Nickname kaydedilemedi');
      }
    } else {
      // Bo≈ü ise sil
      try {
        await deleteNickname.mutateAsync({
          groupId: selectedGroup.id,
          setterUserId: user.id,
          targetUserId: selectedMember.user_id,
        });
        setNicknameModalVisible(false);
        setNicknameText('');
        setSelectedMember(null);
      } catch (error) {
        console.error('Nickname silme hatasƒ±:', error);
        Alert.alert('Hata', 'Nickname silinemedi');
      }
    }
  };
  
  const handleToggleMute = async (member: GroupMemberWithUser) => {
    if (!user?.id) return;
    
    const currentlyMuted = isMuted(member.user_id);
    
    try {
      await toggleMute.mutateAsync({
        muterUserId: user.id,
        mutedUserId: member.user_id,
        isCurrentlyMuted: currentlyMuted,
      });
    } catch (error) {
      console.error('Sessize alma hatasƒ±:', error);
      Alert.alert('Hata', 'ƒ∞≈ülem ba≈üarƒ±sƒ±z oldu');
    }
  };
  
  const handleTransferOwnership = async (member: GroupMemberWithUser) => {
    if (!selectedGroup?.id || !isOwner) return;
    
    Alert.alert(
      'Y√∂neticilik Devri',
      `${member.user?.display_name || member.user?.custom_user_id} kullanƒ±cƒ±sƒ±na y√∂neticiliƒüi devretmek istediƒüinize emin misiniz?`,
      [
        { text: 'ƒ∞ptal', style: 'cancel' },
        {
          text: 'Devret',
          style: 'destructive',
          onPress: async () => {
            try {
              await transferOwnership.mutateAsync({
                groupId: selectedGroup.id,
                newOwnerId: member.user_id,
              });
              setTransferOwnerModalVisible(false);
              setSelectedMember(null);
              Alert.alert('Ba≈üarƒ±lƒ±', 'Y√∂neticilik devredildi');
              router.back();
            } catch (error) {
              console.error('Y√∂neticilik devri hatasƒ±:', error);
              Alert.alert('Hata', 'Y√∂neticilik devredilemedi');
            }
          },
        },
      ]
    );
  };
  
  const handleRemoveMember = async (member: GroupMemberWithUser) => {
    if (!selectedGroup?.id || !isOwner) return;
    
    if (member.user_id === user?.id) {
      // Kendini √ßƒ±karma
      Alert.alert(
        'Gruptan Ayrƒ±l',
        'Gruptan ayrƒ±lmak istediƒüinize emin misiniz?',
        [
          { text: 'ƒ∞ptal', style: 'cancel' },
          {
            text: 'Ayrƒ±l',
            style: 'destructive',
            onPress: async () => {
              try {
                await leaveGroup.mutateAsync({
                  groupId: selectedGroup.id,
                  userId: user.id,
                });
                router.replace('/(drawer)/home');
              } catch (error) {
                console.error('Gruptan ayrƒ±lma hatasƒ±:', error);
                Alert.alert('Hata', 'Gruptan ayrƒ±lamadƒ±nƒ±z');
              }
            },
          },
        ]
      );
    } else {
      // Ba≈ükasƒ±nƒ± √ßƒ±karma (sadece owner)
      Alert.alert(
        '√úyeyi √áƒ±kar',
        `${member.user?.display_name || member.user?.custom_user_id} kullanƒ±cƒ±sƒ±nƒ± gruptan √ßƒ±karmak istediƒüinize emin misiniz?`,
        [
          { text: 'ƒ∞ptal', style: 'cancel' },
          {
            text: '√áƒ±kar',
            style: 'destructive',
            onPress: async () => {
              try {
                await leaveGroup.mutateAsync({
                  groupId: selectedGroup.id,
                  userId: member.user_id,
                });
                Alert.alert('Ba≈üarƒ±lƒ±', '√úye gruptan √ßƒ±karƒ±ldƒ±');
              } catch (error) {
                console.error('√úye √ßƒ±karma hatasƒ±:', error);
                Alert.alert('Hata', '√úye √ßƒ±karƒ±lamadƒ±');
              }
            },
          },
        ]
      );
    }
  };
  
  if (!selectedGroup) {
    return (
      <View style={[styles.container, { backgroundColor: colors.background }]}>
        <Typography variant="h6" style={styles.emptyText}>
          L√ºtfen bir grup se√ßin
        </Typography>
      </View>
    );
  }
  
  if (membersLoading) {
    return (
      <View style={[styles.container, styles.centerContent, { backgroundColor: colors.background }]}>
        <ActivityIndicator size="large" color={colors.primary} />
      </View>
    );
  }
  
  const renderMemberItem = ({ item }: { item: GroupMemberWithUser }) => {
    const memberUser = item.user as User;
    const isMemberOwner = selectedGroup.owner_id === item.user_id;
    const isCurrentUser = item.user_id === user?.id;
    const nickname = getNicknameForUser(item.user_id);
    const muted = isMuted(item.user_id);
    
    return (
      <View style={[styles.memberCard, { backgroundColor: colors.cardBackground }]}>
        <Header title="√úyeler"  back={{ title: 'Gruplar', href: '/(drawer)/home' }}/>
        <View style={styles.memberInfo}>
          <Typography variant="h6" style={styles.memberName}>
            {nickname || memberUser.display_name || memberUser.custom_user_id}
          </Typography>
          {nickname && (
            <Typography variant="bodySmall" style={[styles.memberSubtext, { color: colors.secondaryText }]}>
              {memberUser.display_name || memberUser.custom_user_id}
            </Typography>
          )}
          {isMemberOwner && (
            <Typography variant="caption" style={[styles.ownerBadge, { color: colors.primary }]}>
              Y√∂netici
            </Typography>
          )}
          {muted && (
            <Typography variant="caption" style={[styles.mutedBadge, { color: colors.error }]}>
              Sessize Alƒ±ndƒ±
            </Typography>
          )}
        </View>
        
        <View style={styles.memberActions}>
          {/* Nickname */}
          <TouchableOpacity
            onPress={() => handleNicknamePress(item)}
            style={[styles.actionButton, { backgroundColor: colors.primary + '20' }]}
          >
            <Typography variant="bodySmall" style={{ color: colors.primary }}>
              {nickname ? '‚úèÔ∏è' : '‚ûï'} Takma Ad
            </Typography>
          </TouchableOpacity>
          
          {/* Sessize Al/Kaldƒ±r */}
          <TouchableOpacity
            onPress={() => handleToggleMute(item)}
            style={[styles.actionButton, { backgroundColor: muted ? colors.error + '20' : colors.secondary + '20' }]}
          >
            <Typography variant="bodySmall" style={{ color: muted ? colors.error : colors.secondary }}>
              {muted ? 'üîá A√ß' : 'üîï Sessize Al'}
            </Typography>
          </TouchableOpacity>
          
          {/* Y√∂neticilik Devri (sadece owner, kendisi hari√ß) */}
          {isOwner && !isCurrentUser && !isMemberOwner && (
            <TouchableOpacity
              onPress={() => {
                setSelectedMember(item);
                setTransferOwnerModalVisible(true);
              }}
              style={[styles.actionButton, { backgroundColor: colors.warning + '20' }]}
            >
              <Typography variant="bodySmall" style={{ color: colors.warning }}>
                üëë Y√∂netici Yap
              </Typography>
            </TouchableOpacity>
          )}
          
          {/* √úyeyi √áƒ±kar (sadece owner veya kendisi) */}
          {(isOwner || isCurrentUser) && (
            <TouchableOpacity
              onPress={() => handleRemoveMember(item)}
              style={[styles.actionButton, { backgroundColor: colors.error + '20' }]}
            >
              <Typography variant="bodySmall" style={{ color: colors.error }}>
                {isCurrentUser ? 'üö™ Ayrƒ±l' : '‚ùå √áƒ±kar'}
              </Typography>
            </TouchableOpacity>
          )}
        </View>
      </View>
    );
  };
  
  return (
    <View style={[styles.container, { backgroundColor: colors.background }]}>
      <FlatList
        data={members}
        renderItem={renderMemberItem}
        keyExtractor={(item) => item.user_id}
        contentContainerStyle={styles.listContent}
        ListEmptyComponent={
          <View style={styles.centerContent}>
            <Typography variant="body" style={styles.emptyText}>
              Grupta √ºye yok
            </Typography>
          </View>
        }
      />
      
      {/* Nickname Modal */}
      <Modal
        visible={nicknameModalVisible}
        transparent
        animationType="slide"
        onRequestClose={() => setNicknameModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={[styles.modalContent, { backgroundColor: colors.cardBackground }]}>
            <Typography variant="h6" style={styles.modalTitle}>
              Takma Ad {selectedMember?.user?.display_name ? `(${selectedMember.user.display_name})` : ''}
            </Typography>
            
            <TextInput
              style={[styles.input, { 
                backgroundColor: colors.background, 
                color: colors.text,
                borderColor: colors.stroke 
              }]}
              placeholder="Takma ad girin (bo≈ü bƒ±rakƒ±rsanƒ±z silinir)"
              placeholderTextColor={colors.secondaryText}
              value={nicknameText}
              onChangeText={setNicknameText}
              maxLength={50}
            />
            
            <View style={styles.modalActions}>
              <GeliomButton
                state="active"
                size="medium"
                onPress={() => {
                  setNicknameModalVisible(false);
                  setNicknameText('');
                  setSelectedMember(null);
                }}
                style={styles.modalButton}
              >
                ƒ∞ptal
              </GeliomButton>
              <GeliomButton
                state={upsertNickname.isPending || deleteNickname.isPending ? 'loading' : 'active'}
                size="medium"
                onPress={handleSaveNickname}
                style={styles.modalButton}
              >
                Kaydet
              </GeliomButton>
            </View>
          </View>
        </View>
      </Modal>
      
      {/* Transfer Ownership Modal */}
      <Modal
        visible={transferOwnerModalVisible}
        transparent
        animationType="slide"
        onRequestClose={() => setTransferOwnerModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={[styles.modalContent, { backgroundColor: colors.cardBackground }]}>
            <Typography variant="h6" style={styles.modalTitle}>
              Y√∂neticilik Devri
            </Typography>
            
            <Typography variant="body" style={[styles.modalText, { color: colors.text }]}>
              {selectedMember?.user?.display_name || selectedMember?.user?.custom_user_id} kullanƒ±cƒ±sƒ±na y√∂neticiliƒüi devretmek istediƒüinize emin misiniz?
            </Typography>
            
            <View style={styles.modalActions}>
              <GeliomButton
                state="active"
                size="medium"
                onPress={() => {
                  setTransferOwnerModalVisible(false);
                  setSelectedMember(null);
                }}
                style={styles.modalButton}
              >
                ƒ∞ptal
              </GeliomButton>
              <GeliomButton
                state={transferOwnership.isPending ? 'loading' : 'active'}
                size="medium"
                onPress={() => selectedMember && handleTransferOwnership(selectedMember)}
                style={styles.modalButton}
              >
                Devret
              </GeliomButton>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  centerContent: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  listContent: {
    padding: 16,
  },
  memberCard: {
    padding: 16,
    borderRadius: 12,
    marginBottom: 12,
  },
  memberInfo: {
    marginBottom: 12,
  },
  memberName: {
    marginBottom: 4,
  },
  memberSubtext: {
    marginBottom: 4,
  },
  ownerBadge: {
    marginTop: 4,
    fontWeight: '600',
  },
  mutedBadge: {
    marginTop: 4,
    fontWeight: '600',
  },
  memberActions: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  actionButton: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 8,
    marginRight: 8,
    marginBottom: 8,
  },
  emptyText: {
    textAlign: 'center',
    marginTop: 32,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '90%',
    maxWidth: 400,
    padding: 24,
    borderRadius: 16,
  },
  modalTitle: {
    marginBottom: 16,
    textAlign: 'center',
  },
  modalText: {
    marginBottom: 24,
    textAlign: 'center',
  },
  input: {
    borderWidth: 1,
    borderRadius: 8,
    padding: 12,
    marginBottom: 24,
    fontSize: 16,
  },
  modalActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 12,
  },
  modalButton: {
    flex: 1,
  },
});
</file>

<file path="app/(drawer)/(group)/search-user.tsx">
import { useCreateJoinRequest } from '@/api/groups';
import { useUserByCustomId } from '@/api/users';
import KeyboardAwareView from '@/components/KeyboardAwareView';
import { BaseLayout, GeliomButton, Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useGroupContext } from '@/contexts/GroupContext';
import { useTheme } from '@/contexts/ThemeContext';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useState } from 'react';
import { Alert, StyleSheet, TextInput, View } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function SearchUserScreen() {
  const { user } = useAuth();
  const { selectedGroup } = useGroupContext();
  const { colors } = useTheme();
  const router = useRouter();
  const insets = useSafeAreaInsets();
  const headerHeight = 56 + insets.top;

  const [customUserId, setCustomUserId] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [searchError, setSearchError] = useState<string | null>(null);

  // Custom user ID ile kullanƒ±cƒ± ara
  const {
    data: foundUser,
    isLoading: isLoadingUser,
    refetch: refetchUser,
  } = useUserByCustomId(customUserId.trim().toUpperCase());

  const createJoinRequest = useCreateJoinRequest();

  const handleSearch = () => {
    if (!customUserId.trim()) {
      setSearchError('Kullanƒ±cƒ± ID gerekli');
      return;
    }

    setSearchError(null);
    refetchUser();
  };

  const handleSendInvite = async () => {
    if (!foundUser) {
      setSearchError('Kullanƒ±cƒ± bulunamadƒ±');
      return;
    }

    if (!user?.id) {
      Alert.alert('Hata', 'Kullanƒ±cƒ± bilgisi bulunamadƒ±');
      return;
    }

    if (!selectedGroup) {
      Alert.alert('Hata', 'L√ºtfen √∂nce bir grup se√ßin');
      return;
    }

    if (foundUser.id === user.id) {
      Alert.alert('Hata', 'Kendinize davet g√∂nderemezsiniz');
      return;
    }

    try {
      setIsSubmitting(true);
      setSearchError(null);

      await createJoinRequest.mutateAsync({
        group_id: selectedGroup.id,
        requester_id: foundUser.id,
      });

      Alert.alert(
        'Davet G√∂nderildi',
        `${foundUser.display_name || foundUser.custom_user_id} kullanƒ±cƒ±sƒ±na ${selectedGroup.name} grubuna katƒ±lma daveti g√∂nderildi.`,
        [
          {
            text: 'Tamam',
            onPress: () => {
              setCustomUserId('');
              router.back();
            },
          },
        ]
      );
    } catch (error: any) {
      setSearchError(error.message || 'Davet g√∂nderilemedi');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleUserIdChange = (text: string) => {
    // Sadece b√ºy√ºk harf ve rakam kabul et
    const cleaned = text.toUpperCase().replace(/[^A-Z0-9]/g, '');
    setCustomUserId(cleaned);
    setSearchError(null);
  };

  return (
    <BaseLayout
      headerShow={true}
      header={{
        leftIcon: {
          icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
          onPress: () => router.back(),
        },
        title: <Typography variant="h5" color={colors.text}>Kullanƒ±cƒ± Ara</Typography>,
        backgroundColor: colors.background,
      }}
    >
      <KeyboardAwareView contentContainerStyle={styles.contentContainer} keyboardVerticalOffset={headerHeight}>
        <View style={styles.headerSection}>
          <View style={[styles.iconContainer, { backgroundColor: colors.primary + '20' }]}>
            <Ionicons name="search" size={48} color={colors.primary} />
          </View>
          <Typography variant="h3" color={colors.text} style={{ marginTop: 24, marginBottom: 8 }}>
            Kullanƒ±cƒ± Ara ve Davet Et
          </Typography>
          <Typography variant="body" color={colors.secondaryText} style={{ textAlign: 'center' }}>
            Kullanƒ±cƒ±nƒ±n custom ID'sini girerek arama yapƒ±n ve gruba davet g√∂nderin
          </Typography>
        </View>

        <View style={styles.form}>
          <View style={styles.inputGroup}>
            <Typography variant="label" color={colors.text} style={{ marginBottom: 8 }}>
              Kullanƒ±cƒ± ID
            </Typography>
            <View style={styles.searchContainer}>
              <TextInput
                style={[
                  styles.input,
                  {
                    backgroundColor: colors.cardBackground,
                    color: colors.text,
                    borderColor: searchError ? colors.error : foundUser ? colors.success : colors.stroke,
                  },
                ]}
                placeholder="ABC12345"
                placeholderTextColor={colors.secondaryText + '80'}
                value={customUserId}
                onChangeText={handleUserIdChange}
                autoCapitalize="characters"
                autoCorrect={false}
                returnKeyType="search"
                onSubmitEditing={handleSearch}
              />
              <GeliomButton
                state={isLoadingUser ? 'loading' : customUserId.trim() ? 'active' : 'disabled'}
                size="small"
                icon="search"
                onPress={handleSearch}
                disabled={!customUserId.trim() || isLoadingUser}
              >
                Ara
              </GeliomButton>
            </View>
            {searchError && (
              <Typography variant="caption" color={colors.error} style={{ marginTop: 4 }}>
                {searchError}
              </Typography>
            )}
            {foundUser && !searchError && (
              <Typography variant="caption" color={colors.success} style={{ marginTop: 4 }}>
                ‚úì Kullanƒ±cƒ± bulundu
              </Typography>
            )}
          </View>

          {foundUser && (
            <View style={[styles.userCard, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}>
              <View style={styles.userCardHeader}>
                <View style={[styles.avatar, { backgroundColor: colors.primary + '20' }]}>
                  {foundUser.photo_url ? (
                    <Ionicons name="person" size={32} color={colors.primary} />
                  ) : (
                    <Ionicons name="person-outline" size={32} color={colors.primary} />
                  )}
                </View>
                <View style={styles.userInfo}>
                  <Typography variant="h5" color={colors.text} numberOfLines={1}>
                    {foundUser.display_name || 'ƒ∞simsiz Kullanƒ±cƒ±'}
                  </Typography>
                  <Typography variant="caption" color={colors.secondaryText}>
                    @{foundUser.custom_user_id}
                  </Typography>
                  {foundUser.email && (
                    <Typography variant="caption" color={colors.secondaryText} style={{ marginTop: 2 }}>
                      {foundUser.email}
                    </Typography>
                  )}
                </View>
              </View>
            </View>
          )}

          {selectedGroup && (
            <View style={[styles.groupInfo, { backgroundColor: colors.cardBackground + '80', borderColor: colors.stroke }]}>
              <View style={styles.groupInfoHeader}>
                <Ionicons name="people" size={20} color={colors.secondaryText} />
                <Typography variant="caption" color={colors.secondaryText} style={{ marginLeft: 8 }}>
                  Davet g√∂nderilecek grup: <Typography variant="caption" color={colors.text} fontWeight="semibold">{selectedGroup.name}</Typography>
                </Typography>
              </View>
            </View>
          )}

          {!selectedGroup && (
            <View style={[styles.warningCard, { backgroundColor: colors.warning + '20', borderColor: colors.warning }]}>
              <Ionicons name="warning-outline" size={20} color={colors.warning} />
              <Typography variant="caption" color={colors.warning} style={{ marginLeft: 8, flex: 1 }}>
                Davet g√∂ndermek i√ßin √∂nce bir grup se√ßmelisiniz.
              </Typography>
            </View>
          )}

          <GeliomButton
            state={isSubmitting ? 'loading' : foundUser && selectedGroup ? 'active' : 'disabled'}
            layout="full-width"
            size="large"
            icon="send"
            onPress={handleSendInvite}
            disabled={!foundUser || !selectedGroup || isSubmitting}
          >
            {isSubmitting ? 'G√∂nderiliyor...' : 'Davet G√∂nder'}
          </GeliomButton>
        </View>
      </KeyboardAwareView>
    </BaseLayout>
  );
}

const styles = StyleSheet.create({
  contentContainer: {
    padding: 24,
    paddingBottom: 100,
  },
  headerSection: {
    alignItems: 'center',
    marginBottom: 32,
    paddingHorizontal: 20,
  },
  iconContainer: {
    width: 96,
    height: 96,
    borderRadius: 48,
    justifyContent: 'center',
    alignItems: 'center',
  },
  form: {
    gap: 24,
  },
  inputGroup: {
    gap: 4,
  },
  searchContainer: {
    flexDirection: 'row',
    gap: 12,
    alignItems: 'flex-start',
  },
  input: {
    flex: 1,
    borderWidth: 1.5,
    borderRadius: 16,
    paddingHorizontal: 16,
    paddingVertical: 16,
    fontSize: 18,
    fontFamily: 'Comfortaa-Medium',
  },
  userCard: {
    borderRadius: 16,
    borderWidth: 1.5,
    padding: 16,
  },
  userCardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  avatar: {
    width: 56,
    height: 56,
    borderRadius: 28,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  userInfo: {
    flex: 1,
  },
  groupInfo: {
    borderRadius: 12,
    borderWidth: 1,
    padding: 12,
  },
  groupInfoHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  warningCard: {
    borderRadius: 12,
    borderWidth: 1,
    padding: 12,
    flexDirection: 'row',
    alignItems: 'center',
  },
});
</file>

<file path="components/anim/AnimatedComponents.tsx">
import * as Haptics from 'expo-haptics';
import React, { useEffect } from 'react';
import { Pressable, StyleProp, ViewStyle } from 'react-native';
import Animated, {
    FadeIn,
    Layout,
    useAnimatedStyle,
    useSharedValue,
    withRepeat,
    withSequence,
    withTiming
} from 'react-native-reanimated';
import { useTheme } from '../../contexts/ThemeContext';

// 1. SNAPPY BUTTON (Hƒ±zlƒ±, Net, Opaklƒ±k Deƒüi≈ütiren)
interface BouncyButtonProps {
  children: React.ReactNode;
  onPress?: () => void;
  style?: StyleProp<ViewStyle>;
  scaleTo?: number; 
  activeOpacity?: number; 
  disabled?: boolean;
}

export const BouncyButton = ({ 
  children, 
  onPress, 
  style, 
  scaleTo = 0.98, 
  activeOpacity = 0.7, 
  disabled 
}: BouncyButtonProps) => {
  const scale = useSharedValue(1);
  const opacity = useSharedValue(1);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
    opacity: opacity.value,
  }));

  const handlePressIn = () => {
    if (disabled) return;
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    scale.value = withTiming(scaleTo, { duration: 50 });
    opacity.value = withTiming(activeOpacity, { duration: 50 });
  };

  const handlePressOut = () => {
    if (disabled) return;
    scale.value = withTiming(1, { duration: 100 });
    opacity.value = withTiming(1, { duration: 100 });
  };

  return (
    <Pressable
      onPress={onPress}
      onPressIn={handlePressIn}
      onPressOut={handlePressOut}
      disabled={disabled}
    >
      <Animated.View style={[style, animatedStyle]}>
        {children}
      </Animated.View>
    </Pressable>
  );
};

// 2. Nefes Alan Arkaplan (Ambient)
export const BreathingBackground = () => {
  const { colors } = useTheme();
  const opacity = useSharedValue(0.3);
  
  useEffect(() => {
    opacity.value = withRepeat(
      withSequence(
        withTiming(0.4, { duration: 4000 }),
        withTiming(0.2, { duration: 4000 })
      ),
      -1,
      true
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    opacity: opacity.value,
  }));

  return (
    <Animated.View
      style={[
        {
          position: 'absolute',
          top: -200,
          left: -100,
          right: -100,
          bottom: -200,
          backgroundColor: colors.tertiary,
          zIndex: -1,
          borderRadius: 1000,
          opacity: 0.2,
          transform: [{ scale: 1.2 }]
        },
        animatedStyle,
      ]}
    />
  );
};

// 3. Liste Elemanlarƒ± (Instant Giri≈ü)
export const StaggeredItem = ({ children, index, style }: { children: React.ReactNode, index: number, style?: StyleProp<ViewStyle> }) => {
  return (
    <Animated.View
      entering={FadeIn.delay(index * 15).duration(200)} 
      layout={Layout.duration(150)}
      style={style}
    >
      {children}
    </Animated.View>
  );
};
</file>

<file path="components/dashboard/DashboardView.tsx">
import { useGroupJoinRequests, useGroupJoinRequestsRealtime, useGroupMembers } from '@/api/groups';
import { useGroupUserMoods } from '@/api/moods';
import { useGroupUserStatuses, useUserStatus } from '@/api/statuses';
import MemberCard from '@/components/dashboard/MemberCard';
import StatusSelector from '@/components/dashboard/StatusSelector';
import { GeliomButton, Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useTheme } from '@/contexts/ThemeContext';
import type { GroupWithOwner } from '@/types/database';
import * as Clipboard from 'expo-clipboard';
import { useRouter } from 'expo-router';
import React, { useState } from 'react';
import { ActivityIndicator, FlatList, StyleSheet, View } from 'react-native';

interface DashboardViewProps {
  group: GroupWithOwner;
}

export default function DashboardView({ group }: DashboardViewProps) {
  const { colors } = useTheme();
  const { user } = useAuth();
  const router = useRouter();
  const [isCopying, setIsCopying] = useState(false);

  // Verileri √ßek (React Query hooks)
  const { data: members, isLoading: membersLoading } = useGroupMembers(group.id);
  const { data: groupStatuses } = useGroupUserStatuses(group.id);
  const { data: groupMoods } = useGroupUserMoods(group.id);
  
  // Benim ≈üu anki statusum (StatusSelector i√ßin)
  const { data: myStatus } = useUserStatus(user?.id || '', group.id);

  // Owner ise katƒ±lma isteklerini kontrol et
  const isOwner = group.owner_id === user?.id;
  const { data: joinRequests = [] } = useGroupJoinRequests(group.id, 'pending');
  const pendingRequestsCount = joinRequests.length;

  // Realtime subscription - Grup i√ßin isteklerin anlƒ±k g√ºncellenmesi (sadece owner i√ßin)
  useGroupJoinRequestsRealtime(group.id);

  const copyInviteCode = async () => {
    if (group.invite_code) {
      await Clipboard.setStringAsync(group.invite_code);
      setIsCopying(true);
      setTimeout(() => setIsCopying(false), 2000);
    }
  };

  const handleManageMembers = () => {
    router.push('/(drawer)/(group)/manage-members');
  };

  if (membersLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator color={colors.primary} size="large" />
      </View>
    );
  }

  // FlatList'in Header'ƒ±: Davet kodu ve Durum se√ßici
  const DashboardHeader = () => (
    <View style={styles.headerContainer}>
      {/* Invite Code Card */}
      <View style={[styles.inviteCard, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}>
        <View>
          <Typography variant="caption" color={colors.secondaryText}>Davet Kodu</Typography>
          <Typography variant="h4" color={colors.primary} style={{ letterSpacing: 1 }}>
            {group.invite_code}
          </Typography>
        </View>
        <GeliomButton 
          state={isCopying ? 'active' : 'passive'}
          size="small"
          icon={isCopying ? "checkmark" : "copy"}
          onPress={copyInviteCode}
        >
          {isCopying ? "Kopyalandƒ±" : "Kopyala"}
        </GeliomButton>
      </View>

      {/* Status Selector - Benim Durumum */}
      <StatusSelector 
        groupId={group.id} 
        currentStatusId={myStatus?.status_id}
      />

      {/* Action Buttons */}
      <View style={styles.actionButtons}>
        {isOwner && (
          <>
            <GeliomButton
              state="active"
              size="medium"
              layout="full-width"
              icon="people"
              onPress={() => router.push('/(drawer)/(group)/join-requests')}
            >
              Katƒ±lma ƒ∞stekleri {pendingRequestsCount > 0 && `(${pendingRequestsCount})`}
            </GeliomButton>
            
            <GeliomButton
              state="active"
              size="medium"
              layout="full-width"
              icon="search"
              onPress={() => router.push('/(drawer)/(group)/search-user')}
            >
              Kullanƒ±cƒ± Ara ve Davet Et
            </GeliomButton>
          </>
        )}
        
        <GeliomButton
          state="active"
          size="medium"
          layout="full-width"
          icon="add-circle"
          onPress={() => router.push('/(drawer)/(group)/join-group')}
        >
          Ba≈üka Gruba Katƒ±l
        </GeliomButton>
        
        <GeliomButton
          state="active"
          size="medium"
          layout="full-width"
          icon="settings"
          onPress={handleManageMembers}
        >
          √úyeleri Y√∂net
        </GeliomButton>
      </View>

      <Typography variant="h5" color={colors.text} style={styles.sectionTitle}>
        Grup √úyeleri ({members?.length || 0})
      </Typography>
    </View>
  );

  return (
    <FlatList
      data={members}
      keyExtractor={(item) => item.user_id}
      contentContainerStyle={styles.listContent}
      ListHeaderComponent={DashboardHeader}
      renderItem={({ item }) => {
        // Bu √ºyenin statusunu ve moodunu bul
        const memberStatus = groupStatuses?.find(s => s.user_id === item.user_id);
        const memberMood = groupMoods?.find(m => m.user_id === item.user_id);
        const isMe = item.user_id === user?.id;

        return (
          <MemberCard 
            member={item}
            status={memberStatus}
            mood={memberMood}
            isMe={isMe}
          />
        );
      }}
      ListEmptyComponent={
        <Typography variant="body" color={colors.secondaryText} style={{ textAlign: 'center', marginTop: 20 }}>
          Bu grupta hen√ºz kimse yok.
        </Typography>
      }
    />
  );
}

const styles = StyleSheet.create({
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  listContent: {
    padding: 20,
    paddingBottom: 100,
  },
  headerContainer: {
    marginBottom: 12,
  },
  inviteCard: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderRadius: 16,
    borderWidth: 1,
    marginBottom: 8,
    borderStyle: 'dashed',
  },
  sectionTitle: {
    marginVertical: 12,
    marginLeft: 4,
  },
  actionButtons: {
    gap: 12,
    marginTop: 8,
    marginBottom: 8,
  },
});
</file>

<file path="components/dashboard/EmptyStateView.tsx">
import { GeliomButton, Typography } from '@/components/shared';
import { useTheme } from '@/contexts/ThemeContext';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React from 'react';
import { StyleSheet, View } from 'react-native';

export default function EmptyStateView() {
  const { colors } = useTheme();
  const router = useRouter();

  return (
    <View style={styles.container}>
      <View style={[styles.iconCircle, { backgroundColor: colors.tertiary + '30' }]}>
        <Ionicons name="leaf-outline" size={64} color={colors.primary} />
      </View>
      
      <Typography variant="h3" color={colors.text} style={styles.title}>
        Ho≈ü Geldin!
      </Typography>
      
      <Typography variant="body" color={colors.secondaryText} style={styles.description}>
        Hen√ºz bir grubun se√ßili deƒüil veya bir gruba √ºye deƒüilsin. 
        Arkada≈ülarƒ±nla ve ailenle doƒüanƒ±n ritminde bulu≈ümak i√ßin bir adƒ±m at.
      </Typography>

      <View style={styles.actions}>
        <GeliomButton
          state="active"
          size="large"
          layout="full-width"
          icon="add-circle"
          onPress={() => router.push('/(drawer)/(group)/create-group')}
        >
          Yeni Grup Olu≈ütur
        </GeliomButton>
        
        <GeliomButton
          state="active"
          size="large"
          layout="full-width"
          icon="people"
          variant="outline"
          onPress={() => router.push('/(drawer)/(group)/join-group')}
        >
          Gruba Katƒ±l
        </GeliomButton>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 24,
  },
  iconCircle: {
    width: 120,
    height: 120,
    borderRadius: 60,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 24,
  },
  title: {
    textAlign: 'center',
    marginBottom: 12,
  },
  description: {
    textAlign: 'center',
    marginBottom: 32,
    lineHeight: 24,
  },
  actions: {
    width: '100%',
    gap: 16,
  },
});
</file>

<file path="components/dashboard/index.ts">
export { default as DashboardView } from './DashboardView';
export { default as EmptyStateView } from './EmptyStateView';
export { default as MemberCard } from './MemberCard';
export { default as StatusSelector } from './StatusSelector';
</file>

<file path="components/dashboard/MemberCard.tsx">
import { Typography } from '@/components/shared';
import { useTheme } from '@/contexts/ThemeContext';
import type { GroupMemberWithUser, UserGroupMoodWithMood, UserStatusWithStatus } from '@/types/database';
import { Ionicons } from '@expo/vector-icons';
import React from 'react';
import { StyleSheet, View } from 'react-native';

interface MemberCardProps {
  member: GroupMemberWithUser;
  status?: UserStatusWithStatus;
  mood?: UserGroupMoodWithMood;
  isMe?: boolean;
}

export default function MemberCard({ member, status, mood, isMe }: MemberCardProps) {
  const { colors } = useTheme();
  const user = member.user;

  if (!user) return null;

  // Durum rengi ve ikonu (Varsayƒ±lan: gri/bilinmiyor)
  const statusColor = status?.status?.is_custom ? colors.primary : (status?.status?.notifies ? colors.warning : colors.secondaryText);
  const statusText = status?.status?.text;

  return (
    <View style={[
      styles.container, 
      { 
        backgroundColor: isMe ? colors.tertiary + '20' : colors.cardBackground,
        borderColor: isMe ? colors.primary : colors.stroke 
      }
    ]}>
      {/* Avatar B√∂l√ºm√º */}
      <View style={[styles.avatarContainer, { backgroundColor: colors.tertiary }]}>
        <Typography variant="h5" color={colors.primary}>
          {user.display_name?.charAt(0).toUpperCase() || '?'}
        </Typography>
        
        {/* Mood Emojisi (Avatarƒ±n k√∂≈üesinde) */}
        {mood?.mood?.emoji && (
          <View style={styles.moodBadge}>
            <Typography variant="h6">{mood.mood.emoji}</Typography>
          </View>
        )}
      </View>

      {/* ƒ∞sim ve Durum */}
      <View style={styles.infoContainer}>
        <View style={styles.nameRow}>
          <Typography 
            variant="body" 
            fontWeight="semibold" 
            color={colors.text}
            numberOfLines={1}
            style={{ flex: 1 }}
          >
            {user.display_name} {isMe && '(Sen)'}
          </Typography>
        </View>

        {/* Durum G√∂stergesi */}
        {statusText ? (
          <View style={styles.statusRow}>
            <Ionicons name="radio-button-on" size={12} color={statusColor} />
            <Typography 
              variant="caption" 
              color={statusColor}
              numberOfLines={1}
              style={{ marginLeft: 4, flex: 1 }}
            >
              {statusText}
            </Typography>
          </View>
        ) : (
          <Typography variant="caption" color={colors.secondaryText} style={{ fontStyle: 'italic' }}>
            Durum yok
          </Typography>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    padding: 12,
    borderRadius: 16,
    borderWidth: 1,
    alignItems: 'center',
    marginBottom: 12,
    // G√∂lge efekti
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 3.84,
    elevation: 2,
  },
  avatarContainer: {
    width: 50,
    height: 50,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
  },
  moodBadge: {
    position: 'absolute',
    bottom: -2,
    right: -2,
    backgroundColor: 'white',
    borderRadius: 10,
    width: 20,
    height: 20,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1.41,
    elevation: 2,
  },
  infoContainer: {
    flex: 1,
    marginLeft: 12,
    justifyContent: 'center',
  },
  nameRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  statusRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
});
</file>

<file path="components/dashboard/StatusSelector.tsx">
import { useDefaultStatuses, useSetUserStatus } from '@/api/statuses';
import { GeliomButton, Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useTheme } from '@/contexts/ThemeContext';
import { Ionicons } from '@expo/vector-icons'; // ƒ∞kon tipleri i√ßin
import React from 'react';
import { ActivityIndicator, ScrollView, StyleSheet, View } from 'react-native';

interface StatusSelectorProps {
  groupId?: string;
  currentStatusId?: number;
}

export default function StatusSelector({ groupId, currentStatusId }: StatusSelectorProps) {
  const { colors } = useTheme();
  const { user } = useAuth();
  
  // Varsayƒ±lan durumlarƒ± √ßek (M√ºsaitim, Me≈ügul√ºm vb.)
  const { data: statuses, isLoading } = useDefaultStatuses();
  
  // Durum g√ºncelleme mutasyonu
  const setStatusMutation = useSetUserStatus();

  const handleStatusPress = async (statusId: number) => {
    if (!user) return;

    try {
      await setStatusMutation.mutateAsync({
        user_id: user.id,
        status_id: statusId,
        group_id: groupId || undefined, // Grup varsa gruba √∂zel, yoksa global
      });
    } catch (error) {
      console.error("Status update failed", error);
    }
  };

  if (isLoading) {
    return <ActivityIndicator size="small" color={colors.primary} />;
  }

  return (
    <View style={styles.container}>
      <Typography variant="h6" color={colors.text} style={styles.title}>
        Ne yapƒ±yorsun? üåø
      </Typography>
      
      <ScrollView 
        horizontal 
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.scrollContent}
      >
        {statuses?.map((status) => {
          const isActive = currentStatusId === status.id;
          
          // ƒ∞kon belirleme (Basit bir e≈üle≈ütirme)
          let iconName: keyof typeof Ionicons.glyphMap = 'radio-button-on'; 
          if (status.text.includes('M√ºsait')) iconName = 'checkmark-circle';
          else if (status.text.includes('Me≈ügul')) iconName = 'close-circle';
          else if (status.text.includes('Dƒ±≈üarƒ±')) iconName = 'walk';
          else if (status.text.includes('Ev')) iconName = 'home';
          else if (status.text.includes('√áalƒ±≈ü')) iconName = 'laptop';

          return (
            <GeliomButton
              key={status.id}
              state={isActive ? 'active' : 'passive'}
              size="small"
              layout="icon-left"
              icon={iconName}
              onPress={() => handleStatusPress(status.id)}
              disabled={setStatusMutation.isPending}
              style={styles.button}
            >
              {status.text}
            </GeliomButton>
          );
        })}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    marginVertical: 16,
  },
  title: {
    marginBottom: 12,
    paddingHorizontal: 4,
  },
  scrollContent: {
    gap: 8,
    paddingRight: 20,
  },
  button: {
    marginRight: 0,
  }
});
</file>

<file path="components/NotificationHandler.tsx">
import { useGroupContext } from '@/contexts/GroupContext';
import { useRouter } from 'expo-router';
import { useEffect } from 'react';
import { OneSignal } from 'react-native-onesignal';

/**
 * NotificationHandler Component
 * 
 * OneSignal bildirimlerini handle eder:
 * - Bildirime tƒ±klandƒ±ƒüƒ±nda ilgili gruba y√∂nlendirir
 * - GroupContext'i kullanarak grubu se√ßer
 */
export function NotificationHandler() {
  const router = useRouter();
  const { setSelectedGroup, groups } = useGroupContext();

  useEffect(() => {
    // Notification click handler
    const clickHandler = async (event: any) => {
      console.log('üîî OneSignal notification clicked:', event);
      
      // additionalData'dan grup bilgisini al
      const additionalData = event.notification.additionalData;
      const groupId = additionalData?.group_id as string | undefined;
      const groupName = additionalData?.group_name as string | undefined;

      if (!groupId) {
        console.warn('‚ö†Ô∏è Bildirimde group_id bulunamadƒ±');
        return;
      }

      console.log('‚úÖ Grup bilgisi alƒ±ndƒ±:', { groupId, groupName });

      // Gruplar y√ºkl√º deƒüilse bekle
      if (groups.length === 0) {
        console.warn('‚ö†Ô∏è Gruplar hen√ºz y√ºklenmedi, bekleniyor...');
        // Bir s√ºre sonra tekrar dene (basit retry mekanizmasƒ±)
        setTimeout(() => {
          const group = groups.find(g => g.id === groupId);
          if (group) {
            handleGroupNavigation(group);
          }
        }, 1000);
        return;
      }

      // Grubu bul
      const group = groups.find(g => g.id === groupId);
      if (!group) {
        console.warn('‚ö†Ô∏è Grup bulunamadƒ±:', groupId);
        return;
      }

      handleGroupNavigation(group);
    };

    const handleGroupNavigation = async (group: any) => {
      try {
        // Grubu se√ß
        await setSelectedGroup(group);
        console.log('‚úÖ Grup se√ßildi:', group.name);

        // Ana sayfaya y√∂nlendir
        router.push('/(drawer)/home');
        console.log('‚úÖ Ana sayfaya y√∂nlendirildi');
      } catch (error) {
        console.error('‚ùå Grup se√ßme hatasƒ±:', error);
      }
    };

    // Event listener'ƒ± ekle
    OneSignal.Notifications.addEventListener('click', clickHandler);

    // Cleanup
    return () => {
      OneSignal.Notifications.removeEventListener('click', clickHandler);
    };
  }, [router, setSelectedGroup, groups]);

  // Bu component g√∂r√ºnmez (sadece handler)
  return null;
}
</file>

<file path="docs/bildirim-sistemi.md">
# Bildirim Sistemi - Geliom

## üìã Genel Bakƒ±≈ü

Geliom projesinde bildirimler **OneSignal** kullanƒ±larak g√∂nderilir. Bildirimler grup bazlƒ±dƒ±r ve her bildirimde grup bilgisi bulunur.

## üéØ Bildirim Formatƒ±

### Title Formatƒ±
```
[Grup Adƒ±] - [Bildirim Ba≈ülƒ±ƒüƒ±]
```

**√ñrnek:**
- `Aile Grubu - Yeni Katƒ±lma ƒ∞steƒüi`
- `ƒ∞≈ü Arkada≈ülarƒ± - Durum G√ºncellendi`

### Body Formatƒ±
```
[Grup Adƒ±] grubundan: [Mesaj]
```

**√ñrnek:**
- `Aile Grubu grubundan: Ahmet grubunuza katƒ±lmak istiyor`
- `ƒ∞≈ü Arkada≈ülarƒ± grubundan: Mehmet durumunu "Toplantƒ±da" olarak g√ºncelledi`

### Additional Data
Her bildirimde ≈üu bilgiler g√∂nderilir:
```json
{
  "group_id": "uuid",
  "group_name": "Grup Adƒ±",
  "type": "join_request" | "join_request_status" | "status_update" | "mood_update" | "event_reminder"
}
```

## üîî Bildirim T√ºrleri

### 1. Katƒ±lma ƒ∞steƒüi (join_request)
- **G√∂nderen:** ƒ∞stek yapan kullanƒ±cƒ±
- **Alƒ±cƒ±:** Grup sahibi
- **Ba≈ülƒ±k:** `Yeni Katƒ±lma ƒ∞steƒüi`
- **Mesaj:** `[Kullanƒ±cƒ± Adƒ±] grubunuza katƒ±lmak istiyor`

### 2. Katƒ±lma ƒ∞steƒüi Durumu (join_request_status)
- **G√∂nderen:** Grup sahibi
- **Alƒ±cƒ±:** ƒ∞stek yapan kullanƒ±cƒ±
- **Ba≈ülƒ±k:** `Katƒ±lma ƒ∞steƒüi Onaylandƒ±` veya `Katƒ±lma ƒ∞steƒüi Reddedildi`
- **Mesaj:** `[Grup Adƒ±] grubuna katƒ±lma isteƒüiniz onaylandƒ±!` veya `[Grup Adƒ±] grubuna katƒ±lma isteƒüiniz reddedildi.`

### 3. Durum G√ºncellemesi (status_update)
- **G√∂nderen:** Durum g√ºncelleyen kullanƒ±cƒ±
- **Alƒ±cƒ±:** Grup √ºyeleri
- **Ba≈ülƒ±k:** `Durum G√ºncellendi`
- **Mesaj:** `[Kullanƒ±cƒ± Adƒ±] durumunu "[Durum]" olarak g√ºncelledi`

### 4. Mood G√ºncellemesi (mood_update)
- **G√∂nderen:** Mood g√ºncelleyen kullanƒ±cƒ±
- **Alƒ±cƒ±:** Grup √ºyeleri
- **Ba≈ülƒ±k:** `Mood G√ºncellendi`
- **Mesaj:** `[Kullanƒ±cƒ± Adƒ±] mood'unu "[Mood]" olarak g√ºncelledi`

### 5. Etkinlik Hatƒ±rlatƒ±cƒ±sƒ± (event_reminder)
- **G√∂nderen:** Sistem (zamanlanmƒ±≈ü)
- **Alƒ±cƒ±:** Grup √ºyeleri
- **Ba≈ülƒ±k:** `Etkinlik Hatƒ±rlatƒ±cƒ±sƒ±`
- **Mesaj:** `[Etkinlik Adƒ±] i√ßin 1 saat kaldƒ±!`

## üì± Bildirime Tƒ±klama Davranƒ±≈üƒ±

Kullanƒ±cƒ± bir bildirime tƒ±kladƒ±ƒüƒ±nda:

1. **NotificationHandler** component'i bildirimi yakalar
2. `additionalData`'dan `group_id` ve `group_name` alƒ±nƒ±r
3. **GroupContext** kullanƒ±larak ilgili grup se√ßilir
4. Kullanƒ±cƒ± **ana sayfaya** (`/(drawer)/home`) y√∂nlendirilir
5. Se√ßili grup otomatik olarak g√∂sterilir

## üèóÔ∏è Mimari

### 1. OneSignal Servisi (`services/onesignal.ts`)
- OneSignal SDK initialize
- Player ID alma
- Login/Logout i≈ülemleri
- Tag y√∂netimi

### 2. Notification Handler (`components/NotificationHandler.tsx`)
- Bildirim tƒ±klama event'lerini dinler
- Grup se√ßimi ve navigation yapar
- GroupContext ve Router kullanƒ±r

### 3. Bildirim API (`api/notifications.ts`)
- Supabase Edge Function'ƒ± √ßaƒüƒ±rƒ±r
- Farklƒ± bildirim t√ºrleri i√ßin helper fonksiyonlar
- Type-safe bildirim g√∂nderme

### 4. Supabase Edge Function (`supabase/functions/send-notification/index.ts`)
- OneSignal REST API'yi √ßaƒüƒ±rƒ±r
- Bildirim formatƒ±nƒ± olu≈üturur
- CORS desteƒüi

## üîß Entegrasyon Noktalarƒ±

### Grup Katƒ±lma ƒ∞steƒüi
- **Dosya:** `api/groups.ts`
- **Hook:** `useCreateJoinRequest`
- **Bildirim:** Grup sahibine katƒ±lma isteƒüi bildirimi

### ƒ∞stek Onaylama/Reddetme
- **Dosya:** `api/groups.ts`
- **Hook'lar:** `useApproveJoinRequest`, `useRejectJoinRequest`
- **Bildirim:** ƒ∞stek yapan kullanƒ±cƒ±ya durum bildirimi

## ‚öôÔ∏è Kurulum

### 1. OneSignal App ID
`app.json` dosyasƒ±nda tanƒ±mlƒ±:
```json
{
  "extra": {
    "oneSignalAppId": "dbee675a-f056-44f4-8cfc-77075183897d"
  }
}
```

### 2. Supabase Edge Function Environment Variables
```bash
ONESIGNAL_APP_ID=your-app-id
ONESIGNAL_REST_API_KEY=your-rest-api-key
```

### 3. Edge Function Deploy
```bash
supabase functions deploy send-notification
```

## üìù Notlar

- Bildirim g√∂nderme i≈ülemleri **non-blocking**'dir (hata olsa bile uygulama √ßalƒ±≈ümaya devam eder)
- Player ID'ler kullanƒ±cƒ± giri≈ü yaptƒ±ƒüƒ±nda otomatik olarak kaydedilir
- Bildirimler grup bazlƒ±dƒ±r, her bildirimde grup bilgisi bulunur
- Bildirime tƒ±klandƒ±ƒüƒ±nda kullanƒ±cƒ± ilgili gruba y√∂nlendirilir
</file>

<file path="docs/cron-job-setup.md">
# Supabase Cron Job Kurulumu

## Process Pending Notifications Cron Job

`process-pending-notifications` Edge Function'ƒ±nƒ± her dakika √ßalƒ±≈ütƒ±rmak i√ßin Supabase cron job kurulumu:

### 1. Supabase Dashboard'dan Kurulum

1. Supabase Dashboard ‚Üí Database ‚Üí Cron Jobs
2. "New Cron Job" butonuna tƒ±kla
3. A≈üaƒüƒ±daki ayarlarƒ± yap:

**Job Name:** `process-pending-notifications`

**Schedule:** `* * * * *` (Her dakika)

**Command:**
```sql
SELECT net.http_post(
  url := 'https://jtqmntczxkdmftoqspdx.supabase.co/functions/v1/process-pending-notifications',
  headers := jsonb_build_object(
    'Content-Type', 'application/json',
    'Authorization', 'Bearer YOUR_SERVICE_ROLE_KEY'
  ),
  body := '{}'::jsonb
);
```

**NOT:** 
- `YOUR_PROJECT_REF` ‚Üí Supabase proje referansƒ±nƒ±z
- `YOUR_SERVICE_ROLE_KEY` ‚Üí Supabase Service Role Key (Settings ‚Üí API)

### 2. Alternatif: pg_cron Extension Kullanƒ±mƒ±

Eƒüer Supabase Dashboard'da cron job √∂zelliƒüi yoksa, `pg_cron` extension'ƒ±nƒ± kullanabilirsiniz:

```sql
-- pg_cron extension'ƒ±nƒ± etkinle≈ütir
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Cron job olu≈ütur
SELECT cron.schedule(
  'process-pending-notifications',
  '* * * * *', -- Her dakika
  $$
  SELECT net.http_post(
    url := 'https://YOUR_PROJECT_REF.supabase.co/functions/v1/process-pending-notifications',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer YOUR_SERVICE_ROLE_KEY'
    ),
    body := '{}'::jsonb
  );
  $$
);
```

### 3. Cron Job Kontrol√º

Cron job'un √ßalƒ±≈üƒ±p √ßalƒ±≈ümadƒ±ƒüƒ±nƒ± kontrol etmek i√ßin:

```sql
-- Aktif cron job'larƒ± listele
SELECT * FROM cron.job;

-- Cron job ge√ßmi≈üini g√∂r√ºnt√ºle
SELECT * FROM cron.job_run_details 
WHERE jobid = (SELECT jobid FROM cron.job WHERE jobname = 'process-pending-notifications')
ORDER BY start_time DESC 
LIMIT 10;
```

### 4. Cron Job'u Durdurma

```sql
-- Cron job'u durdur
SELECT cron.unschedule('process-pending-notifications');
```

### 5. Test

Cron job'un √ßalƒ±≈ütƒ±ƒüƒ±nƒ± test etmek i√ßin:

1. Bir kullanƒ±cƒ± status'unu deƒüi≈ütir
2. `pending_notifications` tablosunda kayƒ±t olu≈ütuƒüunu kontrol et
3. 1 dakika sonra kaydƒ±n silindiƒüini ve bildirimin g√∂nderildiƒüini kontrol et

### 6. Edge Function URL

Edge Function URL'ini bulmak i√ßin:
- Supabase Dashboard ‚Üí Edge Functions ‚Üí `process-pending-notifications`
- URL: `https://YOUR_PROJECT_REF.supabase.co/functions/v1/process-pending-notifications`
</file>

<file path="docs/database-migration-status-notifications.sql">
-- Database Migration: Status Bildirim Sistemi
-- Bu migration, status bildirimleri i√ßin messages kolonu ve pending_notifications tablosunu ekler

-- ============================================
-- 1. statuses Tablosuna Messages Kolonu Ekle
-- ============================================

ALTER TABLE public.statuses 
ADD COLUMN IF NOT EXISTS messages TEXT[] NULL;

-- √ñrnek mesajlar ekle (default status'ler i√ßin)
-- Not: Bu mesajlar admin panelinden veya seed script'ten eklenebilir
-- √ñrnek:
-- UPDATE public.statuses 
-- SET messages = ARRAY['{name} artƒ±k m√ºsait!', '{name} ≈üimdi m√ºsait durumda', '{name} m√ºsait oldu']
-- WHERE text = 'M√ºsaitim' AND notifies = true;

-- ============================================
-- 2. pending_notifications Tablosu Olu≈ütur
-- ============================================

CREATE TABLE IF NOT EXISTS public.pending_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sender_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  receiver_ids UUID[] NOT NULL,
  group_id UUID NOT NULL REFERENCES public.groups(id) ON DELETE CASCADE,
  status_id INTEGER NOT NULL REFERENCES public.statuses(id) ON DELETE CASCADE,
  scheduled_at TIMESTAMP WITH TIME ZONE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Bir kullanƒ±cƒ±nƒ±n aynƒ± grup i√ßin sadece 1 pending bildirimi olabilir
  CONSTRAINT pending_notifications_sender_group_unique UNIQUE (sender_id, group_id)
);

-- Index'ler (performans i√ßin)
CREATE INDEX IF NOT EXISTS idx_pending_notifications_scheduled_at 
ON public.pending_notifications(scheduled_at);

CREATE INDEX IF NOT EXISTS idx_pending_notifications_sender_id 
ON public.pending_notifications(sender_id);

CREATE INDEX IF NOT EXISTS idx_pending_notifications_group_id 
ON public.pending_notifications(group_id);

-- ============================================
-- 3. updated_at Trigger Fonksiyonu
-- ============================================

CREATE OR REPLACE FUNCTION update_pending_notifications_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger ekle
DROP TRIGGER IF EXISTS trigger_update_pending_notifications_updated_at ON public.pending_notifications;
CREATE TRIGGER trigger_update_pending_notifications_updated_at
  BEFORE UPDATE ON public.pending_notifications
  FOR EACH ROW
  EXECUTE FUNCTION update_pending_notifications_updated_at();
</file>

<file path="docs/database-rate-limiting-migration.sql">
-- Rate Limiting Tablosu
-- Bildirim spam'ini √∂nlemek i√ßin kullanƒ±lƒ±r

CREATE TABLE IF NOT EXISTS public.notification_rate_limits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sender_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  receiver_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  group_id UUID REFERENCES groups(id) ON DELETE CASCADE,
  notification_type TEXT NOT NULL CHECK (notification_type IN (
    'join_request',
    'join_request_status',
    'direct_invite',
    'status_update',
    'mood_update',
    'event_reminder'
  )),
  last_sent_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(sender_id, receiver_id, group_id, notification_type)
);

-- Index'ler (performans i√ßin)
CREATE INDEX IF NOT EXISTS idx_rate_limits_sender_receiver 
  ON notification_rate_limits(sender_id, receiver_id);
CREATE INDEX IF NOT EXISTS idx_rate_limits_group 
  ON notification_rate_limits(group_id);
CREATE INDEX IF NOT EXISTS idx_rate_limits_type 
  ON notification_rate_limits(notification_type);
CREATE INDEX IF NOT EXISTS idx_rate_limits_last_sent 
  ON notification_rate_limits(last_sent_at);

-- Eski kayƒ±tlarƒ± temizlemek i√ßin function (24 saatten eski)
CREATE OR REPLACE FUNCTION cleanup_old_rate_limits()
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  DELETE FROM notification_rate_limits
  WHERE last_sent_at < NOW() - INTERVAL '24 hours';
END;
$$;

-- Rate limit kontrol√º i√ßin helper function
CREATE OR REPLACE FUNCTION check_rate_limit(
  p_sender_id UUID,
  p_receiver_id UUID,
  p_group_id UUID,
  p_notification_type TEXT,
  p_limit_minutes INTEGER
)
RETURNS TABLE(
  can_send BOOLEAN,
  wait_until TIMESTAMP WITH TIME ZONE
)
LANGUAGE plpgsql
AS $$
DECLARE
  v_last_sent_at TIMESTAMP WITH TIME ZONE;
  v_wait_until TIMESTAMP WITH TIME ZONE;
  v_can_send BOOLEAN;
BEGIN
  -- Son g√∂nderim zamanƒ±nƒ± al
  SELECT nrl.last_sent_at INTO v_last_sent_at
  FROM notification_rate_limits nrl
  WHERE nrl.sender_id = p_sender_id
    AND nrl.receiver_id = p_receiver_id
    AND (p_group_id IS NULL OR nrl.group_id = p_group_id)
    AND nrl.notification_type = p_notification_type;

  -- Eƒüer kayƒ±t yoksa, g√∂nderebilir
  IF v_last_sent_at IS NULL THEN
    v_can_send := TRUE;
    v_wait_until := NOW();
  ELSE
    -- Bekleme s√ºresini hesapla
    v_wait_until := v_last_sent_at + (p_limit_minutes || ' minutes')::INTERVAL;

    -- ≈ûu anki zaman beklenen zamandan sonra mƒ±?
    IF NOW() >= v_wait_until THEN
      v_can_send := TRUE;
    ELSE
      v_can_send := FALSE;
    END IF;
  END IF;

  -- Eƒüer g√∂nderebiliyorsa, kaydƒ± g√ºncelle/ekle
  IF v_can_send THEN
    INSERT INTO notification_rate_limits (
      sender_id, receiver_id, group_id, notification_type, last_sent_at
    )
    VALUES (
      p_sender_id, p_receiver_id, p_group_id, p_notification_type, NOW()
    )
    ON CONFLICT (sender_id, receiver_id, group_id, notification_type)
    DO UPDATE SET last_sent_at = NOW();
  END IF;

  -- Sonucu d√∂nd√ºr
  RETURN QUERY SELECT v_can_send, v_wait_until;
END;
$$;

-- RLS (Row Level Security) - ≈ûimdilik kapalƒ±, proje bitiminde a√ßƒ±lacak
-- ALTER TABLE notification_rate_limits ENABLE ROW LEVEL SECURITY;
</file>

<file path="docs/edge-function-secrets-setup.md">
# Supabase Edge Function Secrets Kurulumu

## OneSignal REST API Key Ekleme

Edge Function'larƒ±n √ßalƒ±≈ümasƒ± i√ßin OneSignal REST API Key'i Supabase Secrets'a eklenmelidir.

### Adƒ±mlar

1. **OneSignal Dashboard'dan REST API Key'i al:**
   - OneSignal Dashboard ‚Üí Settings ‚Üí Keys & IDs
   - **REST API Key**'i kopyala

2. **Supabase Dashboard'a git:**
   - Supabase Dashboard ‚Üí Edge Functions ‚Üí Settings ‚Üí Secrets

3. **Secret ekle:**
   - **Name:** `ONESIGNAL_REST_API_KEY`
   - **Value:** OneSignal REST API Key (kopyaladƒ±ƒüƒ±n deƒüer)
   - **Save**

4. **Diƒüer gerekli secrets:**
   - `ONESIGNAL_APP_ID` - OneSignal App ID (zaten var olabilir)
   - `SUPABASE_URL` - Otomatik eklenir
   - `SUPABASE_SERVICE_ROLE_KEY` - Otomatik eklenir

### Kontrol

Edge Function log'larƒ±nda ≈üu hata g√∂r√ºnmemeli:
```
‚ùå ONESIGNAL_REST_API_KEY environment variable eksik!
```

Eƒüer g√∂r√ºn√ºyorsa, secret'ƒ± eklediƒüinden emin ol.

### Test

Edge Function'ƒ± test et:
- Supabase Dashboard ‚Üí Edge Functions ‚Üí `send-notification` ‚Üí Test
- Body'ye test payload'ƒ± ekle
- Invoke et
- Log'larƒ± kontrol et

## SQL Fonksiyonu G√ºncelleme

`check_rate_limit` fonksiyonunu g√ºncellemek i√ßin:

1. Supabase Dashboard ‚Üí SQL Editor
2. `docs/database-rate-limiting-migration.sql` dosyasƒ±ndaki `check_rate_limit` fonksiyonunu √ßalƒ±≈ütƒ±r
3. Fonksiyon g√ºncellenecek

### Deƒüi≈üiklikler

- `RETURNS TABLE`'dan `last_sent_at` kaldƒ±rƒ±ldƒ± (ambiguous hatasƒ± i√ßin)
- Sadece `can_send` ve `wait_until` d√∂nd√ºr√ºyor
- SELECT'te tablo alias kullanƒ±lƒ±yor (`nrl.last_sent_at`)
</file>

<file path="docs/expo-notifications-kullanim.md">
# expo-notifications Kullanƒ±mƒ± - Geliom Projesi

## üì± expo-notifications Ne ƒ∞≈üe Yarar?

`expo-notifications` paketi, **local notifications** (cihazda zamanlanmƒ±≈ü bildirimler) g√∂ndermek i√ßin kullanƒ±lƒ±r.

## üéØ Projede Kullanƒ±m Alanlarƒ±

### 1. Zamanlanmƒ±≈ü Etkinlikler (Faz 4 - Premium √ñzellik)

**Kullanƒ±m Senaryosu:**
- Premium kullanƒ±cƒ± bir grup i√ßin etkinlik olu≈üturur (√∂rn: "Cumartesi Kahvaltƒ±sƒ±")
- Etkinlik tarihi: 2025-01-25 10:00
- Bildirim zamanƒ±: 2025-01-25 09:00 (1 saat √∂nce)

**Nasƒ±l √áalƒ±≈üƒ±r:**
1. Kullanƒ±cƒ± etkinlik olu≈üturduƒüunda `scheduled_events` tablosuna kaydedilir
2. `expo-notifications` ile cihazda **local notification** zamanlanƒ±r
3. Bildirim zamanƒ± geldiƒüinde cihazda bildirim g√∂sterilir
4. Kullanƒ±cƒ± bildirime tƒ±klayƒ±nca uygulama a√ßƒ±lƒ±r ve etkinlik detayƒ±na gider

**√ñrnek Kullanƒ±m:**
```typescript
import * as Notifications from 'expo-notifications';

// Etkinlik olu≈üturulduƒüunda
const scheduleNotification = async (event: ScheduledEvent) => {
  if (event.notification_time) {
    await Notifications.scheduleNotificationAsync({
      content: {
        title: 'Etkinlik Hatƒ±rlatƒ±cƒ±sƒ±',
        body: `${event.title} i√ßin 1 saat kaldƒ±!`,
        data: { eventId: event.id, groupId: event.group_id },
      },
      trigger: {
        date: new Date(event.notification_time),
      },
    });
  }
};
```

## üîî OneSignal vs expo-notifications Farkƒ±

### OneSignal (react-native-onesignal)
- **Push Notifications** (sunucudan g√∂nderilen)
- ƒ∞nternet baƒülantƒ±sƒ± gerekir
- Kullanƒ±cƒ± uygulamayƒ± kapatsa bile √ßalƒ±≈üƒ±r
- **Kullanƒ±m:** Grup katƒ±lma istekleri, durum g√ºncellemeleri, direkt mesajlar

### expo-notifications
- **Local Notifications** (cihazda zamanlanan)
- ƒ∞nternet baƒülantƒ±sƒ± gerekmez
- Uygulama kapalƒ± olsa bile √ßalƒ±≈üƒ±r (iOS/Android native √∂zellik)
- **Kullanƒ±m:** Zamanlanmƒ±≈ü etkinlik hatƒ±rlatƒ±cƒ±larƒ±

## üìã Kullanƒ±m Senaryolarƒ±

### Senaryo 1: Etkinlik Hatƒ±rlatƒ±cƒ±sƒ±
```
Kullanƒ±cƒ±: "Yarƒ±n 10:00'da kahvaltƒ± var"
Bildirim: "Yarƒ±n 09:00'da" ‚Üí "Kahvaltƒ± i√ßin 1 saat kaldƒ±!"
```

### Senaryo 2: Tekrarlayan Hatƒ±rlatƒ±cƒ±lar (Gelecekte)
```
Her hafta Pazar g√ºn√º 18:00'da ‚Üí "Haftalƒ±k toplantƒ± zamanƒ±!"
```

## ‚öôÔ∏è Teknik Detaylar

### Bildirim ƒ∞zinleri
- iOS: Kullanƒ±cƒ±dan izin istenir
- Android: Otomatik izin verilir (Android 13+ i√ßin izin gerekir)

### Bildirim Zamanlama
- Maksimum 64 bildirim aynƒ± anda zamanlanabilir
- Bildirimler cihaz yeniden ba≈ülatƒ±ldƒ±ƒüƒ±nda kaybolur (yeniden zamanlanmalƒ±)

### Bildirim Tƒ±klama
- Bildirime tƒ±klandƒ±ƒüƒ±nda uygulama a√ßƒ±lƒ±r
- `data` objesi ile etkinlik ID'si g√∂nderilir
- Uygulama a√ßƒ±ldƒ±ƒüƒ±nda ilgili ekrana y√∂nlendirilir

## üöÄ Gelecek Kullanƒ±mlar

1. **Etkinlik Hatƒ±rlatƒ±cƒ±larƒ±** (Faz 4)
2. **G√ºnl√ºk Hatƒ±rlatƒ±cƒ±lar** (Gelecekte)
3. **Tekrarlayan Bildirimler** (Gelecekte)

## üìù Notlar

- `expo-notifications` sadece **local notifications** i√ßin
- **Push notifications** i√ßin `OneSignal` kullanƒ±lacak
- ƒ∞kisi birlikte kullanƒ±labilir (farklƒ± ama√ßlar i√ßin)
</file>

<file path="docs/faz2-todo.md">
# Faz 2: Grup Katƒ±lma Sistemi ve Bildirimler - Yapƒ±lacaklar Listesi

## üìã Genel Bakƒ±≈ü
Grup katƒ±lma onay sistemi ve bildirim altyapƒ±sƒ±nƒ± kurmak.

---

## üóÑÔ∏è 1. Veritabanƒ± ƒ∞≈ülemleri

### 1.1. `group_join_requests` Tablosu Olu≈üturma
- ‚úÖ Supabase SQL Editor'de yeni tablo olu≈ütur:
  ```sql
  CREATE TABLE public.group_join_requests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    group_id UUID NOT NULL REFERENCES groups(id) ON DELETE CASCADE,
    requester_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(group_id, requester_id) -- Aynƒ± kullanƒ±cƒ± aynƒ± gruba tekrar istek g√∂nderemez
  );
  ```
- [ ] RLS (Row Level Security) politikalarƒ± ekle:
  - [ ] Grup kurucusu t√ºm istekleri g√∂rebilir
  - [ ] ƒ∞stek sahibi kendi isteklerini g√∂rebilir
  - [ ] ƒ∞stek sahibi yeni istek olu≈üturabilir
  - [ ] Grup kurucusu istekleri onaylayƒ±p reddedebilir
- [ ] Index'ler ekle (performans i√ßin):
  - [ ] `group_id` √ºzerinde index
  - [ ] `requester_id` √ºzerinde index
  - [ ] `status` √ºzerinde index

### 1.2. TypeScript Tipleri G√ºncelleme
- ‚úÖ `types/database.ts` dosyasƒ±na `GroupJoinRequest` interface'i ekle
- ‚úÖ `CreateGroupJoinRequest` ve `UpdateGroupJoinRequest` tiplerini ekle
- ‚úÖ `GroupJoinRequestWithDetails` interface'i eklendi

---

## üîç 2. Kullanƒ±cƒ± Arama ve Davet Sistemi

### 2.1. API Hook'larƒ±
- ‚úÖ `api/users.ts` dosyasƒ±na `useUserByCustomId` hook'u ekle (zaten mevcut)
- ‚úÖ Custom user ID ile kullanƒ±cƒ± arama fonksiyonu yaz (zaten mevcut)

### 2.2. UI Component'leri
- ‚úÖ **Ekran: Kullanƒ±cƒ± Arama Ekranƒ±** (`app/(drawer)/(group)/search-user.tsx`)
  - ‚úÖ Arama input'u (custom_user_id i√ßin)
  - ‚úÖ Arama butonu
  - ‚úÖ Bulunan kullanƒ±cƒ± kartƒ± (display_name, custom_user_id, email)
  - ‚úÖ Bulunan kullanƒ±cƒ±ya davet g√∂nderme butonu
  - ‚úÖ Se√ßili grup bilgisi g√∂sterimi
  - ‚úÖ Grup se√ßilmedi uyarƒ±sƒ±
  - ‚úÖ Hata mesajlarƒ± ve validasyon
- ‚úÖ DashboardView'e "Kullanƒ±cƒ± Ara ve Davet Et" butonu eklendi (sadece owner i√ßin)

---

## üìù 3. Grup Katƒ±lma ƒ∞steƒüi G√∂nderme

### 3.1. API Hook'larƒ±
- ‚úÖ `api/groups.ts` dosyasƒ±na ≈üu hook'larƒ± ekle:
  - ‚úÖ `useCreateJoinRequest` - Katƒ±lma isteƒüi g√∂nderme
  - ‚úÖ `useGroupJoinRequests` - Grup i√ßin bekleyen istekleri getirme
  - ‚úÖ `useMyJoinRequests` - Kullanƒ±cƒ±nƒ±n g√∂nderdiƒüi istekleri getirme

### 3.2. UI Component'leri
- ‚úÖ **Ekran: Grup Katƒ±lma Ekranƒ±** (`app/(drawer)/(group)/join-group.tsx`)
  - ‚úÖ Davet kodu input'u
  - ‚úÖ "Katƒ±lma ƒ∞steƒüi G√∂nder" butonu
  - ‚úÖ Grup bilgisi g√∂sterimi (kod ge√ßerliyse)
  - ‚úÖ Hata mesajlarƒ± ve validasyon
- ‚úÖ Ana ekranda "Gruba Katƒ±l" butonu eklendi (EmptyStateView'de)

---

## ‚úÖ 4. Grup Katƒ±lma ƒ∞stekleri Y√∂netimi (Grup Kurucusu)

### 4.1. API Hook'larƒ±
- ‚úÖ `api/groups.ts` dosyasƒ±na ≈üu hook'larƒ± ekle:
  - ‚úÖ `useApproveJoinRequest` - ƒ∞steƒüi onaylama mutation
  - ‚úÖ `useRejectJoinRequest` - ƒ∞steƒüi reddetme mutation
  - ‚úÖ `useGroupJoinRequests` - Grup i√ßin t√ºm istekleri getirme (owner i√ßin)

### 4.2. UI Component'leri
- ‚úÖ **Ekran: Grup Katƒ±lma ƒ∞stekleri** (`app/(drawer)/(group)/join-requests.tsx`)
  - ‚úÖ Bekleyen istekler listesi (pending)
  - ‚úÖ Her istek i√ßin:
    - ‚úÖ Kullanƒ±cƒ± bilgileri (display_name, custom_user_id, photo_url)
    - ‚úÖ ƒ∞stek zamanƒ± (created_at)
    - ‚úÖ "Onayla" butonu
    - ‚úÖ "Reddet" butonu
  - ‚úÖ Empty state (istek yoksa)
  - ‚úÖ Pull-to-refresh (yenileme)
  - ‚úÖ Owner kontrol√º (sadece owner g√∂rebilir)
  - ‚úÖ Grup se√ßilmedi durumu
- ‚úÖ DashboardView'e "Katƒ±lma ƒ∞stekleri" butonu eklendi (sadece owner i√ßin, badge ile sayƒ± g√∂sterimi)
- ‚úÖ DashboardView'e "Ba≈üka Gruba Katƒ±l" butonu eklendi (her zaman g√∂r√ºn√ºr)

### 4.3. Backend Logic
- ‚úÖ ƒ∞stek onaylandƒ±ƒüƒ±nda:
  - ‚úÖ `group_members` tablosuna yeni kayƒ±t ekle (useApproveJoinRequest i√ßinde)
  - ‚úÖ ƒ∞stek durumunu `approved` yap (useApproveJoinRequest i√ßinde)
  - [ ] Kullanƒ±cƒ±ya bildirim g√∂nder (OneSignal) - Faz 2'nin sonunda
- ‚úÖ ƒ∞stek reddedildiƒüinde:
  - ‚úÖ ƒ∞stek durumunu `rejected` yap (useRejectJoinRequest i√ßinde)
  - [ ] Kullanƒ±cƒ±ya bildirim g√∂nder (OneSignal) - Faz 2'nin sonunda

---

## üîî 5. Bildirim Sistemi (OneSignal)

### 5.1. OneSignal SDK Entegrasyonu
- ‚úÖ `package.json`'a `react-native-onesignal` paketini ekle
- ‚úÖ OneSignal'ƒ± initialize et (`app/Provider.tsx` ve `services/onesignal.ts`)
- ‚úÖ Kullanƒ±cƒ± giri≈ü yaptƒ±ƒüƒ±nda `onesignal_player_id`'yi al
- ‚úÖ `users` tablosuna `onesignal_player_id` kolonunu ekle (zaten var)
- ‚úÖ Kullanƒ±cƒ± profil g√ºncellemesinde `onesignal_player_id`'yi kaydet
- ‚úÖ OneSignal login/logout entegrasyonu (external ID ile)

### 5.2. Bildirim G√∂nderme
- ‚úÖ **Supabase Edge Function: `send-notification`**
  - ‚úÖ OneSignal API key'ini environment variable olarak ekle (dok√ºmantasyonda belirtildi)
  - ‚úÖ Grup √ºyelerine bildirim g√∂nderme fonksiyonu
  - ‚úÖ Kullanƒ±cƒ±ya bildirim g√∂nderme fonksiyonu
- ‚úÖ **Bildirim G√∂nderme Entegrasyonu**
  - ‚úÖ `useCreateJoinRequest` hook'unda grup sahibine bildirim g√∂nderme
  - ‚úÖ `useApproveJoinRequest` hook'unda istek yapan kullanƒ±cƒ±ya bildirim g√∂nderme
  - ‚úÖ `useRejectJoinRequest` hook'unda istek yapan kullanƒ±cƒ±ya bildirim g√∂nderme
- ‚úÖ **Bildirim Tƒ±klama Handler**
  - ‚úÖ `NotificationHandler` component'i olu≈üturuldu
  - ‚úÖ Bildirime tƒ±klandƒ±ƒüƒ±nda grup se√ßimi ve navigation
  - ‚úÖ Provider'a entegre edildi

### 5.3. Bildirim ƒ∞√ßerikleri
- ‚úÖ Katƒ±lma isteƒüi geldiƒüinde: "[Grup Adƒ±] - Yeni Katƒ±lma ƒ∞steƒüi" / "[Kullanƒ±cƒ± Adƒ±] grubunuza katƒ±lmak istiyor"
- ‚úÖ ƒ∞stek onaylandƒ±ƒüƒ±nda: "[Grup Adƒ±] - Katƒ±lma ƒ∞steƒüi Onaylandƒ±" / "[Grup Adƒ±] grubuna katƒ±lma isteƒüiniz onaylandƒ±!"
- ‚úÖ ƒ∞stek reddedildiƒüinde: "[Grup Adƒ±] - Katƒ±lma ƒ∞steƒüi Reddedildi" / "[Grup Adƒ±] grubuna katƒ±lma isteƒüiniz reddedildi."
- ‚è≥ Direkt davet geldiƒüinde: "X kullanƒ±cƒ±sƒ± sizi Y grubuna davet etti" (Faz 3'te eklenecek)

---

## üîÑ 6. Realtime G√ºncellemeleri

### 6.1. Supabase Realtime Subscription
- ‚úÖ `api/groups.ts` dosyasƒ±na `useGroupJoinRequestsRealtime` hook'u ekle
- ‚úÖ `api/groups.ts` dosyasƒ±na `useMyJoinRequestsRealtime` hook'u ekle
- ‚úÖ Grup kurucusu i√ßin isteklerin anlƒ±k g√ºncellenmesi (`join-requests.tsx` ve `DashboardView.tsx`)
- ‚úÖ ƒ∞stek sahibi i√ßin durum deƒüi≈üikliklerinin anlƒ±k g√ºncellenmesi (hook hazƒ±r, kullanƒ±m i√ßin ekran gerekli)
- ‚úÖ Export'lar `api/index.ts`'e eklendi

---

## üé® 7. UI/UX ƒ∞yile≈ütirmeleri

### 7.1. Mevcut Ekranlara Entegrasyon
- [ ] Ana ekrana "Gruba Katƒ±l" butonu ekle
- [ ] Grup detay ekranƒ±na "Katƒ±lma ƒ∞stekleri" butonu ekle (sadece owner)
- [ ] Grup listesinde bekleyen istek sayƒ±sƒ±nƒ± g√∂ster (badge)

### 7.2. Navigation
- [ ] Drawer navigation'a yeni ekranlar ekle:
  - [ ] "Gruba Katƒ±l" ekranƒ±
  - [ ] "Kullanƒ±cƒ± Ara" ekranƒ±
  - [ ] "Katƒ±lma ƒ∞stekleri" ekranƒ± (sadece grup owner'larƒ± i√ßin)

---

## üß™ 8. Test ve Doƒürulama

### 8.1. Fonksiyonel Testler
- [ ] Davet kodu ile katƒ±lma isteƒüi g√∂nderme
- [ ] Custom user ID ile kullanƒ±cƒ± arama
- [ ] Direkt davet g√∂nderme
- [ ] ƒ∞stek onaylama/reddetme
- [ ] Bildirimlerin doƒüru g√∂nderilmesi
- [ ] Realtime g√ºncellemelerinin √ßalƒ±≈ümasƒ±

### 8.2. Edge Case'ler
- [ ] Aynƒ± kullanƒ±cƒ± aynƒ± gruba tekrar istek g√∂nderemez
- [ ] Zaten √ºye olan kullanƒ±cƒ± istek g√∂nderemez
- [ ] Grup limiti dolduƒüunda istek g√∂nderilemez
- [ ] Silinen grup i√ßin istekler temizlenir

---

## üìù 9. Dok√ºmantasyon

### 9.1. Kod Dok√ºmantasyonu
- [ ] Yeni API hook'larƒ± i√ßin JSDoc yorumlarƒ±
- [ ] Yeni component'ler i√ßin kullanƒ±m √∂rnekleri

### 9.2. Kullanƒ±cƒ± Dok√ºmantasyonu
- [ ] Grup katƒ±lma akƒ±≈üƒ±nƒ± a√ßƒ±klayan dok√ºman
- [ ] Bildirim ayarlarƒ± dok√ºmanƒ±

---

## ‚úÖ Tamamlanma Kriterleri

Faz 2 tamamlanmƒ±≈ü sayƒ±lƒ±r eƒüer:
- ‚úÖ Kullanƒ±cƒ±lar davet kodu ile grup katƒ±lma isteƒüi g√∂nderebiliyor
- ‚úÖ Kullanƒ±cƒ±lar custom user ID ile arama yapƒ±p direkt davet g√∂nderebiliyor
- ‚úÖ Grup kurucularƒ± katƒ±lma isteklerini g√∂r√ºp onaylayƒ±p reddedebiliyor
- ‚úÖ Bildirimler doƒüru ≈üekilde g√∂nderiliyor (rate limiting ile)
- ‚úÖ Realtime g√ºncellemeler √ßalƒ±≈üƒ±yor
- ‚úÖ T√ºm edge case'ler handle ediliyor (tekrar istek g√∂nderme, zaten √ºye kontrol√º)

---

## üöÄ √ñncelik Sƒ±rasƒ±

1. **Y√ºksek √ñncelik:**
   - Veritabanƒ± tablosu olu≈üturma
   - API hook'larƒ±
   - Temel UI ekranlarƒ±
   - Bildirim sistemi

2. **Orta √ñncelik:**
   - Realtime g√ºncellemeler
   - UI iyile≈ütirmeleri
   - Edge case handling

3. **D√º≈ü√ºk √ñncelik:**
   - Dok√ºmantasyon
   - Test coverage artƒ±rma
</file>

<file path="docs/future-packages.md">
# Gelecekte Gerekli Paketler - Prebuild √ñncesi Y√ºkleme Listesi

## üì¶ ≈ûimdiden Y√ºklenmesi Gereken Paketler

### 1. Bildirimler (Faz 2+)
- ‚úÖ `expo-notifications` - Local notifications i√ßin (zamanlanmƒ±≈ü etkinlikler)

### 2. Diƒüer Yararlƒ± Paketler
- ‚úÖ `expo-sharing` - Dosya payla≈üƒ±mƒ± i√ßin (gelecekte gerekebilir)

## üìù Notlar

- Profil fotoƒürafƒ± y√ºkleme i√ßin paketler (expo-image-picker, expo-file-system, expo-media-library) ≈üimdilik y√ºklenmedi
- ƒ∞htiya√ß duyulduƒüunda prebuild sonrasƒ± da eklenebilir

## ‚ö†Ô∏è Firebase Paketleri (≈ûimdilik EKLEMEYƒ∞N)

Firebase Analytics ve Crashlytics i√ßin native mod√ºl gerektirir ve Expo managed workflow'da sorun √ßƒ±karabilir. 
Prebuild sonrasƒ± gerekirse eklenebilir veya EAS Build kullanƒ±labilir.

## ‚úÖ Zaten Y√ºkl√º Olan Paketler

- ‚úÖ `react-native-onesignal` - Bildirimler i√ßin
- ‚úÖ `onesignal-expo-plugin` - OneSignal plugin
- ‚úÖ `react-native-adapty` - Abonelik y√∂netimi i√ßin
- ‚úÖ T√ºm native mod√ºller (reanimated, gesture-handler, screens, vb.)
</file>

<file path="docs/onesignal-api-key-setup.md">
# OneSignal REST API Key Kurulum Rehberi

Bu dok√ºmantasyon, OneSignal REST API Key'in nasƒ±l alƒ±nacaƒüƒ±nƒ±, doƒüru formatta nasƒ±l ayarlanacaƒüƒ±nƒ± ve Supabase Edge Functions'da nasƒ±l kullanƒ±lacaƒüƒ±nƒ± a√ßƒ±klar.

## OneSignal REST API Key Nedir?

OneSignal REST API Key, OneSignal REST API'yi kullanarak bildirim g√∂ndermek i√ßin gereken bir kimlik doƒürulama anahtarƒ±dƒ±r. Bu key, Supabase Edge Function (`send-notification`) tarafƒ±ndan OneSignal API'ye istek g√∂nderirken kullanƒ±lƒ±r.

## OneSignal REST API Key Nasƒ±l Alƒ±nƒ±r?

1. **OneSignal Dashboard'a giri≈ü yapƒ±n**
   - [OneSignal Dashboard](https://app.onesignal.com/) adresine gidin
   - Giri≈ü yapƒ±n

2. **Settings ‚Üí Keys & IDs b√∂l√ºm√ºne gidin**
   - Sol men√ºden **Settings** se√ßeneƒüine tƒ±klayƒ±n
   - **Keys & IDs** sekmesine gidin

3. **REST API Key'i kopyalayƒ±n**
   - **REST API Key** b√∂l√ºm√ºnde **"Show"** butonuna tƒ±klayƒ±n
   - API Key'i kopyalayƒ±n
   - ‚ö†Ô∏è **√ñNEMLƒ∞**: API Key'i g√ºvenli bir yerde saklayƒ±n, bir daha g√∂sterilmeyecek!

## OneSignal REST API Key Formatƒ±

- **Uzunluk**: Genellikle 40-50 karakter arasƒ± (bazƒ± durumlarda daha uzun olabilir)
- **Karakter Seti**: Alphanumerik karakterler ve bazƒ± √∂zel karakterler (`-`, `_`, vb.)
- **Format**: Base64 benzeri bir string (√∂rn: `YjE2MTYxMjEtOTBiNS00Y2IwLWEzZWUtOWUxOGYyZDY5MDdj`)

### √ñrnek API Key Formatƒ±

```
YjE2MTYxMjEtOTBiNS00Y2IwLWEzZWUtOWUxOGYyZDY5MDdj
```

## Supabase Secrets'a OneSignal REST API Key Ekleme

### Y√∂ntem 1: Supabase Dashboard (√ñnerilen)

1. **Supabase Dashboard'a giri≈ü yapƒ±n**
   - [Supabase Dashboard](https://app.supabase.com/) adresine gidin
   - Projenizi se√ßin

2. **Edge Functions ‚Üí Settings ‚Üí Secrets b√∂l√ºm√ºne gidin**
   - Sol men√ºden **Edge Functions** se√ßeneƒüine tƒ±klayƒ±n
   - **Settings** sekmesine gidin
   - **Secrets** b√∂l√ºm√ºne scroll edin

3. **Yeni Secret ekleyin**
   - **"Add new secret"** butonuna tƒ±klayƒ±n
   - **Name**: `ONESIGNAL_REST_API_KEY`
   - **Value**: OneSignal Dashboard'dan kopyaladƒ±ƒüƒ±nƒ±z REST API Key'i yapƒ±≈ütƒ±rƒ±n
   - ‚ö†Ô∏è **√ñNEMLƒ∞**: API Key'in ba≈üƒ±nda/sonunda bo≈üluk olmamalƒ±!
   - **"Save"** butonuna tƒ±klayƒ±n

4. **Diƒüer gerekli secrets'larƒ± kontrol edin**
   - `ONESIGNAL_APP_ID`: OneSignal App ID (Settings ‚Üí Keys & IDs ‚Üí App ID)
   - `SUPABASE_URL`: Supabase proje URL'i (Settings ‚Üí API ‚Üí Project URL)
   - `SUPABASE_SERVICE_ROLE_KEY`: Supabase Service Role Key (Settings ‚Üí API ‚Üí service_role key)

### Y√∂ntem 2: Supabase CLI

```bash
# Supabase CLI ile secret ekleme
supabase secrets set ONESIGNAL_REST_API_KEY=your_api_key_here

# T√ºm secrets'larƒ± listeleme
supabase secrets list
```

## API Key Doƒürulama ve Test

### 1. Edge Function Log'larƒ±nƒ± Kontrol Edin

Supabase Dashboard ‚Üí Edge Functions ‚Üí Logs b√∂l√ºm√ºnden `send-notification` fonksiyonunun log'larƒ±nƒ± kontrol edin:

```
üîµ Edge Function environment variables: {
  ONESIGNAL_REST_API_KEY: "‚úÖ Set (113 karakter, YjE2M...MDdj)"
  ONESIGNAL_REST_API_KEY_VALID: "‚úÖ Valid"
}
```

Eƒüer `‚ùå Invalid` g√∂r√ºyorsanƒ±z, API Key formatƒ±nƒ± kontrol edin.

### 2. cURL ile OneSignal API Testi

OneSignal REST API Key'inizi test etmek i√ßin a≈üaƒüƒ±daki cURL komutunu kullanabilirsiniz:

```bash
# OneSignal REST API Key'inizi test edin
curl -X POST "https://onesignal.com/api/v1/notifications" \
  -H "Content-Type: application/json" \
  -H "Authorization: Basic YOUR_REST_API_KEY_HERE" \
  -d '{
    "app_id": "YOUR_ONESIGNAL_APP_ID",
    "include_player_ids": ["test_player_id"],
    "headings": {"en": "Test Notification"},
    "contents": {"en": "This is a test notification"}
  }'
```

**Beklenen Sonu√ßlar:**
- ‚úÖ **200 OK**: API Key ge√ßerli, bildirim g√∂nderildi
- ‚ùå **403 Forbidden**: API Key ge√ßersiz veya yanlƒ±≈ü format
- ‚ùå **400 Bad Request**: Request body formatƒ± hatalƒ±

### 3. Edge Function'dan Test Bildirimi G√∂nderme

Uygulama i√ßinden bir test bildirimi g√∂ndererek API Key'in √ßalƒ±≈üƒ±p √ßalƒ±≈ümadƒ±ƒüƒ±nƒ± kontrol edebilirsiniz:

1. Uygulamada bir grup olu≈üturun veya mevcut bir gruba katƒ±lƒ±n
2. Bir kullanƒ±cƒ±ya katƒ±lma isteƒüi g√∂nderin
3. Supabase Dashboard ‚Üí Edge Functions ‚Üí Logs b√∂l√ºm√ºnden log'larƒ± kontrol edin

**Ba≈üarƒ±lƒ± Log √ñrneƒüi:**
```
‚úÖ OneSignal bildirim g√∂nderildi: {
  id: "notification_id",
  recipients: 1
}
```

**Hata Log √ñrneƒüi:**
```
‚ùå OneSignal API hatasƒ±: {
  status: 403,
  statusText: "Forbidden",
  error: "Access denied. Please include an 'Authorization: ...' header with a valid API key"
}
```

## Yaygƒ±n Hatalar ve √á√∂z√ºmleri

### Hata 1: "403 Forbidden - Access denied"

**Nedenler:**
- API Key yanlƒ±≈ü veya ge√ßersiz
- API Key formatƒ± hatalƒ± (ba≈üƒ±nda/sonunda bo≈üluk var)
- API Key bu App ID i√ßin yetkisiz
- API Key s√ºresi dolmu≈ü veya iptal edilmi≈ü

**√á√∂z√ºmler:**
1. OneSignal Dashboard'dan yeni bir REST API Key olu≈üturun
2. Supabase Secrets'dan API Key'i silin ve yeniden ekleyin (ba≈üƒ±nda/sonunda bo≈üluk olmadan)
3. API Key'in doƒüru App ID ile e≈üle≈ütiƒüinden emin olun
4. Edge Function log'larƒ±nda API Key preview'ƒ±nƒ± kontrol edin

### Hata 2: "API Key √ßok kƒ±sa" veya "API Key formatƒ± hatalƒ±"

**Nedenler:**
- API Key yanlƒ±≈ü kopyalandƒ± (eksik karakterler)
- API Key'in ba≈üƒ±nda/sonunda g√∂r√ºnmez karakterler var

**√á√∂z√ºmler:**
1. OneSignal Dashboard'dan API Key'i tekrar kopyalayƒ±n
2. Supabase Secrets'da API Key'i yeniden yapƒ±≈ütƒ±rƒ±n
3. API Key'in tamamƒ±nƒ± kopyaladƒ±ƒüƒ±nƒ±zdan emin olun

### Hata 3: "ONESIGNAL_REST_API_KEY environment variable eksik"

**Nedenler:**
- Secret Supabase'e eklenmemi≈ü
- Secret adƒ± yanlƒ±≈ü yazƒ±lmƒ±≈ü (b√ºy√ºk/k√º√ß√ºk harf duyarlƒ±)

**√á√∂z√ºmler:**
1. Supabase Dashboard ‚Üí Edge Functions ‚Üí Settings ‚Üí Secrets b√∂l√ºm√ºnden kontrol edin
2. Secret adƒ±nƒ±n tam olarak `ONESIGNAL_REST_API_KEY` olduƒüundan emin olun
3. Secret'ƒ± silin ve yeniden ekleyin

## G√ºvenlik √ñnerileri

1. **API Key'i asla commit etmeyin**
   - `.env` dosyalarƒ±nƒ± `.gitignore`'a ekleyin
   - API Key'i kod i√ßinde hardcode etmeyin
   - Sadece Supabase Secrets'da saklayƒ±n

2. **API Key'i d√ºzenli olarak rotate edin**
   - Her 3-6 ayda bir yeni API Key olu≈üturun
   - Eski API Key'i iptal edin

3. **API Key eri≈üimini sƒ±nƒ±rlandƒ±rƒ±n**
   - OneSignal Dashboard'da IP allowlisting kullanabilirsiniz
   - Sadece gerekli olan Edge Function'lara eri≈üim verin

## ƒ∞lgili Dok√ºmantasyon

- [OneSignal REST API Overview](https://documentation.onesignal.com/reference)
- [OneSignal Keys & IDs](https://documentation.onesignal.com/docs/accounts-and-keys)
- [Supabase Edge Functions Secrets](https://supabase.com/docs/guides/functions/secrets)
- [OneSignal Troubleshooting](https://documentation.onesignal.com/docs/troubleshooting)

## Destek

Sorun ya≈üƒ±yorsanƒ±z:
1. Edge Function log'larƒ±nƒ± kontrol edin
2. OneSignal Dashboard'da API Key'in durumunu kontrol edin
3. Bu dok√ºmantasyondaki troubleshooting adƒ±mlarƒ±nƒ± takip edin
4. OneSignal ve Supabase destek ekipleriyle ileti≈üime ge√ßin
</file>

<file path="docs/onesignal-fix-checklist.md">
# OneSignal Sorun Giderme Checklist

## Sorun 1: Edge Function 403 Forbidden Hatasƒ±

### Hata
```
Access denied. Please include an 'Authorization: ...' header with a valid API key
```

### √á√∂z√ºm

1. **OneSignal Dashboard'dan REST API Key'i al:**
   - OneSignal Dashboard ‚Üí Settings ‚Üí Keys & IDs
   - **REST API Key**'i kopyala (uzun bir string, √∂rn: `YjA3...`)

2. **Supabase Dashboard'a git:**
   - Supabase Dashboard ‚Üí Project ‚Üí Edge Functions ‚Üí Settings ‚Üí Secrets

3. **Secret ekle/g√ºncelle:**
   - **Name:** `ONESIGNAL_REST_API_KEY`
   - **Value:** OneSignal REST API Key (kopyaladƒ±ƒüƒ±n deƒüer)
   - **Save**

4. **Edge Function'ƒ± yeniden deploy et:**
   ```bash
   supabase functions deploy send-notification
   ```

5. **Kontrol:**
   - Edge Function log'larƒ±nda `ONESIGNAL_REST_API_KEY: ‚úÖ Set` g√∂r√ºnmeli
   - `ONESIGNAL_REST_API_KEY_LENGTH` 0'dan b√ºy√ºk olmalƒ±

### Not
- REST API Key, OneSignal App ID'den farklƒ±dƒ±r
- REST API Key, OneSignal Dashboard ‚Üí Settings ‚Üí Keys & IDs'den alƒ±nƒ±r
- Secret'ƒ± ekledikten sonra Edge Function'ƒ± yeniden deploy etmek gerekebilir

## Sorun 2: OneSignal Dashboard'da User G√∂r√ºnm√ºyor

### Kontrol Listesi

1. **OneSignal SDK Initialize Edildi mi?**
   - Console'da `‚úÖ OneSignal SDK initialize edildi` g√∂r√ºnmeli
   - Eƒüer g√∂r√ºnm√ºyorsa, app'i yeniden ba≈ülat

2. **Permission Verildi mi?**
   - Console'da `‚úÖ OneSignal permission granted: true` g√∂r√ºnmeli
   - Eƒüer `false` ise, cihaz ayarlarƒ±ndan bildirim izni ver

3. **Player ID Olu≈ütu mu?**
   - Console'da `‚úÖ OneSignal Player ID hazƒ±r: <id>` g√∂r√ºnmeli
   - Eƒüer g√∂r√ºnm√ºyorsa, permission verildikten sonra 2-3 saniye bekle

4. **Login Yapƒ±ldƒ± mƒ±?**
   - Console'da `‚úÖ OneSignal login ba≈üarƒ±lƒ±, external ID ayarlandƒ±: <id>` g√∂r√ºnmeli
   - Eƒüer g√∂r√ºnm√ºyorsa, app'i yeniden ba≈ülat veya logout/login yap

5. **OneSignal Dashboard'da Kontrol:**
   - OneSignal Dashboard ‚Üí Audience ‚Üí All Users
   - External ID ile ara (Supabase auth ID)
   - Veya Player ID ile ara

### Debug Adƒ±mlarƒ±

1. **App'i tamamen kapat ve yeniden a√ß**
2. **Login yap**
3. **Console log'larƒ±nƒ± kontrol et:**
   ```
   üîµ OneSignal initialize ediliyor
   ‚úÖ OneSignal SDK initialize edildi
   ‚úÖ OneSignal permission granted: true
   ‚úÖ OneSignal Player ID hazƒ±r: <id>
   üîµ OneSignal login yapƒ±lƒ±yor, external ID: <id>
   ‚úÖ OneSignal login ba≈üarƒ±lƒ±
   ‚úÖ OneSignal alias eklendi
   ‚úÖ OneSignal tags eklendi
   ```

4. **Eƒüer Player ID g√∂r√ºnm√ºyorsa:**
   - Permission verildikten sonra 2-3 saniye bekle
   - Push subscription change listener √ßalƒ±≈üacak
   - Console'da `üîî OneSignal push subscription changed` g√∂r√ºnmeli

5. **Eƒüer login yapƒ±lmƒ±yorsa:**
   - `pendingExternalId` mekanizmasƒ± √ßalƒ±≈üƒ±yor olmalƒ±
   - Subscription olu≈üunca otomatik login yapƒ±lacak
   - Console'da `üîµ Bekleyen external ID var, otomatik login yapƒ±lƒ±yor` g√∂r√ºnmeli

### iOS √ñzel Notlar

- iOS'ta permission verildikten sonra subscription olu≈ümasƒ± biraz zaman alabilir
- Test cihazƒ±nda APNs sertifikasƒ± doƒüru yapƒ±landƒ±rƒ±lmƒ±≈ü olmalƒ±
- Development build'de sandbox APNs kullanƒ±lƒ±r, production build'de production APNs

### Android √ñzel Notlar

- Android'de FCM (Firebase Cloud Messaging) yapƒ±landƒ±lmƒ±≈ü olmalƒ±
- `google-services.json` dosyasƒ± doƒüru yapƒ±landƒ±rƒ±lmƒ±≈ü olmalƒ±
- OneSignal App ID ve FCM Server Key doƒüru yapƒ±landƒ±rƒ±lmƒ±≈ü olmalƒ±

## Test

1. **Edge Function Test:**
   - Supabase Dashboard ‚Üí Edge Functions ‚Üí `send-notification` ‚Üí Test
   - Body'ye test payload'ƒ± ekle
   - Invoke et
   - Log'larƒ± kontrol et

2. **OneSignal Dashboard Test:**
   - OneSignal Dashboard ‚Üí Messages ‚Üí New Push
   - Test kullanƒ±cƒ±sƒ±na bildirim g√∂nder
   - Bildirim geliyorsa, user olu≈ümu≈ü demektir
</file>

<file path="docs/onesignal-ios-fix-checklist.md">
# OneSignal iOS Bildirim Sorun Giderme Checklist

## Hƒ±zlƒ± Kontrol Listesi

### ‚úÖ 1. Player ID ile Test Bildirimi G√∂nder

**OneSignal Dashboard:**
1. Messages ‚Üí New Push
2. **Target Audience:** "Send to Specific Users"
3. **Player ID'yi girin:** `3cf0f9f5-fa07-4c20-af84-14b220633160` (log'lardan)
   - ‚ö†Ô∏è **√ñNEMLƒ∞:** External ID deƒüil, Player ID kullanƒ±n!
4. Mesaj g√∂nder

### ‚úÖ 2. OneSignal Dashboard'da Cihazƒ± Kontrol Et

1. Audience ‚Üí Devices
2. External ID ile arayƒ±n: `da9ed634-9b37-4812-b12d-ed9333c7310f`
3. Cihazƒ±nƒ±z listede g√∂r√ºn√ºyor mu?
4. Push Subscription aktif mi? (Status: Subscribed)

### ‚úÖ 3. iOS APNs Yapƒ±landƒ±rmasƒ±

**OneSignal Dashboard:**
1. Settings ‚Üí Platforms ‚Üí iOS
2. **APNs Authentication Key** veya **APNs Certificate** yapƒ±landƒ±rƒ±lmƒ±≈ü mƒ±?
3. Eƒüer yoksa:
   - Apple Developer Portal'dan APNs Key olu≈üturun
   - OneSignal'e y√ºkleyin

### ‚úÖ 4. Build Type Kontrol√º

**Development build'de APNs √ßalƒ±≈ümayabilir:**
- Production build'de test edin:
  ```bash
  eas build --platform ios --profile production
  ```

### ‚úÖ 5. Notification Permission

**iOS Settings:**
1. Settings ‚Üí Geliom ‚Üí Notifications
2. "Allow Notifications" a√ßƒ±k mƒ±?
3. "Lock Screen", "Notification Center", "Banners" a√ßƒ±k mƒ±?

### ‚úÖ 6. Uygulama Durumu

**iOS'ta bildirimler:**
- Uygulama arka plandayken gelir
- Uygulama kapalƒ±yken gelir
- Uygulama a√ßƒ±kken (foreground) gelmeyebilir (NotificationHandler log'larƒ±nƒ± kontrol edin)

### ‚úÖ 7. OneSignal API Response Kontrol√º

**OneSignal Dashboard:**
1. Messages ‚Üí Delivery Reports
2. G√∂nderdiƒüiniz bildirimin durumunu kontrol edin
3. Hata mesajƒ± var mƒ±?
4. "Delivered" sayƒ±sƒ± > 0 mƒ±?

## Test Adƒ±mlarƒ±

### Adƒ±m 1: Player ID'yi Doƒürula

Log'lardan Player ID'yi alƒ±n:
```
‚úÖ OneSignal Player ID: 3cf0f9f5-fa07-4c20-af84-14b220633160
```

### Adƒ±m 2: OneSignal Dashboard'dan Test

1. Messages ‚Üí New Push
2. "Send to Specific Users" ‚Üí Player ID'yi yapƒ±≈ütƒ±r
3. "Test" mesajƒ± g√∂nder
4. Delivery Reports'ta durumu kontrol et

### Adƒ±m 3: Uygulama Durumunu Kontrol Et

- Uygulamayƒ± arka plana alƒ±n (home button'a basƒ±n)
- Bildirim gelmeli
- Notification Center'ƒ± kontrol edin

### Adƒ±m 4: Console Log'larƒ±nƒ± Kontrol Et

Uygulama a√ßƒ±kken bildirim gelirse:
```
üîî OneSignal notification received in foreground: ...
```

Uygulama kapalƒ±yken bildirim gelirse:
- Notification Center'da g√∂r√ºnmeli
- Bildirime tƒ±klayƒ±nca uygulama a√ßƒ±lmalƒ±

## Yaygƒ±n Sorunlar

### Sorun 1: "Invalid Player ID"
- **√á√∂z√ºm:** Player ID'yi doƒüru kopyaladƒ±ƒüƒ±nƒ±zdan emin olun
- Log'lardan: `‚úÖ OneSignal Player ID: 3cf0f9f5-fa07-4c20-af84-14b220633160`

### Sorun 2: "No devices found"
- **√á√∂z√ºm:** 
  - Audience ‚Üí Devices'da cihazƒ± kontrol edin
  - External ID ile arayƒ±n: `da9ed634-9b37-4812-b12d-ed9333c7310f`
  - Push Subscription aktif mi kontrol edin

### Sorun 3: iOS'ta bildirim gelmiyor
- **√á√∂z√ºm:**
  1. APNs sertifikasƒ± yapƒ±landƒ±rƒ±lmƒ±≈ü mƒ± kontrol edin
  2. Production build'de test edin
  3. Settings ‚Üí Geliom ‚Üí Notifications kontrol edin
  4. Uygulamayƒ± arka plana alƒ±n

### Sorun 4: Bildirim g√∂nderiliyor ama gelmiyor
- **√á√∂z√ºm:**
  1. Delivery Reports'ta durumu kontrol edin
  2. Hata mesajƒ± var mƒ± kontrol edin
  3. Uygulama durumunu kontrol edin (arka planda mƒ±?)
  4. Internet baƒülantƒ±sƒ± var mƒ± kontrol edin

## Hƒ±zlƒ± Test

1. **Player ID'yi al:** `3cf0f9f5-fa07-4c20-af84-14b220633160`
2. **OneSignal Dashboard:** Messages ‚Üí New Push ‚Üí "Send to Specific Users" ‚Üí Player ID
3. **Mesaj g√∂nder:** "Test bildirimi"
4. **Uygulamayƒ± arka plana al**
5. **Bildirim gelmeli**

## Debug Komutlarƒ±

### Player ID'yi Console'da G√∂rmek

Uygulama a√ßƒ±kken console'da:
```
‚úÖ OneSignal Player ID: 3cf0f9f5-fa07-4c20-af84-14b220633160
```

### OneSignal Subscription Durumunu Kontrol Etmek

OneSignal Dashboard:
- Audience ‚Üí Devices
- External ID ile arayƒ±n: `da9ed634-9b37-4812-b12d-ed9333c7310f`
- Push Subscription durumunu kontrol edin
</file>

<file path="docs/onesignal-player-id-test.md">
# OneSignal Player ID Test Rehberi

## Durum

OneSignal Dashboard'da:
- **OneSignal ID:** `b1616121-90b5-4cb0-a3ee-9e18f2d6907c` (Dashboard'dan)
- **External ID:** G√∂r√ºnm√ºyor (bu normal, kod g√ºncellendi, bir sonraki login'de g√∂r√ºnecek)

Log'lardan:
- **Player ID:** `3cf0f9f5-fa07-4c20-af84-14b220633160` (Uygulama log'larƒ±ndan)

## √ñnemli Not

**Player ID'ler farklƒ± olabilir!** Bu normal √ß√ºnk√º:
- Her cihaz/abonelik i√ßin farklƒ± Player ID olu≈üur
- Uygulama yeniden y√ºklendiƒüinde yeni Player ID olu≈üabilir
- Her zaman **en g√ºncel Player ID'yi kullanƒ±n**

## Test Bildirimi G√∂nderme

### Y√∂ntem 1: OneSignal Dashboard'dan (Player ID ile)

1. **OneSignal Dashboard ‚Üí Messages ‚Üí New Push**
2. **Target Audience:** "Send to Specific Users"
3. **Player ID'yi girin:**
   - Dashboard'dan: `b1616121-90b5-4cb0-a3ee-9e18f2d6907c`
   - Veya log'lardan: `3cf0f9f5-fa07-4c20-af84-14b220633160`
4. **Mesaj g√∂nder**

### Y√∂ntem 2: En G√ºncel Player ID'yi Bulma

**Uygulama a√ßƒ±kken console'da:**
```
‚úÖ OneSignal Player ID: 3cf0f9f5-fa07-4c20-af84-14b220633160
```

**Supabase'den:**
```sql
SELECT id, display_name, onesignal_player_id 
FROM users 
WHERE id = 'da9ed634-9b37-4812-b12d-ed9333c7310f';
```

**OneSignal Dashboard:**
- Audience ‚Üí Devices
- Cihazƒ±nƒ±zƒ± bulun
- Player ID'yi kopyalayƒ±n

## External ID G√∂r√ºnm√ºyor - √á√∂z√ºm

Kod g√ºncellendi, artƒ±k:
1. `OneSignal.login()` async olarak √ßalƒ±≈üƒ±yor
2. `OneSignal.User.addAlias()` ile alias ekleniyor
3. Bir sonraki login'de external ID g√∂r√ºnecek

**Test i√ßin:**
1. Uygulamayƒ± kapatƒ±n
2. Tekrar a√ßƒ±n ve login olun
3. OneSignal Dashboard ‚Üí Audience ‚Üí Devices
4. External ID g√∂r√ºnmeli: `da9ed634-9b37-4812-b12d-ed9333c7310f`

## Hƒ±zlƒ± Test

1. **En g√ºncel Player ID'yi al:**
   - Console log'larƒ±ndan: `3cf0f9f5-fa07-4c20-af84-14b220633160`
   - Veya Supabase'den: `onesignal_player_id` kolonunu kontrol et

2. **OneSignal Dashboard:**
   - Messages ‚Üí New Push
   - "Send to Specific Users" ‚Üí Player ID'yi yapƒ±≈ütƒ±r
   - "Test" mesajƒ± g√∂nder

3. **Uygulamayƒ± arka plana al** (iOS'ta bildirimler arka plandayken gelir)

4. **Bildirim gelmeli**

## Sorun Devam Ediyorsa

1. **Player ID'yi doƒürula:**
   - Console log'larƒ±ndan en g√ºncel Player ID'yi al
   - Supabase'de `onesignal_player_id` kolonunu kontrol et
   - OneSignal Dashboard'da cihazƒ± bul ve Player ID'yi kontrol et

2. **OneSignal Dashboard ‚Üí Delivery Reports:**
   - Bildirimin durumunu kontrol et
   - Hata mesajƒ± var mƒ±?
   - "Delivered" sayƒ±sƒ± > 0 mƒ±?

3. **iOS APNs yapƒ±landƒ±rmasƒ±:**
   - OneSignal Dashboard ‚Üí Settings ‚Üí Platforms ‚Üí iOS
   - APNs Authentication Key veya Certificate yapƒ±landƒ±rƒ±lmƒ±≈ü mƒ±?

4. **Build type:**
   - Development build'de APNs √ßalƒ±≈ümayabilir
   - Production build'de test et
</file>

<file path="docs/onesignal-test-notification.md">
# OneSignal Test Bildirimi G√∂nderme Rehberi

## √ñnemli Notlar

### 1. Player ID vs External ID

**OneSignal Dashboard'dan test bildirimi g√∂nderirken:**
- **Player ID kullanƒ±n** (External ID deƒüil!)
- Player ID: `3cf0f9f5-fa07-4c20-af84-14b220633160` (log'lardan)
- External ID: `da9ed634-9b37-4812-b12d-ed9333c7310f` (Supabase auth ID - bu sadece kullanƒ±cƒ±yƒ± bulmak i√ßin)

### 2. Test Bildirimi G√∂nderme Adƒ±mlarƒ±

1. **OneSignal Dashboard'a gidin:**
   - https://dashboard.onesignal.com/
   - App'ƒ±nƒ±zƒ± se√ßin

2. **Messages ‚Üí New Push** tƒ±klayƒ±n

3. **Target Audience:**
   - "Send to Specific Users" se√ßin
   - **Player ID'yi girin** (External ID deƒüil!)
   - Player ID'yi bulmak i√ßin:
     - Log'lardan: `‚úÖ OneSignal Player ID: 3cf0f9f5-fa07-4c20-af84-14b220633160`
     - Veya Supabase `users` tablosundan `onesignal_player_id` kolonunu kontrol edin

4. **Message:**
   - Ba≈ülƒ±k ve i√ßerik girin
   - Test mesajƒ±: "Test bildirimi"

5. **Send** butonuna tƒ±klayƒ±n

### 3. iOS i√ßin √ñzel Kontroller

**iOS'ta bildirim gelmiyorsa:**

1. **APNs Sertifikasƒ±:**
   - OneSignal Dashboard ‚Üí Settings ‚Üí Platforms ‚Üí iOS
   - APNs Authentication Key veya APNs Certificate yapƒ±landƒ±rƒ±lmƒ±≈ü olmalƒ±
   - Production sertifikasƒ± kullanƒ±lƒ±yorsa, production build'de test edin

2. **Build Type:**
   - Development build'de APNs √ßalƒ±≈ümayabilir
   - Production build'de test edin:
     ```bash
     eas build --platform ios --profile production
     ```

3. **Entitlements:**
   - `app.json` i√ßinde `aps-environment: production` olmalƒ± ‚úÖ (zaten var)

4. **Notification Permission:**
   - Log'larda `‚úÖ OneSignal permission granted: true` g√∂r√ºn√ºyor ‚úÖ
   - Ama Settings ‚Üí Geliom ‚Üí Notifications kontrol edin

### 4. Debug Adƒ±mlarƒ±

1. **Player ID'yi kontrol edin:**
   ```typescript
   // Console'da √ßalƒ±≈ütƒ±rƒ±n
   import { getOneSignalPlayerId } from '@/services/onesignal';
   getOneSignalPlayerId().then(console.log);
   ```

2. **OneSignal Dashboard'da cihazƒ± kontrol edin:**
   - Audience ‚Üí Devices
   - Cihazƒ±nƒ±z listede g√∂r√ºn√ºyor mu?
   - Push Subscription aktif mi?

3. **OneSignal API Response'unu kontrol edin:**
   - Messages ‚Üí Delivery Reports
   - Bildirimin durumunu kontrol edin
   - Hata mesajƒ± var mƒ±?

4. **Edge Function log'larƒ±nƒ± kontrol edin:**
   - Supabase Dashboard ‚Üí Edge Functions ‚Üí Logs
   - `send-notification` fonksiyonunun log'larƒ±nƒ± kontrol edin
   - OneSignal API response'unu kontrol edin

### 5. Yaygƒ±n Sorunlar

#### Sorun 1: "Invalid Player ID"
- **√á√∂z√ºm:** Player ID'yi doƒüru kopyaladƒ±ƒüƒ±nƒ±zdan emin olun
- Log'lardan Player ID'yi alƒ±n: `‚úÖ OneSignal Player ID: ...`

#### Sorun 2: "No devices found"
- **√á√∂z√ºm:** 
  - Cihazƒ±n OneSignal'e kayƒ±tlƒ± olduƒüundan emin olun
  - Audience ‚Üí Devices'da cihazƒ± kontrol edin
  - Push Subscription aktif mi kontrol edin

#### Sorun 3: iOS'ta bildirim gelmiyor
- **√á√∂z√ºm:**
  - APNs sertifikasƒ± yapƒ±landƒ±rƒ±lmƒ±≈ü mƒ± kontrol edin
  - Production build'de test edin
  - Settings ‚Üí Geliom ‚Üí Notifications ‚Üí Allow Notifications

#### Sorun 4: Bildirim g√∂nderiliyor ama gelmiyor
- **√á√∂z√ºm:**
  - Internet baƒülantƒ±sƒ± var mƒ± kontrol edin
  - Uygulama arka planda mƒ±? (iOS'ta bildirimler arka planda gelir)
  - Notification Center'ƒ± kontrol edin

### 6. Test Senaryolarƒ±

#### Senaryo 1: OneSignal Dashboard'dan Test
1. Player ID'yi log'lardan al
2. OneSignal Dashboard ‚Üí Messages ‚Üí New Push
3. "Send to Specific Users" ‚Üí Player ID'yi gir
4. Mesaj g√∂nder
5. Bildirim gelmeli

#### Senaryo 2: Edge Function'dan Test
1. Supabase Dashboard ‚Üí Edge Functions ‚Üí `send-notification`
2. Test butonuna tƒ±kla
3. Body'ye ≈üunu ekle:
   ```json
   {
     "user_ids": ["3cf0f9f5-fa07-4c20-af84-14b220633160"],
     "group_id": "test-group-id",
     "group_name": "Test Grubu",
     "title": "Test",
     "message": "Test bildirimi",
     "type": "status_update"
   }
   ```
4. Invoke et
5. Log'larƒ± kontrol et
6. Bildirim gelmeli

### 7. Player ID'yi Bulma

**Y√∂ntem 1: Log'lardan**
- Console'da: `‚úÖ OneSignal Player ID: 3cf0f9f5-fa07-4c20-af84-14b220633160`

**Y√∂ntem 2: Supabase'den**
```sql
SELECT id, display_name, onesignal_player_id 
FROM users 
WHERE id = 'da9ed634-9b37-4812-b12d-ed9333c7310f';
```

**Y√∂ntem 3: OneSignal Dashboard**
- Audience ‚Üí Devices
- External ID ile arayƒ±n: `da9ed634-9b37-4812-b12d-ed9333c7310f`
- Player ID'yi g√∂r√ºn

### 8. Hƒ±zlƒ± Test

1. **Player ID'yi al:**
   - Log'lardan: `3cf0f9f5-fa07-4c20-af84-14b220633160`

2. **OneSignal Dashboard:**
   - Messages ‚Üí New Push
   - "Send to Specific Users" ‚Üí Player ID'yi yapƒ±≈ütƒ±r
   - "Test" mesajƒ± g√∂nder

3. **Beklenen sonu√ß:**
   - Bildirim gelmeli
   - Console'da: `üîî OneSignal notification received in foreground:` veya
   - Notification Center'da bildirim g√∂r√ºnmeli
</file>

<file path="docs/onesignal-troubleshooting.md">
# OneSignal Bildirim Sorun Giderme Rehberi

## Test Bildirimi Gelmiyorsa Kontrol Edilecekler

### 1. OneSignal SDK Initialization

**Kontrol:**
- Uygulama ba≈üladƒ±ƒüƒ±nda console'da ≈üu log'lar g√∂r√ºnmeli:
  - `üîµ OneSignal initialize ediliyor, App ID: ...`
  - `‚úÖ OneSignal permission granted: true`
  - `‚úÖ OneSignal Player ID: ...`

**Sorun:** Log'lar g√∂r√ºnm√ºyorsa
- `app/Provider.tsx` i√ßinde `initializeOneSignal()` √ßaƒürƒ±lƒ±yor mu kontrol et
- `services/onesignal.ts` dosyasƒ±nda hata var mƒ± kontrol et

### 2. Player ID Kaydediliyor mu?

**Kontrol:**
- Kullanƒ±cƒ± login olduktan sonra console'da ≈üu log g√∂r√ºnmeli:
  - `‚úÖ OneSignal Player ID kaydedildi: ...`
- Supabase `users` tablosunda `onesignal_player_id` kolonu dolu mu kontrol et

**Sorun:** Player ID kaydedilmiyorsa
- `contexts/AuthContext.tsx` i√ßinde `savePlayerId` fonksiyonu √ßalƒ±≈üƒ±yor mu kontrol et
- Retry mekanizmasƒ± √ßalƒ±≈üƒ±yor mu kontrol et (5 deneme, 1 saniye aralƒ±k)

### 3. OneSignal Dashboard'dan Test Bildirimi

**Kontrol:**
- OneSignal Dashboard ‚Üí Messages ‚Üí New Push
- **Target Audience:** 
  - "Send to Specific Users" se√ß
  - Player ID'yi manuel olarak gir (users tablosundan al)
- **Message:** Test mesajƒ±
- **Send**

**Sorun:** Bildirim gelmiyorsa
- Player ID doƒüru mu kontrol et
- OneSignal App ID doƒüru mu kontrol et (`app.json` i√ßinde)
- OneSignal REST API Key doƒüru mu kontrol et (Supabase Edge Function environment variable)

### 4. Edge Function'dan Bildirim G√∂nderme

**Kontrol:**
- Supabase Edge Function log'larƒ±nƒ± kontrol et:
  - `üîµ OneSignal API √ßaƒürƒ±sƒ± yapƒ±lƒ±yor: ...`
  - `‚úÖ OneSignal bildirim g√∂nderildi: ...`
- OneSignal API response'u kontrol et:
  - `recipients` sayƒ±sƒ± > 0 olmalƒ±
  - `errors` bo≈ü olmalƒ±

**Sorun:** Edge Function hatasƒ± varsa
- OneSignal REST API Key doƒüru mu kontrol et
- Player ID'ler doƒüru mu kontrol et
- OneSignal App ID doƒüru mu kontrol et

### 5. Notification Permission

**Kontrol:**
- iOS: Settings ‚Üí Geliom ‚Üí Notifications ‚Üí Allow Notifications
- Android: Settings ‚Üí Apps ‚Üí Geliom ‚Üí Notifications ‚Üí Allow

**Sorun:** Permission verilmemi≈üse
- Uygulama ilk a√ßƒ±ldƒ±ƒüƒ±nda permission isteƒüi √ßƒ±kmalƒ±
- Eƒüer √ßƒ±kmƒ±yorsa, `services/onesignal.ts` i√ßinde `requestPermission` √ßaƒürƒ±sƒ± kontrol et

### 6. Device Token / Push Subscription

**Kontrol:**
- OneSignal Dashboard ‚Üí Audience ‚Üí Devices
- Cihazƒ±nƒ±z listede g√∂r√ºn√ºyor mu?
- Push Subscription aktif mi?

**Sorun:** Cihaz listede yoksa
- OneSignal SDK d√ºzg√ºn initialize edilmi≈ü mi kontrol et
- Permission verilmi≈ü mi kontrol et
- Internet baƒülantƒ±sƒ± var mƒ± kontrol et

### 7. Debug Log'larƒ±

**Kontrol:**
- Console'da ≈üu log'lar g√∂r√ºnmeli:
  - `üîµ OneSignal initialize ediliyor...`
  - `‚úÖ OneSignal permission granted: true`
  - `‚úÖ OneSignal Player ID: ...`
  - `‚úÖ OneSignal login yapƒ±ldƒ±, external ID: ...`
  - `‚úÖ OneSignal Player ID kaydedildi: ...`

**Sorun:** Log'lar g√∂r√ºnm√ºyorsa
- Console'u a√ßƒ±k tut
- Uygulamayƒ± yeniden ba≈ülat
- Log'larƒ± kontrol et

## Yaygƒ±n Sorunlar ve √á√∂z√ºmleri

### Sorun 1: Player ID null geliyor

**√á√∂z√ºm:**
- OneSignal SDK'nƒ±n tam initialize olmasƒ±nƒ± bekle
- Retry mekanizmasƒ± zaten var (5 deneme, 1 saniye aralƒ±k)
- Eƒüer hala null geliyorsa, permission verilmi≈ü mi kontrol et

### Sorun 2: Bildirim g√∂nderiliyor ama gelmiyor

**√á√∂z√ºm:**
- OneSignal Dashboard ‚Üí Messages ‚Üí Delivery Reports kontrol et
- Hata mesajƒ± var mƒ± kontrol et
- Player ID doƒüru mu kontrol et
- Cihaz internet baƒülantƒ±sƒ± var mƒ± kontrol et

### Sorun 3: Edge Function hatasƒ±

**√á√∂z√ºm:**
- Supabase Edge Function log'larƒ±nƒ± kontrol et
- OneSignal REST API Key doƒüru mu kontrol et
- Environment variable'lar doƒüru mu kontrol et

### Sorun 4: iOS'ta bildirim gelmiyor

**√á√∂z√ºm:**
- iOS entitlements doƒüru mu kontrol et (`app.json`)
- APNs sertifikasƒ± OneSignal'de yapƒ±landƒ±rƒ±lmƒ±≈ü mƒ± kontrol et
- Production build'de test et (development build'de APNs √ßalƒ±≈ümayabilir)

### Sorun 5: Android'de bildirim gelmiyor

**√á√∂z√ºm:**
- Google Services dosyasƒ± (`google-services.json`) doƒüru mu kontrol et
- Firebase Cloud Messaging (FCM) yapƒ±landƒ±rƒ±lmƒ±≈ü mƒ± kontrol et
- OneSignal Dashboard'da Android platform aktif mi kontrol et

## Test Adƒ±mlarƒ±

1. **Uygulamayƒ± a√ß**
   - Console'da OneSignal initialize log'larƒ±nƒ± kontrol et
   - Permission isteƒüi √ßƒ±kmalƒ±

2. **Login ol**
   - Console'da Player ID kaydedildi log'unu kontrol et
   - Supabase users tablosunda `onesignal_player_id` kontrol et

3. **OneSignal Dashboard'dan test bildirimi g√∂nder**
   - Player ID'yi kullanarak manuel bildirim g√∂nder
   - Bildirim gelmeli

4. **Edge Function'dan test bildirimi g√∂nder**
   - `send-notification` Edge Function'ƒ±nƒ± √ßaƒüƒ±r
   - Log'larƒ± kontrol et
   - Bildirim gelmeli

## Debug Komutlarƒ±

### Player ID'yi Console'da G√∂rmek

```typescript
import { getOneSignalPlayerId } from '@/services/onesignal';

getOneSignalPlayerId().then((playerId) => {
  console.log('Player ID:', playerId);
});
```

### OneSignal Subscription Durumunu Kontrol Etmek

```typescript
import { OneSignal } from 'react-native-onesignal';

OneSignal.User.pushSubscription.getOptedInAsync().then((optedIn) => {
  console.log('Opted in:', optedIn);
});

OneSignal.User.pushSubscription.getIdAsync().then((id) => {
  console.log('Subscription ID:', id);
});
```
</file>

<file path="docs/prebuild-checklist.md">
# Prebuild √ñncesi Kontrol Listesi

## ‚úÖ Y√ºkl√º Olmasƒ± Gereken Paketler

### 1. OneSignal (Bildirim Sistemi)
- ‚úÖ `react-native-onesignal` - Y√ºkl√º (v5.2.14)
- ‚úÖ `onesignal-expo-plugin` - Y√ºkl√º (v2.0.3)
- ‚úÖ `app.json`'da plugin konfig√ºrasyonu mevcut

### 2. Native Mod√ºller
- ‚úÖ `@gorhom/bottom-sheet` - Y√ºkl√º (v5.2.6)
- ‚úÖ `react-native-adapty` - Y√ºkl√º (v3.11.2)
- ‚úÖ `react-native-reanimated` - Y√ºkl√º (v4.1.1)
- ‚úÖ `lottie-react-native` - Y√ºkl√º (v7.3.4)
- ‚úÖ `react-native-gesture-handler` - Y√ºkl√º (v2.28.0)
- ‚úÖ `react-native-screens` - Y√ºkl√º (v4.16.0)

### 3. Expo Paketleri
- ‚úÖ `expo` - Y√ºkl√º (v54.0.23)
- ‚úÖ `expo-router` - Y√ºkl√º (v6.0.14)
- ‚úÖ `expo-build-properties` - Y√ºkl√º (v1.0.9)
- ‚úÖ `expo-apple-authentication` - Y√ºkl√º (v8.0.7)

## üìã Prebuild √ñncesi Yapƒ±lacaklar

### 1. Paket Y√ºkleme Kontrol√º
```bash
# T√ºm paketlerin y√ºkl√º olduƒüundan emin ol
npm install

# Eksik paket var mƒ± kontrol et
npm list --depth=0
```

### 2. app.json Kontrol√º
- ‚úÖ `onesignal-expo-plugin` plugin'i mevcut
- ‚úÖ `oneSignalAppId` extra config'de mevcut
- ‚úÖ iOS entitlements yapƒ±landƒ±rƒ±lmƒ±≈ü (aps-environment: production)
- ‚úÖ Android google-services.json mevcut
- ‚úÖ iOS GoogleService-Info.plist mevcut

### 3. Native Dosya Kontrol√º
- ‚úÖ `google-services.json` - Android i√ßin mevcut
- ‚úÖ `GoogleService-Info.plist` - iOS i√ßin mevcut

### 4. Gelecek ƒ∞√ßin Y√ºklenen Paketler
- ‚úÖ `expo-notifications` - Local notifications i√ßin
- ‚úÖ `expo-sharing` - Dosya payla≈üƒ±mƒ± i√ßin

### 4. Prebuild Komutu
```bash
# Prebuild yap (iOS ve Android native klas√∂rlerini olu≈üturur)
npx expo prebuild

# Veya sadece iOS i√ßin
npx expo prebuild --platform ios

# Veya sadece Android i√ßin
npx expo prebuild --platform android
```

## ‚ö†Ô∏è Dikkat Edilmesi Gerekenler

1. **OneSignal Plugin**: `app.json`'da `onesignal-expo-plugin` zaten konfig√ºre edilmi≈ü. Prebuild sƒ±rasƒ±nda otomatik olarak native kod ekleyecek.

2. **iOS Entitlements**: `aps-environment: production` ayarlanmƒ±≈ü. Development i√ßin `development` olabilir.

3. **Android**: `google-services.json` dosyasƒ± mevcut ve doƒüru konumda olmalƒ±.

4. **iOS**: `GoogleService-Info.plist` dosyasƒ± mevcut ve doƒüru konumda olmalƒ±.

## üîç Prebuild Sonrasƒ± Kontrol

Prebuild sonrasƒ± ≈üunlarƒ± kontrol edin:

1. **iOS**:
   - `ios/` klas√∂r√º olu≈üturuldu mu?
   - `ios/Podfile` mevcut mu?
   - `pod install` √ßalƒ±≈ütƒ±rƒ±lmalƒ± (iOS i√ßin)

2. **Android**:
   - `android/` klas√∂r√º olu≈üturuldu mu?
   - `android/app/google-services.json` mevcut mu?

3. **OneSignal**:
   - iOS: `ios/Geliom/Info.plist` i√ßinde OneSignal ayarlarƒ± var mƒ±?
   - Android: `android/app/build.gradle` i√ßinde OneSignal plugin'i var mƒ±?

## üìù Notlar

- Prebuild yapƒ±ldƒ±ktan sonra `ios/` ve `android/` klas√∂rleri olu≈üur
- Bu klas√∂rler `.gitignore`'da olmamalƒ± (native kodlar)
- Prebuild sonrasƒ± `npx expo run:ios` veya `npx expo run:android` ile √ßalƒ±≈ütƒ±rabilirsiniz
</file>

<file path="docs/rate-limiting-implementation.md">
# Rate Limiting Implementasyonu - Tamamlandƒ± ‚úÖ

## üìã Yapƒ±lanlar

### 1. Veritabanƒ±
- ‚úÖ `notification_rate_limits` tablosu SQL migration dosyasƒ± olu≈üturuldu
- ‚úÖ `check_rate_limit` database function olu≈üturuldu
- ‚úÖ `cleanup_old_rate_limits` temizleme function'ƒ± olu≈üturuldu
- ‚úÖ Index'ler eklendi (performans i√ßin)

**Dosya:** `docs/database-rate-limiting-migration.sql`

### 2. Edge Function
- ‚úÖ `send-notification` Edge Function'a rate limiting eklendi
- ‚úÖ Supabase client entegrasyonu
- ‚úÖ Rate limit kontrol√º (her alƒ±cƒ± i√ßin)
- ‚úÖ HTTP 429 (Too Many Requests) response
- ‚úÖ Bekleme s√ºresi bilgisi d√∂nd√ºr√ºl√ºyor

**Dosya:** `supabase/functions/send-notification/index.ts`

### 3. API Layer
- ‚úÖ `api/notifications.ts` g√ºncellendi
- ‚úÖ `sender_id` ve `receiver_ids` parametreleri eklendi
- ‚úÖ Rate limit hatasƒ± handling eklendi
- ‚úÖ `api/groups.ts`'deki bildirim √ßaƒürƒ±larƒ± g√ºncellendi

**Dosyalar:**
- `api/notifications.ts`
- `api/groups.ts`

## üöÄ Kurulum Adƒ±mlarƒ±

### 1. Veritabanƒ± Migration'ƒ± √áalƒ±≈ütƒ±r
Supabase SQL Editor'de `docs/database-rate-limiting-migration.sql` dosyasƒ±nƒ± √ßalƒ±≈ütƒ±r:

```sql
-- Tablo olu≈ütur
-- Function'lar olu≈ütur
-- Index'ler olu≈ütur
```

### 2. Edge Function Environment Variables
Supabase Dashboard'da Edge Function environment variables ekle:

```
SUPABASE_URL=your-supabase-url
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
```

(Bu deƒüi≈ükenler genellikle otomatik olarak mevcuttur)

### 3. Edge Function Deploy
```bash
supabase functions deploy send-notification
```

## ‚è±Ô∏è Rate Limit Kurallarƒ±

| Bildirim Tipi | Limit | S√ºre |
|--------------|-------|------|
| `join_request` | 1 istek | 5 dakika |
| `join_request_status` | 1 bildirim | 1 dakika |
| `direct_invite` | 1 davet | 10 dakika |
| `status_update` | 1 bildirim | 1 dakika |
| `mood_update` | 1 bildirim | 1 dakika |
| `event_reminder` | 1 bildirim | 60 dakika |

## üîß Nasƒ±l √áalƒ±≈üƒ±r?

1. **Bildirim G√∂nderme ƒ∞steƒüi:**
   - Client `sendNotification` fonksiyonunu √ßaƒüƒ±rƒ±r
   - `sender_id` ve `receiver_ids` parametreleri g√∂nderilir

2. **Edge Function Kontrol√º:**
   - `check_rate_limit` database function'ƒ± √ßaƒürƒ±lƒ±r
   - Son g√∂nderim zamanƒ± kontrol edilir
   - Limit a≈üƒ±ldƒ±ysa HTTP 429 d√∂nd√ºr√ºl√ºr

3. **Rate Limit A≈üƒ±ldƒ±ƒüƒ±nda:**
   - HTTP 429 (Too Many Requests) response
   - `wait_until` ve `wait_seconds` bilgisi d√∂nd√ºr√ºl√ºr
   - Client'da hata mesajƒ± g√∂sterilir

4. **Rate Limit A≈üƒ±lmadƒ±ƒüƒ±nda:**
   - Bildirim g√∂nderilir
   - `notification_rate_limits` tablosu g√ºncellenir
   - Ba≈üarƒ±lƒ± response d√∂nd√ºr√ºl√ºr

## üìù Notlar

- Rate limiting sadece `sender_id` ve `receiver_ids` g√∂nderildiƒüinde aktif
- Sistem bildirimleri (event_reminder) i√ßin rate limiting daha uzun (60 dakika)
- Eski kayƒ±tlar 24 saat sonra otomatik temizlenir
- Rate limit kontrol√º non-blocking (hata olsa bile bildirim g√∂nderilmeye √ßalƒ±≈üƒ±lƒ±r)

## üß™ Test

1. Aynƒ± kullanƒ±cƒ±ya 2 kez hƒ±zlƒ±ca bildirim g√∂nder
2. ƒ∞kinci istekte HTTP 429 hatasƒ± alƒ±nmalƒ±
3. Bekleme s√ºresi sonrasƒ± tekrar denemeli

## üîÑ Sonraki Adƒ±mlar

- [ ] Realtime g√ºncellemeleri ekle
- [ ] Client-side'da rate limit hatasƒ± i√ßin UI iyile≈ütirmesi
- [ ] Rate limit a≈üƒ±mƒ± i√ßin analytics/logging
</file>

<file path="docs/rate-limiting-plan.md">
# Rate Limiting Planƒ± - Bildirim Spam √ñnleme

## üéØ Ama√ß
Kullanƒ±cƒ±larƒ±n s√ºrekli bildirim g√∂ndermesini √∂nlemek ve sistem kaynaklarƒ±nƒ± korumak.

## üìã Rate Limit Kurallarƒ±

### 1. Katƒ±lma ƒ∞steƒüi G√∂nderme
- **Limit:** Aynƒ± kullanƒ±cƒ± aynƒ± gruba **5 dakikada bir** istek g√∂nderebilir
- **Kontrol Yeri:** 
  - Client-side: `useCreateJoinRequest` hook'unda
  - Server-side: Database constraint (zaten var - UNIQUE constraint)
- **Hata Mesajƒ±:** "Bu gruba yeni bir istek g√∂ndermek i√ßin 5 dakika beklemeniz gerekiyor"

### 2. Bildirim G√∂nderme (OneSignal)
- **Limit:** Aynƒ± g√∂nderen aynƒ± alƒ±cƒ±ya **1 dakikada bir** bildirim g√∂nderebilir
- **Kontrol Yeri:** Edge Function (`send-notification`)
- **Hata Mesajƒ±:** "√áok sƒ±k bildirim g√∂nderiyorsunuz. L√ºtfen 1 dakika bekleyin"

### 3. Kullanƒ±cƒ± Arama ve Direkt Davet
- **Limit:** Aynƒ± g√∂nderen aynƒ± alƒ±cƒ±ya **10 dakikada bir** davet g√∂nderebilir
- **Kontrol Yeri:** 
  - Client-side: `useCreateJoinRequest` hook'unda (davet g√∂nderirken)
  - Server-side: Database'de rate limit kontrol√º
- **Hata Mesajƒ±:** "Bu kullanƒ±cƒ±ya yeni bir davet g√∂ndermek i√ßin 10 dakika beklemeniz gerekiyor"

## üóÑÔ∏è Veritabanƒ± Yapƒ±sƒ±

### `notification_rate_limits` Tablosu
```sql
CREATE TABLE public.notification_rate_limits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sender_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  receiver_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  group_id UUID REFERENCES groups(id) ON DELETE CASCADE,
  notification_type TEXT NOT NULL CHECK (notification_type IN (
    'join_request',
    'join_request_status',
    'direct_invite',
    'status_update',
    'mood_update',
    'event_reminder'
  )),
  last_sent_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(sender_id, receiver_id, group_id, notification_type)
);

-- Index'ler
CREATE INDEX idx_rate_limits_sender_receiver ON notification_rate_limits(sender_id, receiver_id);
CREATE INDEX idx_rate_limits_group ON notification_rate_limits(group_id);
CREATE INDEX idx_rate_limits_type ON notification_rate_limits(notification_type);
CREATE INDEX idx_rate_limits_last_sent ON notification_rate_limits(last_sent_at);
```

## üîß Implementasyon Stratejisi

### 1. Edge Function'da Rate Limiting
- `send-notification` Edge Function'ƒ±nda kontrol
- Database'den son g√∂nderim zamanƒ±nƒ± kontrol et
- Limit a≈üƒ±ldƒ±ysa hata d√∂nd√ºr
- Limit a≈üƒ±lmadƒ±ysa kayƒ±t g√ºncelle/olu≈ütur

### 2. Client-Side Kontrol (UX i√ßin)
- Hƒ±zlƒ± geri bildirim i√ßin
- Server-side kontrol√º ge√ßemez (g√ºvenlik i√ßin)

### 3. Database Function (Opsiyonel)
- Rate limit kontrol√º i√ßin helper function
- Otomatik temizleme (eski kayƒ±tlarƒ± sil)

## ‚è±Ô∏è Zaman Limitleri

| ƒ∞≈ülem | Limit | S√ºre |
|-------|-------|------|
| Katƒ±lma ƒ∞steƒüi | 1 istek | 5 dakika |
| Bildirim G√∂nderme | 1 bildirim | 1 dakika |
| Direkt Davet | 1 davet | 10 dakika |

## üö® Hata Y√∂netimi

### Rate Limit A≈üƒ±ldƒ±ƒüƒ±nda
1. **Edge Function:** HTTP 429 (Too Many Requests) d√∂nd√ºr
2. **Client:** Kullanƒ±cƒ±ya anla≈üƒ±lƒ±r mesaj g√∂ster
3. **Log:** Rate limit a≈üƒ±mƒ±nƒ± logla (analytics i√ßin)

### Kullanƒ±cƒ± Deneyimi
- Kalan s√ºreyi g√∂ster (√∂rn: "3 dakika 45 saniye sonra tekrar deneyebilirsiniz")
- Toast mesajƒ± ile bilgilendir
- Buton'u disable et (kalan s√ºre boyunca)

## üîÑ Temizleme Stratejisi

### Otomatik Temizleme
- 24 saatten eski kayƒ±tlarƒ± otomatik sil
- Cron job veya database function ile
- Performans i√ßin gerekli

## üìù Notlar

- Rate limiting sadece bildirim g√∂nderme i√ßin deƒüil, spam √∂nleme i√ßin de kullanƒ±lƒ±r
- Farklƒ± bildirim tipleri i√ßin farklƒ± limitler olabilir
- Premium kullanƒ±cƒ±lar i√ßin daha y√ºksek limitler d√º≈ü√ºn√ºlebilir (gelecekte)
</file>

<file path="docs/realtime-join-requests.md">
# Realtime Join Requests - Implementasyon

## ‚úÖ Tamamlanan ƒ∞≈üler

### 1. Realtime Hook'larƒ±
- ‚úÖ `useGroupJoinRequestsRealtime` - Grup i√ßin katƒ±lma isteklerini dinler
- ‚úÖ `useMyJoinRequestsRealtime` - Kullanƒ±cƒ±nƒ±n kendi isteklerini dinler

### 2. Entegrasyon
- ‚úÖ `join-requests.tsx` ekranƒ±na realtime hook eklendi
- ‚úÖ `DashboardView.tsx`'e realtime hook eklendi (badge sayƒ±sƒ± anlƒ±k g√ºncellenir)
- ‚úÖ Export'lar `api/index.ts`'e eklendi

## üîß Nasƒ±l √áalƒ±≈üƒ±r?

### Grup Kurucusu ƒ∞√ßin
1. `useGroupJoinRequestsRealtime(groupId)` hook'u √ßaƒürƒ±lƒ±r
2. Supabase Realtime `group_join_requests` tablosunu dinler
3. Yeni istek geldiƒüinde veya istek durumu deƒüi≈ütiƒüinde:
   - Query cache invalidate edilir
   - UI otomatik g√ºncellenir
   - Badge sayƒ±sƒ± anlƒ±k g√ºncellenir

### ƒ∞stek Sahibi ƒ∞√ßin
1. `useMyJoinRequestsRealtime(userId)` hook'u √ßaƒürƒ±lƒ±r
2. Supabase Realtime kullanƒ±cƒ±nƒ±n isteklerini dinler
3. ƒ∞stek onaylandƒ±ƒüƒ±nda/reddedildiƒüinde:
   - Query cache invalidate edilir
   - UI otomatik g√ºncellenir

## üìç Kullanƒ±m Yerleri

### 1. Katƒ±lma ƒ∞stekleri Ekranƒ± (`join-requests.tsx`)
```typescript
useGroupJoinRequestsRealtime(groupId);
```
- Grup kurucusu yeni istekleri anƒ±nda g√∂r√ºr
- ƒ∞stek durumu deƒüi≈üikliklerini anƒ±nda g√∂r√ºr

### 2. Dashboard View (`DashboardView.tsx`)
```typescript
useGroupJoinRequestsRealtime(group.id);
```
- Badge sayƒ±sƒ± anlƒ±k g√ºncellenir
- Yeni istek geldiƒüinde sayƒ± artar

## üéØ Faydalar

1. **Anlƒ±k G√ºncelleme:** Sayfa yenilemeye gerek yok
2. **Daha ƒ∞yi UX:** Kullanƒ±cƒ± deƒüi≈üiklikleri hemen g√∂r√ºr
3. **Performans:** Sadece deƒüi≈üen veriler g√ºncellenir
4. **Otomatik:** Manuel refresh'e gerek yok

## üìù Notlar

- Realtime subscription'lar otomatik olarak cleanup edilir (component unmount olduƒüunda)
- Query cache invalidate edildiƒüinde React Query otomatik refetch yapar
- Rate limiting ile birlikte √ßalƒ±≈üƒ±r (spam √∂nleme)
</file>

<file path="docs/realtime-tables-list.md">
# Realtime √ñzelliƒüi A√ßƒ±k Olmasƒ± Gereken Tablolar

Bu dok√ºmantasyon, Supabase'de Realtime √∂zelliƒüinin a√ßƒ±k olmasƒ± gereken tablolarƒ± listeler. Bu tablolar, uygulama i√ßinde anlƒ±k g√ºncellemeler i√ßin kullanƒ±lmaktadƒ±r.

## Supabase Dashboard'da Realtime A√ßma

1. **Supabase Dashboard** ‚Üí **Database** ‚Üí **Replication** b√∂l√ºm√ºne gidin
2. Her tablo i√ßin **Realtime** toggle'ƒ±nƒ± **A√áIK** yapƒ±n
3. Veya SQL ile:
   ```sql
   ALTER PUBLICATION supabase_realtime ADD TABLE table_name;
   ```

## Realtime A√ßƒ±k Olmasƒ± Gereken Tablolar

### 1. **users** ‚úÖ
- **Kullanƒ±m:** Kullanƒ±cƒ± profil g√ºncellemeleri
- **Hook:** `useUsersRealtime`
- **Dosya:** `api/users.ts`
- **A√ßƒ±klama:** Kullanƒ±cƒ± bilgileri (display_name, photo_url, mood_id, vb.) deƒüi≈ütiƒüinde anlƒ±k g√ºncelleme

### 2. **groups** ‚úÖ
- **Kullanƒ±m:** Grup bilgileri g√ºncellemeleri
- **Hook:** `useGroupsRealtime`
- **Dosya:** `api/groups.ts`
- **A√ßƒ±klama:** Grup bilgileri (name, owner_id, vb.) deƒüi≈ütiƒüinde anlƒ±k g√ºncelleme

### 3. **group_members** ‚úÖ
- **Kullanƒ±m:** Grup √ºyelik deƒüi≈üiklikleri
- **Hook:** `useGroupMembersRealtime`
- **Dosya:** `api/groups.ts`
- **A√ßƒ±klama:** Kullanƒ±cƒ± gruba katƒ±ldƒ±ƒüƒ±nda/ayrƒ±ldƒ±ƒüƒ±nda anlƒ±k g√ºncelleme

### 4. **group_join_requests** ‚úÖ
- **Kullanƒ±m:** Grup katƒ±lma istekleri
- **Hook:** `useGroupJoinRequestsRealtime`, `useMyJoinRequestsRealtime`
- **Dosya:** `api/groups.ts`
- **A√ßƒ±klama:** Katƒ±lma istekleri olu≈üturulduƒüunda/onaylandƒ±ƒüƒ±nda/reddedildiƒüinde anlƒ±k g√ºncelleme

### 5. **statuses** ‚úÖ
- **Kullanƒ±m:** Status tanƒ±mlarƒ± (default ve custom)
- **Hook:** `useStatusesRealtime`
- **Dosya:** `api/statuses.ts`
- **A√ßƒ±klama:** Status tanƒ±mlarƒ± deƒüi≈ütiƒüinde anlƒ±k g√ºncelleme (custom status olu≈üturma/g√ºncelleme)

### 6. **user_statuses** ‚úÖ
- **Kullanƒ±m:** Kullanƒ±cƒ± status'larƒ± (grup bazlƒ±)
- **Hook:** `useGroupStatusesRealtime`, `useUserStatusesRealtime`
- **Dosya:** `api/statuses.ts`
- **A√ßƒ±klama:** Kullanƒ±cƒ± status'u deƒüi≈ütiƒüinde anlƒ±k g√ºncelleme (en √∂nemli realtime √∂zelliƒüi)

### 7. **moods** ‚úÖ
- **Kullanƒ±m:** Mood tanƒ±mlarƒ± (default ve custom)
- **Hook:** `useMoodsRealtime`
- **Dosya:** `api/moods.ts`
- **A√ßƒ±klama:** Mood tanƒ±mlarƒ± deƒüi≈ütiƒüinde anlƒ±k g√ºncelleme (custom mood olu≈üturma/g√ºncelleme)

### 8. **user_group_moods** ‚úÖ
- **Kullanƒ±m:** Kullanƒ±cƒ± mood'larƒ± (grup bazlƒ±)
- **Hook:** `useGroupMoodsRealtime`
- **Dosya:** `api/moods.ts`
- **A√ßƒ±klama:** Kullanƒ±cƒ± mood'u deƒüi≈ütiƒüinde anlƒ±k g√ºncelleme (en √∂nemli realtime √∂zelliƒüi)

### 9. **nicknames** ‚úÖ
- **Kullanƒ±m:** Kullanƒ±cƒ± takma adlarƒ± (grup bazlƒ±)
- **Hook:** `useNicknamesRealtime`
- **Dosya:** `api/nicknames.ts`
- **A√ßƒ±klama:** Takma ad olu≈üturulduƒüunda/g√ºncellendiƒüinde/silindiƒüinde anlƒ±k g√ºncelleme

### 10. **scheduled_events** ‚úÖ
- **Kullanƒ±m:** Planlanmƒ±≈ü etkinlikler
- **Hook:** `useGroupEventsRealtime`, `useEventsRealtime`
- **Dosya:** `api/events.ts`
- **A√ßƒ±klama:** Etkinlik olu≈üturulduƒüunda/g√ºncellendiƒüinde/silindiƒüinde anlƒ±k g√ºncelleme

### 11. **subscriptions** ‚úÖ
- **Kullanƒ±m:** Kullanƒ±cƒ± abonelikleri
- **Hook:** `useSubscriptionRealtime`
- **Dosya:** `api/subscriptions.ts`
- **A√ßƒ±klama:** Abonelik durumu deƒüi≈ütiƒüinde anlƒ±k g√ºncelleme (premium √∂zellikler i√ßin)

### 12. **muted_notifications** ‚ö†Ô∏è
- **Kullanƒ±m:** Sessize alƒ±nmƒ±≈ü bildirimler
- **Hook:** ≈ûu an realtime hook yok (gelecekte eklenebilir)
- **Dosya:** `api/muted.ts`
- **A√ßƒ±klama:** ≈ûu an realtime kullanƒ±lmƒ±yor ama gelecekte eklenebilir

## √ñncelik Sƒ±rasƒ±

### Y√ºksek √ñncelik (Kritik)
1. **user_statuses** - Status deƒüi≈üiklikleri anlƒ±k yansƒ±malƒ±
2. **user_group_moods** - Mood deƒüi≈üiklikleri anlƒ±k yansƒ±malƒ±
3. **group_members** - √úyelik deƒüi≈üiklikleri anlƒ±k yansƒ±malƒ±
4. **group_join_requests** - Katƒ±lma istekleri anlƒ±k yansƒ±malƒ±

### Orta √ñncelik
5. **groups** - Grup bilgileri deƒüi≈üiklikleri
6. **users** - Kullanƒ±cƒ± profil g√ºncellemeleri
7. **nicknames** - Takma ad deƒüi≈üiklikleri

### D√º≈ü√ºk √ñncelik
8. **statuses** - Status tanƒ±mlarƒ± (nadiren deƒüi≈üir)
9. **moods** - Mood tanƒ±mlarƒ± (nadiren deƒüi≈üir)
10. **scheduled_events** - Etkinlik deƒüi≈üiklikleri
11. **subscriptions** - Abonelik durumu (nadiren deƒüi≈üir)

## SQL Komutlarƒ± (Toplu A√ßma)

T√ºm tablolarƒ± tek seferde a√ßmak i√ßin:

```sql
-- Realtime √∂zelliƒüini t√ºm tablolara ekle
ALTER PUBLICATION supabase_realtime ADD TABLE users;
ALTER PUBLICATION supabase_realtime ADD TABLE groups;
ALTER PUBLICATION supabase_realtime ADD TABLE group_members;
ALTER PUBLICATION supabase_realtime ADD TABLE group_join_requests;
ALTER PUBLICATION supabase_realtime ADD TABLE statuses;
ALTER PUBLICATION supabase_realtime ADD TABLE user_statuses;
ALTER PUBLICATION supabase_realtime ADD TABLE moods;
ALTER PUBLICATION supabase_realtime ADD TABLE user_group_moods;
ALTER PUBLICATION supabase_realtime ADD TABLE nicknames;
ALTER PUBLICATION supabase_realtime ADD TABLE scheduled_events;
ALTER PUBLICATION supabase_realtime ADD TABLE subscriptions;
ALTER PUBLICATION supabase_realtime ADD TABLE muted_notifications;
```

## Kontrol Etme

Realtime'ƒ±n a√ßƒ±k olup olmadƒ±ƒüƒ±nƒ± kontrol etmek i√ßin:

```sql
-- T√ºm realtime tablolarƒ±nƒ± listele
SELECT 
  schemaname,
  tablename
FROM pg_publication_tables
WHERE pubname = 'supabase_realtime'
ORDER BY tablename;
```

## Notlar

- **RLS (Row Level Security):** Realtime √∂zelliƒüi RLS ile uyumlu √ßalƒ±≈üƒ±r
- **Performans:** Realtime subscription'lar performansƒ± etkileyebilir, sadece gerekli tablolarda a√ßƒ±n
- **G√ºvenlik:** Realtime a√ßƒ±k olan tablolar, client-side'dan dinlenebilir (RLS ile korunmalƒ±)
- **Muted Notifications:** ≈ûu an realtime kullanƒ±lmƒ±yor ama gelecekte eklenebilir
</file>

<file path="docs/realtime-troubleshooting.md">
# Realtime Troubleshooting

## Sorun: Realtime Subscription Kuruluyor Ama Payload Gelmiyor

### Belirtiler
- ‚úÖ `üì° Realtime subscription status: SUBSCRIBED` g√∂r√ºn√ºyor
- ‚úÖ `‚úÖ Realtime subscription ba≈üarƒ±yla kuruldu` g√∂r√ºn√ºyor
- ‚ùå `üîÑ Realtime status update` log'u g√∂r√ºnm√ºyor
- ‚ùå Database'de deƒüi≈üiklik yapƒ±ldƒ±ƒüƒ±nda realtime payload gelmiyor

### Olasƒ± Nedenler

#### 1. Tablo Realtime Publication'da Deƒüil (EN YAYGIN)

Supabase'de bir tablonun realtime √ßalƒ±≈ümasƒ± i√ßin `supabase_realtime` publication'ƒ±na eklenmesi gerekir.

**Kontrol:**
```sql
-- Hangi tablolar realtime'da?
SELECT 
  schemaname,
  tablename
FROM pg_publication_tables
WHERE pubname = 'supabase_realtime'
ORDER BY tablename;
```

**√á√∂z√ºm:**
```sql
-- user_statuses tablosunu realtime'a ekle
ALTER PUBLICATION supabase_realtime ADD TABLE user_statuses;

-- user_group_moods tablosunu realtime'a ekle
ALTER PUBLICATION supabase_realtime ADD TABLE user_group_moods;
```

#### 2. Supabase Dashboard'da Realtime Kapalƒ±

**Kontrol:**
1. Supabase Dashboard ‚Üí Database ‚Üí Replication
2. `user_statuses` ve `user_group_moods` tablolarƒ±nda Realtime toggle'ƒ± **A√áIK** olmalƒ±

**√á√∂z√ºm:**
- Dashboard'dan toggle'ƒ± a√ßƒ±n
- Veya yukarƒ±daki SQL komutlarƒ±nƒ± √ßalƒ±≈ütƒ±rƒ±n

#### 3. Filter Problemi

Realtime filter'larƒ± bazen √ßalƒ±≈ümayabilir. Test i√ßin filter'ƒ± kaldƒ±rƒ±p t√ºm deƒüi≈üiklikleri dinleyin:

```typescript
// Test i√ßin filter olmadan
.on(
  'postgres_changes',
  {
    event: '*',
    schema: 'public',
    table: 'user_statuses',
    // filter: `group_id=eq.${groupId}`, // Ge√ßici olarak kaldƒ±r
  },
  (payload) => {
    console.log('üîÑ Realtime status update (ALL):', payload);
  }
)
```

#### 4. RLS (Row Level Security) Problemi

RLS a√ßƒ±ksa, kullanƒ±cƒ±larƒ±n realtime event'lerini g√∂rebilmesi i√ßin policy'ler gerekir.

**Kontrol:**
```sql
-- RLS a√ßƒ±k mƒ±?
SELECT tablename, rowsecurity 
FROM pg_tables 
WHERE schemaname = 'public' 
  AND tablename IN ('user_statuses', 'user_group_moods');
```

**Not:** ≈ûu an RLS kapalƒ±, bu sorun deƒüil.

### Test Adƒ±mlarƒ±

1. **Publication Kontrol√º:**
   ```sql
   SELECT tablename 
   FROM pg_publication_tables 
   WHERE pubname = 'supabase_realtime' 
     AND tablename IN ('user_statuses', 'user_group_moods');
   ```

2. **Manuel Test:**
   - Supabase Dashboard ‚Üí Table Editor ‚Üí `user_statuses`
   - Bir kaydƒ± g√ºncelleyin
   - Console'da `üîÑ Realtime status update` log'u g√∂r√ºnmeli

3. **Subscription Durumu:**
   - Console'da `üì° Realtime subscription status: SUBSCRIBED` g√∂r√ºnmeli
   - Eƒüer `CHANNEL_ERROR`, `TIMED_OUT` veya `CLOSED` g√∂r√ºyorsanƒ±z, baƒülantƒ± sorunu var

### √á√∂z√ºm √ñnceliƒüi

1. **√ñNCE:** `ALTER PUBLICATION supabase_realtime ADD TABLE user_statuses;` √ßalƒ±≈ütƒ±rƒ±n
2. **SONRA:** `ALTER PUBLICATION supabase_realtime ADD TABLE user_group_moods;` √ßalƒ±≈ütƒ±rƒ±n
3. **TEST:** Bir status deƒüi≈ütirin ve `üîÑ Realtime status update` log'unu kontrol edin

### Notlar

- Realtime subscription kurulduktan sonra (`SUBSCRIBED`), database'deki deƒüi≈üiklikler otomatik olarak payload olarak gelmelidir
- Eƒüer payload gelmiyorsa, tablo publication'da deƒüildir veya Supabase Realtime servisi √ßalƒ±≈ümƒ±yordur
- Filter'lar (`group_id=eq.${groupId}`) sadece payload'ƒ± filtreler, subscription'ƒ± engellemez
</file>

<file path="docs/status-notification-system.md">
# Status Bildirim Sistemi

## Genel Bakƒ±≈ü

Status deƒüi≈üikliƒüinde grup √ºyelerine bildirim g√∂nderilir. Bildirimler kuyruƒüa alƒ±nƒ±r ve minimum 1 dakika sonra g√∂nderilir.

## √ñzellikler

1. **Kuyruk Sistemi:** Status deƒüi≈üikliƒüinde bildirim hemen g√∂nderilmez, kuyruƒüa alƒ±nƒ±r
2. **Debounce Pattern:** Kullanƒ±cƒ± s√ºrekli status deƒüi≈ütirirse, sadece son status i√ßin bildirim g√∂nderilir
3. **Mesaj Sistemi:** Her status i√ßin √∂zelle≈ütirilebilir mesajlar (messages array)
4. **Placeholder Desteƒüi:** `{name}` ve `{group}` placeholder'larƒ± desteklenir
5. **Rate Limiting:** 1 dakika i√ßinde aynƒ± alƒ±cƒ±ya tekrar bildirim g√∂nderilmez

## Veritabanƒ± Yapƒ±sƒ±

### statuses Tablosu
- `messages TEXT[]` - Bildirim mesajlarƒ± (rastgele se√ßilecek)

### pending_notifications Tablosu
- `id UUID PK`
- `sender_id UUID FK` - Status deƒüi≈ütiren kullanƒ±cƒ±
- `receiver_ids UUID[]` - Grup √ºyeleri (kendisi hari√ß)
- `group_id UUID FK`
- `status_id INT FK`
- `scheduled_at TIMESTAMPTZ` - G√∂nderilecek zaman (created_at + 1 dakika)
- `created_at TIMESTAMPTZ`
- `updated_at TIMESTAMPTZ`
- Unique constraint: `(sender_id, group_id)` - Bir kullanƒ±cƒ±nƒ±n aynƒ± grup i√ßin sadece 1 pending bildirimi

## Akƒ±≈ü

1. **Status Deƒüi≈üikliƒüi:**
   - Kullanƒ±cƒ± status'unu deƒüi≈ütirir
   - `useSetUserStatus` hook'u √ßalƒ±≈üƒ±r
   - Status g√ºncellenir
   - Eƒüer `notifies: true` ise:
     - Grup √ºyeleri bulunur (kendisi hari√ß)
     - `pending_notifications` tablosuna kayƒ±t eklenir/g√ºncellenir
     - `scheduled_at = NOW() + 1 dakika`

2. **Bildirim G√∂nderme (Cron Job):**
   - Her dakika `process-pending-notifications` Edge Function √ßalƒ±≈üƒ±r
   - `scheduled_at <= NOW()` olan kayƒ±tlar bulunur
   - Her kayƒ±t i√ßin:
     - Status mesajlarƒ±ndan rastgele bir mesaj se√ßilir
     - Placeholder'lar deƒüi≈ütirilir (`{name}`, `{group}`)
     - `send-notification` Edge Function'ƒ± √ßaƒürƒ±lƒ±r
     - Rate limiting kontrol√º yapƒ±lƒ±r
     - Bildirim g√∂nderilir
     - Kayƒ±t silinir

## Mesaj Formatƒ±

### Placeholder'lar
- `{name}` ‚Üí Kullanƒ±cƒ± adƒ± (display_name veya custom_user_id)
- `{group}` ‚Üí Grup adƒ±

### √ñrnek Mesajlar
```json
[
  "{name} artƒ±k m√ºsait!",
  "{name} ≈üimdi m√ºsait durumda",
  "{name} {group} grubunda m√ºsait oldu"
]
```

### Default Mesaj
Eƒüer `messages` array'i bo≈üsa veya yoksa:
```
"{name} durumunu g√ºncelledi"
```

## Debounce Mantƒ±ƒüƒ±

- Kullanƒ±cƒ± status deƒüi≈ütirdiƒüinde:
  - Eƒüer mevcut bir `pending_notification` varsa ‚Üí UPDATE (scheduled_at g√ºncellenir)
  - Yoksa ‚Üí INSERT
- Unique constraint sayesinde bir kullanƒ±cƒ±nƒ±n aynƒ± grup i√ßin sadece 1 pending bildirimi olabilir
- S√ºrekli status deƒüi≈ütirirse, sadece son status i√ßin bildirim g√∂nderilir

## Rate Limiting

- `send-notification` Edge Function'ƒ±nda rate limiting kontrol√º yapƒ±lƒ±r
- Status update i√ßin 1 dakika limit
- Eƒüer rate limit a≈üƒ±ldƒ±ysa:
  - `scheduled_at` 1 dakika sonraya g√ºncellenir
  - Bir sonraki cron job'da tekrar denenecek

## Dosyalar

- `docs/database-migration-status-notifications.sql` - Database migration
- `api/statuses.ts` - Status g√ºncelleme ve pending notification olu≈üturma
- `supabase/functions/process-pending-notifications/index.ts` - Cron job Edge Function
- `supabase/functions/send-notification/index.ts` - Bildirim g√∂nderme (mevcut)
- `types/database.ts` - TypeScript type tanƒ±mlarƒ±
- `docs/cron-job-setup.md` - Cron job kurulum rehberi

## Test Senaryolarƒ±

1. ‚úÖ Status deƒüi≈ütir ‚Üí 1 dakika sonra bildirim g√∂nder
2. ‚úÖ Status deƒüi≈ütir ‚Üí 30 saniye sonra tekrar deƒüi≈ütir ‚Üí Sadece son status i√ßin bildirim g√∂nder
3. ‚úÖ S√ºrekli tƒ±klama ‚Üí Sadece son status i√ßin bildirim g√∂nder
4. ‚úÖ Mesaj placeholder'larƒ± doƒüru deƒüi≈ütirilsin
5. ‚úÖ `notifies: false` olan status'ler i√ßin bildirim g√∂nderilmesin
6. ‚úÖ Farklƒ± gruplarda status deƒüi≈ütir ‚Üí Her grup i√ßin ayrƒ± bildirim
</file>

<file path="services/notification-handler.ts">
import { OneSignal } from 'react-native-onesignal';

// Notification click handler'ƒ± setup et
// Bu fonksiyon Provider.tsx'te √ßaƒürƒ±lacak
export const setupNotificationHandler = () => {
  // Notification a√ßƒ±ldƒ±ƒüƒ±nda (kullanƒ±cƒ± bildirime tƒ±kladƒ±ƒüƒ±nda)
  OneSignal.Notifications.addEventListener('click', async (event) => {
    console.log('üîî OneSignal notification clicked:', event);
    
    // additionalData'dan grup bilgisini al
    const additionalData = event.notification.additionalData;
    const groupId = additionalData?.group_id as string | undefined;
    const groupName = additionalData?.group_name as string | undefined;

    if (!groupId) {
      console.warn('‚ö†Ô∏è Bildirimde group_id bulunamadƒ±');
      return;
    }

    console.log('‚úÖ Grup bilgisi alƒ±ndƒ±:', { groupId, groupName });

    // Navigation i√ßin router ve group context'e ihtiyacƒ±mƒ±z var
    // Bu handler'ƒ± bir component i√ßinde setup etmeliyiz
    // ≈ûimdilik sadece log, ger√ßek navigation'ƒ± NotificationHandler component'inde yapacaƒüƒ±z
  });
};
</file>

<file path="services/onesignal.ts">
import Constants from 'expo-constants';
import { OneSignal } from 'react-native-onesignal';

// OneSignal App ID - app.json'dan al
const ONESIGNAL_APP_ID = Constants.expoConfig?.extra?.oneSignalAppId;

// OneSignal initialization state
let isOneSignalInitialized = false;
let pendingExternalId: string | null = null; // Subscription olu≈üunca login yapmak i√ßin bekleyen external ID
let initializationPromise: Promise<void> | null = null;

// OneSignal'i initialize et (Promise d√∂nd√ºr√ºr)
export const initializeOneSignal = async (): Promise<void> => {
  // Eƒüer zaten initialize edildiyse, mevcut promise'i d√∂nd√ºr
  if (isOneSignalInitialized && initializationPromise) {
    return initializationPromise;
  }

  // Yeni initialization promise'i olu≈ütur
  initializationPromise = (async () => {
    try {
      console.log('üîµ OneSignal initialize ediliyor, App ID:', ONESIGNAL_APP_ID);
      
      // OneSignal'i initialize et
      OneSignal.initialize(ONESIGNAL_APP_ID);
      console.log('‚úÖ OneSignal SDK initialize edildi');
      isOneSignalInitialized = true;

      // Notification permission iste
      const granted = await OneSignal.Notifications.requestPermission(false);
      console.log('‚úÖ OneSignal permission granted:', granted);
      
      if (granted) {
        // Permission verildiyse Player ID'yi kontrol et
        // Biraz bekle, subscription olu≈ümasƒ± i√ßin (iOS'ta √∂zellikle gerekli)
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        const playerId = await getOneSignalPlayerId();
        if (playerId) {
          console.log('‚úÖ OneSignal Player ID hazƒ±r:', playerId);
          
          // Push subscription bilgilerini log'la
          try {
            const subscriptionId = await OneSignal.User.pushSubscription.getIdAsync();
            const pushToken = await OneSignal.User.pushSubscription.getTokenAsync();
            console.log('‚úÖ OneSignal Push Subscription ID:', subscriptionId);
            console.log('‚úÖ OneSignal Push Token:', pushToken ? 'Mevcut' : 'Yok');
            
            // Eƒüer bekleyen bir external ID varsa, hemen login yap
            if (pendingExternalId) {
              console.log('üîµ Permission verildi, bekleyen external ID ile login yapƒ±lƒ±yor:', pendingExternalId);
              const externalId = pendingExternalId;
              pendingExternalId = null; // Temizle
              try {
                await performOneSignalLogin(externalId, playerId, 3, 1000);
              } catch (error) {
                console.error('‚ùå Otomatik login hatasƒ± (permission sonrasƒ±):', error);
                // Hata olsa bile pendingExternalId'yi tekrar set et, subscription change listener tekrar denesin
                pendingExternalId = externalId;
              }
            }
          } catch (subError) {
            console.warn('‚ö†Ô∏è OneSignal subscription bilgileri alƒ±namadƒ±:', subError);
          }
        } else {
          console.log('‚è≥ OneSignal Player ID hen√ºz hazƒ±r deƒüil, subscription olu≈ümasƒ± bekleniyor...');
        }
      } else {
        console.warn('‚ö†Ô∏è OneSignal permission reddedildi - bildirimler √ßalƒ±≈ümayacak');
      }

    // Notification a√ßƒ±ldƒ±ƒüƒ±nda (kullanƒ±cƒ± bildirime tƒ±kladƒ±ƒüƒ±nda)
    OneSignal.Notifications.addEventListener('click', (event) => {
      console.log('üîî OneSignal notification clicked:', event);
      // Burada navigation yapƒ±labilir
      // event.notification.additionalData ile custom data'ya eri≈üilebilir
    });

    // Notification alƒ±ndƒ±ƒüƒ±nda (foreground'da)
    OneSignal.Notifications.addEventListener('foregroundWillDisplay', (event) => {
      console.log('üîî OneSignal notification received in foreground:', event);
      // Bildirimi g√∂ster (otomatik g√∂sterilir, burada sadece log)
    });

      // Push subscription deƒüi≈üikliklerini dinle
      OneSignal.User.pushSubscription.addEventListener('change', async (subscription) => {
        console.log('üîî OneSignal push subscription changed');
        const playerId = await getOneSignalPlayerId();
        if (playerId) {
          console.log('‚úÖ Yeni Player ID:', playerId);
          
          // Eƒüer bekleyen bir external ID varsa (kullanƒ±cƒ± login ama subscription hen√ºz olu≈ümamƒ±≈üsa), login yap
          if (pendingExternalId) {
            console.log('üîµ Bekleyen external ID var, otomatik login yapƒ±lƒ±yor:', pendingExternalId);
            const externalId = pendingExternalId;
            pendingExternalId = null; // Temizle
            try {
              await performOneSignalLogin(externalId, playerId, 3, 1000);
            } catch (error) {
              console.error('‚ùå Otomatik login hatasƒ± (subscription change):', error);
              // Hata olsa bile pendingExternalId'yi tekrar set et, bir sonraki subscription change'de tekrar denesin
              pendingExternalId = externalId;
            }
          }
        }
      });

      console.log('‚úÖ OneSignal initialize tamamlandƒ±');
    } catch (error) {
      console.error('‚ùå OneSignal initialize hatasƒ±:', error);
      isOneSignalInitialized = false;
      initializationPromise = null;
      throw error;
    }
  })();

  return initializationPromise;
};

// Kullanƒ±cƒ±nƒ±n OneSignal Player ID'sini al (Push Subscription ID)
export const getOneSignalPlayerId = async (): Promise<string | null> => {
  try {
    const subscriptionId = await OneSignal.User.pushSubscription.getIdAsync();
    return subscriptionId;
  } catch (error) {
    console.error('Error getting OneSignal player ID:', error);
    return null;
  }
};

// Kullanƒ±cƒ±ya tag ekle (segmentasyon i√ßin)
export const setOneSignalTags = (tags: Record<string, string>) => {
  try {
    OneSignal.User.addTags(tags);
  } catch (error) {
    console.error('Error setting OneSignal tags:', error);
  }
};

// Kullanƒ±cƒ± tag'lerini g√ºncelle
export const updateOneSignalTags = (tags: Record<string, string>) => {
  try {
    OneSignal.User.addTags(tags);
  } catch (error) {
    console.error('Error updating OneSignal tags:', error);
  }
};

// OneSignal login i≈ülemini ger√ßekle≈ütir (internal helper function)
// Retry mekanizmasƒ± ile login ba≈üarƒ± kontrol√º yapar
const performOneSignalLogin = async (
  externalId: string, 
  playerId: string | null,
  maxRetries: number = 3,
  retryDelay: number = 1000
): Promise<void> => {
  console.log('üîµ OneSignal login i≈ülemi ba≈ülatƒ±lƒ±yor:', {
    externalId,
    playerId: playerId || 'Yok',
    maxRetries,
  });

  let lastError: Error | null = null;
  
  // Retry mekanizmasƒ± ile login dene
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`üîµ OneSignal login denemesi ${attempt}/${maxRetries}...`);
      
      // OneSignal.login() async bir i≈ülem olabilir, await edelim
      await OneSignal.login(externalId);
      
      // Login sonrasƒ± external ID'yi doƒürula (OneSignal SDK v5'te getExternalId mevcut)
      // Biraz bekle, SDK'nƒ±n internal state'ini g√ºncellemesi i√ßin
      await new Promise(resolve => setTimeout(resolve, 500));
      
      try {
        const currentExternalId = await OneSignal.User.getExternalId();
        if (currentExternalId === externalId) {
          console.log('‚úÖ OneSignal login ba≈üarƒ±lƒ±, external ID doƒürulandƒ±:', externalId);
        } else {
          console.warn(`‚ö†Ô∏è OneSignal login yapƒ±ldƒ± ama external ID e≈üle≈ümedi. Beklenen: ${externalId}, Mevcut: ${currentExternalId || 'Yok'}`);
          // E≈üle≈ümese bile devam et, belki SDK hen√ºz g√ºncellemedi
        }
      } catch (verifyError) {
        console.warn('‚ö†Ô∏è External ID doƒürulama hatasƒ± (non-blocking):', verifyError);
        // Doƒürulama hatasƒ± olsa bile devam et
      }
      
      // External ID'yi alias olarak da ekleyelim (Dashboard'da g√∂r√ºnmesi i√ßin)
      // OneSignal SDK v5'te external ID'yi alias olarak eklemek daha g√ºvenilir
      try {
        await OneSignal.User.addAlias('supabase_auth_id', externalId);
        console.log('‚úÖ OneSignal alias eklendi (supabase_auth_id):', externalId);
      } catch (aliasError) {
        console.warn('‚ö†Ô∏è OneSignal alias ekleme hatasƒ± (non-blocking):', aliasError);
      }
      
      // User properties'leri de g√ºncelle (Dashboard'da g√∂r√ºnmesi i√ßin)
      try {
        await OneSignal.User.addTags({
          'supabase_auth_id': externalId,
          'player_id': playerId || 'unknown',
        });
        console.log('‚úÖ OneSignal tags eklendi');
      } catch (tagsError) {
        console.warn('‚ö†Ô∏è OneSignal tags ekleme hatasƒ± (non-blocking):', tagsError);
      }
      
      // Push subscription bilgilerini log'la
      try {
        const subscriptionId = await OneSignal.User.pushSubscription.getIdAsync();
        const pushToken = await OneSignal.User.pushSubscription.getTokenAsync();
        console.log('‚úÖ OneSignal Push Subscription ID:', subscriptionId);
        console.log('‚úÖ OneSignal Push Token:', pushToken ? 'Mevcut' : 'Yok');
      } catch (subError) {
        console.warn('‚ö†Ô∏è OneSignal subscription bilgileri alƒ±namadƒ±:', subError);
      }
      
      console.log('‚úÖ OneSignal login i≈ülemi tamamlandƒ±');
      return; // Ba≈üarƒ±lƒ±, √ßƒ±k
      
    } catch (error: any) {
      lastError = error;
      console.error(`‚ùå OneSignal login denemesi ${attempt}/${maxRetries} ba≈üarƒ±sƒ±z:`, error);
      
      // Son deneme deƒüilse, bekle ve tekrar dene
      if (attempt < maxRetries) {
        console.log(`‚è≥ ${retryDelay}ms sonra tekrar deneniyor...`);
        await new Promise(resolve => setTimeout(resolve, retryDelay));
      }
    }
  }
  
  // T√ºm denemeler ba≈üarƒ±sƒ±z oldu
  console.error('‚ùå OneSignal login t√ºm denemeler ba≈üarƒ±sƒ±z oldu:', lastError);
  throw new Error(`OneSignal login ba≈üarƒ±sƒ±z (${maxRetries} deneme): ${lastError?.message || 'Bilinmeyen hata'}`);
};

// Kullanƒ±cƒ±yƒ± OneSignal'e login et (external ID ile - Supabase auth ID)
// Player ID hazƒ±r olana kadar bekler (push subscription olu≈ümalƒ±)
export const loginOneSignal = async (externalId: string, maxRetries: number = 10, delay: number = 1000): Promise<void> => {
  try {
    console.log('üîµ OneSignal login yapƒ±lƒ±yor, external ID (Supabase auth ID):', externalId);
    
    // OneSignal'in initialize edilip edilmediƒüini kontrol et
    if (!isOneSignalInitialized) {
      console.log('‚è≥ OneSignal hen√ºz initialize edilmemi≈ü, bekleniyor...');
      await initializeOneSignal();
    }
    
    // Player ID hazƒ±r olana kadar bekle (push subscription olu≈ümalƒ±)
    let playerId: string | null = null;
    for (let i = 0; i < maxRetries; i++) {
      playerId = await getOneSignalPlayerId();
      if (playerId) {
        console.log('‚úÖ OneSignal Player ID hazƒ±r:', playerId);
        break;
      }
      console.log(`‚è≥ OneSignal Player ID hen√ºz hazƒ±r deƒüil, ${delay}ms sonra tekrar deneniyor... (${i + 1}/${maxRetries})`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
    
    if (!playerId) {
      console.warn('‚ö†Ô∏è OneSignal Player ID alƒ±namadƒ±, subscription olu≈ümasƒ± bekleniyor...');
      // Player ID yoksa, subscription olu≈üunca login yapmak i√ßin external ID'yi kaydet
      pendingExternalId = externalId;
      console.log('‚è≥ Subscription olu≈üunca otomatik login yapƒ±lacak');
      return; // Subscription change listener login yapacak
    }
    
    // Player ID hazƒ±rsa, login yap (retry mekanizmasƒ± performOneSignalLogin i√ßinde)
    await performOneSignalLogin(externalId, playerId, 3, 1000);
    
    // Login ba≈üarƒ±lƒ± olduktan sonra external ID'yi tekrar doƒürula
    try {
      const verifiedExternalId = await OneSignal.User.getExternalId();
      if (verifiedExternalId === externalId) {
        console.log('‚úÖ OneSignal login ve external ID doƒürulama ba≈üarƒ±lƒ±');
      } else {
        console.warn(`‚ö†Ô∏è OneSignal login yapƒ±ldƒ± ama external ID doƒürulama ba≈üarƒ±sƒ±z. Beklenen: ${externalId}, Mevcut: ${verifiedExternalId || 'Yok'}`);
      }
    } catch (verifyError) {
      console.warn('‚ö†Ô∏è OneSignal external ID doƒürulama hatasƒ± (non-blocking):', verifyError);
    }
  } catch (error) {
    console.error('‚ùå OneSignal login hatasƒ±:', error);
    throw error;
  }
};

// Kullanƒ±cƒ±yƒ± OneSignal'den logout et
export const logoutOneSignal = () => {
  try {
    OneSignal.logout();
  } catch (error) {
    console.error('Error logging out OneSignal:', error);
  }
};
</file>

<file path="supabase/functions/process-pending-notifications/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const ONESIGNAL_APP_ID = Deno.env.get('ONESIGNAL_APP_ID') || '';
const ONESIGNAL_REST_API_KEY = Deno.env.get('ONESIGNAL_REST_API_KEY') || '';
const SUPABASE_URL = Deno.env.get('SUPABASE_URL') || '';
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || '';

interface NotificationPayload {
  receiver_ids: string[]; // Alƒ±cƒ± kullanƒ±cƒ± ID'leri (Supabase user IDs - external_id olarak kullanƒ±lacak)
  sender_id: string; // Bildirim g√∂nderen kullanƒ±cƒ± ID (rate limiting i√ßin)
  group_id: string;
  group_name: string;
  title: string;
  message: string;
  type: 'status_update';
}

/**
 * Mesaj se√ßimi ve placeholder deƒüi≈ütirme
 * Custom status'ler i√ßin de messages array'i kullanƒ±lƒ±r
 */
function prepareNotificationMessage(
  messages: string[] | null | undefined,
  userName: string,
  groupName: string,
  statusText?: string
): string {
  let message: string;

  // Mesaj se√ßimi
  if (messages && messages.length > 0) {
    // Rastgele bir mesaj se√ß (custom status'ler i√ßin de ge√ßerli)
    const randomIndex = Math.floor(Math.random() * messages.length);
    message = messages[randomIndex];
  } else {
    // Default mesaj (messages array yoksa veya bo≈üsa)
    message = '{name} durumunu "{status}" olarak g√ºncelledi';
  }

  // Placeholder deƒüi≈ütirme
  message = message.replace(/{name}/g, userName);
  message = message.replace(/{group}/g, groupName);
  if (statusText) {
    message = message.replace(/{status}/g, statusText);
  }

  return message;
}

serve(async (req) => {
  try {
    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

    // scheduled_at <= NOW() olan pending notification'larƒ± bul
    const { data: pendingNotifications, error: fetchError } = await supabase
      .from('pending_notifications')
      .select(`
        *,
        status:statuses(*),
        sender:users!pending_notifications_sender_id_fkey(display_name, custom_user_id),
        group:groups(name)
      `)
      .lte('scheduled_at', new Date().toISOString());

    if (fetchError) {
      console.error('Pending notifications fetch hatasƒ±:', fetchError);
      return new Response(
        JSON.stringify({ error: 'Pending notifications alƒ±namadƒ±', details: fetchError.message }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }

    if (!pendingNotifications || pendingNotifications.length === 0) {
      return new Response(
        JSON.stringify({ success: true, processed: 0, message: 'ƒ∞≈ülenecek bildirim yok' }),
        { status: 200, headers: { 'Content-Type': 'application/json' } }
      );
    }

    let processedCount = 0;
    let errorCount = 0;

    // Her pending notification i√ßin bildirim g√∂nder
    for (const pending of pendingNotifications) {
      try {
        // Gerekli verileri kontrol et
        if (!pending.status || !pending.sender || !pending.group) {
          console.error('Eksik veri:', pending);
          errorCount++;
          continue;
        }

        // Status notifies kontrol√º
        if (!pending.status.notifies) {
          // Bildirim g√∂nderme, kaydƒ± sil
          console.log('Status notifies false, kayƒ±t siliniyor:', pending.id);
          await supabase
            .from('pending_notifications')
            .delete()
            .eq('id', pending.id);
          continue;
        }

        // receiver_ids'lerin ge√ßerli olup olmadƒ±ƒüƒ±nƒ± kontrol et (users tablosunda var mƒ±?)
        const { data: validUsers, error: validUsersError } = await supabase
          .from('users')
          .select('id')
          .in('id', pending.receiver_ids);

        if (validUsersError) {
          console.error('Ge√ßerli users kontrol√º hatasƒ±:', validUsersError);
          errorCount++;
          continue;
        }

        const validReceiverIds = validUsers?.map((u: { id: string }) => u.id) || [];

        if (validReceiverIds.length === 0) {
          // Ge√ßerli alƒ±cƒ± yok, kaydƒ± sil
          console.log('Ge√ßerli receiver_ids yok, kayƒ±t siliniyor:', pending.id);
          await supabase
            .from('pending_notifications')
            .delete()
            .eq('id', pending.id);
          continue;
        }

        // Mesaj hazƒ±rla
        // Custom status'ler i√ßin de messages array'i kullanƒ±lƒ±r (statuses tablosunda messages kolonu var)
        const userName = pending.sender.display_name || pending.sender.custom_user_id || 'Kullanƒ±cƒ±';
        const groupName = pending.group.name;
        const statusText = pending.status.text || 'Durum';
        
        // Status'un messages array'inden rastgele mesaj se√ß veya default mesaj kullan
        const message = prepareNotificationMessage(
          pending.status.messages, // Custom status'ler i√ßin de messages array'i kullanƒ±lƒ±r
          userName,
          groupName,
          statusText
        );

        console.log('üîµ Status bildirimi hazƒ±rlanƒ±yor:', {
          sender: userName,
          group: groupName,
          status: statusText,
          receiver_count: validReceiverIds.length,
          message,
        });

        // Rate limiting kontrol√º (send-notification Edge Function'ƒ±na g√∂nder)
        // Yeni API formatƒ±: receiver_ids kullanƒ±lƒ±yor (external_id olarak)
        const notificationPayload: NotificationPayload = {
          receiver_ids: validReceiverIds, // Supabase user IDs (external_id olarak kullanƒ±lacak)
          sender_id: pending.sender_id,
          group_id: pending.group_id,
          group_name: groupName,
          title: 'Durum G√ºncellendi',
          message,
          type: 'status_update',
        };

        // send-notification Edge Function'ƒ±nƒ± √ßaƒüƒ±r
        const { data: notificationResult, error: notificationError } = await supabase.functions.invoke(
          'send-notification',
          { body: notificationPayload }
        );

        if (notificationError) {
          console.error('Bildirim g√∂nderme hatasƒ±:', notificationError);
          errorCount++;
          // Rate limit hatasƒ± ise kaydƒ± silme, tekrar denesin
          if (notificationError.message?.includes('rate_limit_exceeded')) {
            // scheduled_at'i g√ºncelle (1 dakika sonra tekrar dene)
            const newScheduledAt = new Date(Date.now() + 60 * 1000).toISOString();
            await supabase
              .from('pending_notifications')
              .update({ scheduled_at: newScheduledAt })
              .eq('id', pending.id);
          } else {
            // Diƒüer hatalar i√ßin kaydƒ± sil
            await supabase
              .from('pending_notifications')
              .delete()
              .eq('id', pending.id);
          }
        } else {
          // Ba≈üarƒ±lƒ±, kaydƒ± sil
          await supabase
            .from('pending_notifications')
            .delete()
            .eq('id', pending.id);
          processedCount++;
        }
      } catch (error) {
        console.error('Pending notification i≈üleme hatasƒ±:', error);
        errorCount++;
        // Hata durumunda kaydƒ± sil
        await supabase
          .from('pending_notifications')
          .delete()
          .eq('id', pending.id);
      }
    }

    return new Response(
      JSON.stringify({
        success: true,
        processed: processedCount,
        errors: errorCount,
        total: pendingNotifications.length,
      }),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*',
        },
      }
    );
  } catch (error) {
    console.error('Process pending notifications hatasƒ±:', error);
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
});
</file>

<file path="supabase/functions/send-notification/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

// Environment variables - trim edilmi≈ü ve doƒürulanmƒ±≈ü
const ONESIGNAL_APP_ID = (Deno.env.get('ONESIGNAL_APP_ID') || '').trim();
let ONESIGNAL_REST_API_KEY = (Deno.env.get('ONESIGNAL_REST_API_KEY') || '').trim();
const SUPABASE_URL = (Deno.env.get('SUPABASE_URL') || '').trim();
const SUPABASE_SERVICE_ROLE_KEY = (Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || '').trim();

// API Key format kontrol√º ve doƒürulama
const validateOneSignalApiKey = (apiKey: string): { valid: boolean; error?: string } => {
  if (!apiKey) {
    return { valid: false, error: 'API Key bo≈ü' };
  }
  
  // OneSignal REST API Key genellikle 40-50 karakter arasƒ± olur
  // Ama bazƒ± durumlarda daha uzun olabilir, bu y√ºzden sadece minimum kontrol yapƒ±yoruz
  if (apiKey.length < 20) {
    return { valid: false, error: `API Key √ßok kƒ±sa (${apiKey.length} karakter, minimum 20 bekleniyor)` };
  }
  
  // API Key sadece alfanumerik karakterler ve bazƒ± √∂zel karakterler i√ßermeli
  // Ama tam format kontrol√º yapmak yerine, sadece bo≈üluk kontrol√º yapƒ±yoruz
  if (apiKey.includes('\n') || apiKey.includes('\r')) {
    return { valid: false, error: 'API Key i√ßinde yeni satƒ±r karakteri var' };
  }
  
  return { valid: true };
};

// API Key doƒürulama
const apiKeyValidation = validateOneSignalApiKey(ONESIGNAL_REST_API_KEY);

// Debug: Environment variables kontrol√º (API Key'in ilk/son 5 karakterini log'la, g√ºvenlik i√ßin)
const apiKeyPreview = ONESIGNAL_REST_API_KEY 
  ? `${ONESIGNAL_REST_API_KEY.substring(0, 5)}...${ONESIGNAL_REST_API_KEY.substring(ONESIGNAL_REST_API_KEY.length - 5)}`
  : 'Yok';

console.log('üîµ Edge Function environment variables:', {
  ONESIGNAL_APP_ID: ONESIGNAL_APP_ID ? '‚úÖ Set' : '‚ùå Missing',
  ONESIGNAL_REST_API_KEY: ONESIGNAL_REST_API_KEY ? `‚úÖ Set (${ONESIGNAL_REST_API_KEY.length} karakter, ${apiKeyPreview})` : '‚ùå Missing',
  ONESIGNAL_REST_API_KEY_VALID: apiKeyValidation.valid ? '‚úÖ Valid' : `‚ùå Invalid: ${apiKeyValidation.error}`,
  SUPABASE_URL: SUPABASE_URL ? '‚úÖ Set' : '‚ùå Missing',
  SUPABASE_SERVICE_ROLE_KEY: SUPABASE_SERVICE_ROLE_KEY ? '‚úÖ Set' : '‚ùå Missing',
});

// Rate limit s√ºreleri (dakika cinsinden)
const RATE_LIMITS: Record<string, number> = {
  'join_request': 5,        // 5 dakika
  'join_request_status': 1, // 1 dakika
  'direct_invite': 10,      // 10 dakika
  'status_update': 1,       // 1 dakika
  'mood_update': 1,         // 1 dakika
  'event_reminder': 60,     // 60 dakika (sistem bildirimi, daha uzun)
};

interface NotificationPayload {
  user_ids?: string[]; // OneSignal player_id'leri (DEPRECATED - include_aliases kullanƒ±lacak)
  receiver_ids: string[]; // Alƒ±cƒ± kullanƒ±cƒ± ID'leri (Supabase user IDs - external_id olarak kullanƒ±lacak)
  sender_id?: string; // Bildirim g√∂nderen kullanƒ±cƒ± ID (rate limiting i√ßin)
  receiver_id_to_player_id?: Record<string, string>; // receiver_id -> player_id mapping (rate limiting i√ßin, artƒ±k kullanƒ±lmƒ±yor)
  group_id: string;
  group_name: string;
  title: string;
  message: string;
  type: 'join_request' | 'join_request_status' | 'status_update' | 'mood_update' | 'event_reminder';
}

serve(async (req) => {
  try {
    // CORS headers
    if (req.method === 'OPTIONS') {
      return new Response(null, {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'POST, OPTIONS',
          'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
        },
      });
    }

    // Request body'yi parse et
    console.log('üîµ Request alƒ±ndƒ±, body parse ediliyor...');
    const payload: NotificationPayload = await req.json();
    console.log('üîµ Request payload:', {
      receiver_ids_count: payload.receiver_ids?.length || 0,
      receiver_ids: payload.receiver_ids?.slice(0, 3) || [], // ƒ∞lk 3'√º g√∂ster
      sender_id: payload.sender_id,
      group_id: payload.group_id,
      group_name: payload.group_name,
      type: payload.type,
    });

    // Validation - receiver_ids gerekli (Supabase user IDs - external_id olarak kullanƒ±lacak)
    if (!payload.receiver_ids || payload.receiver_ids.length === 0) {
      console.error('‚ùå Validation hatasƒ±: receiver_ids eksik veya bo≈ü');
      return new Response(
        JSON.stringify({ error: 'receiver_ids gerekli (Supabase user IDs)' }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    if (!payload.group_id || !payload.group_name) {
      console.error('‚ùå Validation hatasƒ±: group_id veya group_name eksik');
      return new Response(
        JSON.stringify({ error: 'group_id ve group_name gerekli' }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    console.log('‚úÖ Validation ba≈üarƒ±lƒ±');

    // Rate limiting kontrol√º (sadece sender_id varsa)
    // Status update ve mood update gibi √ßoklu alƒ±cƒ± bildirimlerinde
    // limit a≈üƒ±lan alƒ±cƒ±larƒ± filtrele, diƒüerlerine g√∂nder
    let allowedReceiverIds: string[] = [];

    if (payload.sender_id && payload.receiver_ids && payload.receiver_ids.length > 0) {
      console.log('üîµ Rate limiting kontrol√º ba≈ülatƒ±lƒ±yor...', {
        sender_id: payload.sender_id,
        receiver_ids_count: payload.receiver_ids.length,
        type: payload.type,
      });

      const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
      const limitMinutes = RATE_LIMITS[payload.type] || 1;

      // √ñnce receiver_ids'lerin ge√ßerli olup olmadƒ±ƒüƒ±nƒ± kontrol et (users tablosunda var mƒ±?)
      // Bu, foreign key constraint hatalarƒ±nƒ± √∂nler
      console.log('üîµ Ge√ßerli receiver_ids kontrol ediliyor...');
      const { data: validUsers, error: validUsersError } = await supabase
        .from('users')
        .select('id')
        .in('id', payload.receiver_ids);

      if (validUsersError) {
        console.error('‚ùå Ge√ßerli users kontrol√º hatasƒ±:', validUsersError);
        // Hata olsa bile devam et, rate limiting non-blocking
      }

      const validReceiverIds = validUsers?.map((u: { id: string }) => u.id) || [];
      console.log('üîµ Ge√ßerli receiver_ids:', {
        total: payload.receiver_ids.length,
        valid: validReceiverIds.length,
        invalid: payload.receiver_ids.length - validReceiverIds.length,
      });
      
      if (validReceiverIds.length === 0) {
        console.error('‚ùå T√ºm receiver_ids ge√ßersiz');
        return new Response(
          JSON.stringify({ 
            error: 'Ge√ßersiz alƒ±cƒ± ID\'leri',
            message: 'T√ºm alƒ±cƒ± ID\'leri ge√ßersiz veya kullanƒ±cƒ±lar silinmi≈ü.',
          }),
          { status: 400, headers: { 'Content-Type': 'application/json' } }
        );
      }

      // Sadece ge√ßerli receiver_ids'leri kullan
      const validReceiverIdsSet = new Set(validReceiverIds);
      const filteredReceiverIds = payload.receiver_ids.filter(id => validReceiverIdsSet.has(id));
      console.log('üîµ Filtrelenmi≈ü receiver_ids:', filteredReceiverIds.length);

      // √áoklu alƒ±cƒ± bildirimleri i√ßin (status_update, mood_update)
      const isMultiReceiver = payload.type === 'status_update' || payload.type === 'mood_update';
      console.log('üîµ Rate limiting tipi:', isMultiReceiver ? 'Multi-receiver (paralel)' : 'Single-receiver (sƒ±ralƒ±)');

      // √áoklu alƒ±cƒ± bildirimlerinde paralel kontrol, tek alƒ±cƒ± bildirimlerinde sƒ±ralƒ± kontrol
      if (isMultiReceiver) {
        // Paralel kontrol (performans i√ßin) - sadece ge√ßerli receiver_ids'ler i√ßin
        console.log('üîµ Paralel rate limit kontrol√º ba≈ülatƒ±lƒ±yor...', filteredReceiverIds.length, 'receiver i√ßin');
        const rateLimitChecks = await Promise.allSettled(
          filteredReceiverIds.map(receiverId =>
            supabase.rpc('check_rate_limit', {
              p_sender_id: payload.sender_id,
              p_receiver_id: receiverId,
              p_group_id: payload.group_id,
              p_notification_type: payload.type,
              p_limit_minutes: limitMinutes,
            })
          )
        );

        // Sonu√ßlarƒ± i≈üle
        console.log('üîµ Rate limit kontrol√º sonu√ßlarƒ± i≈üleniyor...');
        rateLimitChecks.forEach((result, index) => {
          const receiverId = filteredReceiverIds[index];

          if (result.status === 'fulfilled') {
            const { data: rateLimitCheck, error: rateLimitError } = result.value;

            if (rateLimitError) {
              console.error('Rate limit kontrol√º hatasƒ±:', rateLimitError);
              // Hata olsa bile devam et (rate limiting non-blocking)
              allowedReceiverIds.push(receiverId);
            } else if (rateLimitCheck && rateLimitCheck.length > 0) {
              const { can_send } = rateLimitCheck[0];
              if (can_send) {
                allowedReceiverIds.push(receiverId);
              } else {
                // Rate limit a≈üƒ±ldƒ± - bu alƒ±cƒ±yƒ± atla
                console.log(`‚ö†Ô∏è Rate limit a≈üƒ±ldƒ±: sender=${payload.sender_id}, receiver=${receiverId}, type=${payload.type}`);
              }
            } else {
              // Kayƒ±t yoksa izin ver
              allowedReceiverIds.push(receiverId);
            }
          } else {
            // Promise rejected - hata durumunda izin ver (non-blocking)
            console.error('‚ùå Rate limit kontrol√º promise hatasƒ±:', result.reason);
            allowedReceiverIds.push(receiverId);
          }
        });
        console.log('‚úÖ Paralel rate limit kontrol√º tamamlandƒ±:', {
          total: filteredReceiverIds.length,
          allowed: allowedReceiverIds.length,
          blocked: filteredReceiverIds.length - allowedReceiverIds.length,
        });
      } else {
        // Tek alƒ±cƒ± bildirimlerinde sƒ±ralƒ± kontrol (hata durumunda hemen durdur)
        // Sadece ge√ßerli receiver_ids'ler i√ßin kontrol yap
        console.log('üîµ Sƒ±ralƒ± rate limit kontrol√º ba≈ülatƒ±lƒ±yor...', filteredReceiverIds.length, 'receiver i√ßin');
        for (const receiverId of filteredReceiverIds) {
          console.log('üîµ Rate limit kontrol√º:', { sender: payload.sender_id, receiver: receiverId, type: payload.type });
          const { data: rateLimitCheck, error: rateLimitError } = await supabase.rpc(
            'check_rate_limit',
            {
              p_sender_id: payload.sender_id,
              p_receiver_id: receiverId,
              p_group_id: payload.group_id,
              p_notification_type: payload.type,
              p_limit_minutes: limitMinutes,
            }
          );

          if (rateLimitError) {
            // Foreign key constraint hatasƒ± gibi hatalar i√ßin log'la ama devam et
            if (rateLimitError.code === '23503') {
              console.warn(`Rate limit kontrol√º: receiver_id (${receiverId}) users tablosunda yok, atlanƒ±yor`);
              // Bu receiver_id'yi atla
              continue;
            }
            console.error('Rate limit kontrol√º hatasƒ±:', rateLimitError);
            // Diƒüer hatalar i√ßin devam et (rate limiting non-blocking)
            allowedReceiverIds.push(receiverId);
          } else if (rateLimitCheck && rateLimitCheck.length > 0 && rateLimitCheck[0]) {
          const { can_send, wait_until } = rateLimitCheck[0];
          
          if (can_send) {
            allowedReceiverIds.push(receiverId);
          } else {
              // Rate limit a≈üƒ±ldƒ± - tek alƒ±cƒ± bildirimlerinde t√ºm bildirimi durdur
              const waitSeconds = Math.ceil((new Date(wait_until).getTime() - Date.now()) / 1000);
              const waitMinutes = Math.ceil(waitSeconds / 60);
              
              return new Response(
                JSON.stringify({
                  error: 'rate_limit_exceeded',
                  message: `√áok sƒ±k bildirim g√∂nderiyorsunuz. L√ºtfen ${waitMinutes} dakika bekleyin.`,
                  wait_until: wait_until,
                  wait_seconds: waitSeconds,
                }),
                {
                  status: 429, // Too Many Requests
                  headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*',
                    'Retry-After': waitSeconds.toString(),
                  },
                }
              );
            }
          } else {
            // Kayƒ±t yoksa izin ver
            allowedReceiverIds.push(receiverId);
          }
        }
      }

      // √áoklu alƒ±cƒ± bildirimlerinde hi√ßbir alƒ±cƒ±ya g√∂nderilemiyorsa hata d√∂nd√ºr
      if (isMultiReceiver && allowedReceiverIds.length === 0) {
        console.error('‚ùå T√ºm alƒ±cƒ±lar i√ßin rate limit a≈üƒ±ldƒ±');
        return new Response(
          JSON.stringify({
            error: 'rate_limit_exceeded',
            message: 'T√ºm alƒ±cƒ±lar i√ßin rate limit a≈üƒ±ldƒ±. L√ºtfen bir s√ºre bekleyin.',
          }),
          {
            status: 429,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
          }
        );
      }

      // √áoklu alƒ±cƒ± bildirimlerinde limit a≈ümayan alƒ±cƒ±larƒ±n receiver_ids'lerini filtrele
      // Artƒ±k player_id yerine external_id (receiver_id) kullanacaƒüƒ±z
      if (isMultiReceiver) {
        // Sadece limit a≈ümayan alƒ±cƒ±lara bildirim g√∂nder
        payload.receiver_ids = allowedReceiverIds;
        console.log('‚úÖ Rate limiting sonrasƒ± receiver_ids:', allowedReceiverIds.length);
      } else {
        // Tek alƒ±cƒ± bildirimlerinde zaten allowedReceiverIds kontrol edildi
        payload.receiver_ids = allowedReceiverIds;
        console.log('‚úÖ Rate limiting sonrasƒ± receiver_ids:', allowedReceiverIds.length);
      }
    } else {
      console.log('‚ÑπÔ∏è Rate limiting atlandƒ± (sender_id yok)');
    }

    // OneSignal API'ye bildirim g√∂nder (Yeni API v2 formatƒ±)
    // include_aliases.external_id kullanƒ±yoruz (receiver_ids = Supabase user IDs = external_id)
    console.log('üîµ OneSignal payload hazƒ±rlanƒ±yor...', {
      receiver_ids_count: payload.receiver_ids.length,
      receiver_ids_preview: payload.receiver_ids.slice(0, 3),
    });
    
    const oneSignalPayload = {
      app_id: ONESIGNAL_APP_ID,
      include_aliases: {
        external_id: payload.receiver_ids, // Supabase user IDs = OneSignal external_id
      },
      target_channel: 'push', // Push notification channel
      headings: {
        en: `${payload.group_name} - ${payload.title}`,
        tr: `${payload.group_name} - ${payload.title}`,
      },
      contents: {
        en: `${payload.group_name} grubundan: ${payload.message}`,
        tr: `${payload.group_name} grubundan: ${payload.message}`,
      },
      data: {
        group_id: payload.group_id,
        group_name: payload.group_name,
        type: payload.type,
      },
      // iOS ve Android i√ßin √∂zel ayarlar
      ios_badgeType: 'Increase',
      ios_badgeCount: 1,
    };

    console.log('üîµ OneSignal API √ßaƒürƒ±sƒ± yapƒ±lƒ±yor (Yeni API v2):', {
      app_id: ONESIGNAL_APP_ID,
      endpoint: '/notifications?c=push',
      receiver_ids_count: payload.receiver_ids.length,
      receiver_ids_preview: payload.receiver_ids.slice(0, 3), // ƒ∞lk 3'√º g√∂ster
      title: `${payload.group_name} - ${payload.title}`,
      message: `${payload.group_name} grubundan: ${payload.message}`,
    });

    // OneSignal REST API Key kontrol√º ve doƒürulama
    if (!ONESIGNAL_REST_API_KEY) {
      console.error('‚ùå ONESIGNAL_REST_API_KEY environment variable eksik!');
      return new Response(
        JSON.stringify({ 
          error: 'OneSignal REST API Key yapƒ±landƒ±rƒ±lmamƒ±≈ü',
          message: 'ONESIGNAL_REST_API_KEY environment variable eksik. Supabase Dashboard ‚Üí Edge Functions ‚Üí Settings ‚Üí Secrets\'dan ekleyin.',
        }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // API Key format kontrol√º
    if (!apiKeyValidation.valid) {
      console.error('‚ùå ONESIGNAL_REST_API_KEY format hatasƒ±:', apiKeyValidation.error);
      return new Response(
        JSON.stringify({ 
          error: 'OneSignal REST API Key format hatasƒ±',
          message: `API Key ge√ßersiz: ${apiKeyValidation.error}. L√ºtfen Supabase Dashboard ‚Üí Edge Functions ‚Üí Settings ‚Üí Secrets\'dan doƒüru API Key'i ekleyin.`,
        }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // OneSignal REST API Authorization header formatƒ± (Yeni API v2)
    // Yeni API i√ßin: Authorization: Key {REST_API_KEY}
    // API Key'in ba≈üƒ±nda "Key " prefix'i olmamalƒ±, sadece API key olmalƒ±
    // OneSignal API Key formatƒ±: "os_v2_app_..." veya benzeri
    // Authorization header: "Key os_v2_app_..." formatƒ±nda olmalƒ±
    const authorizationHeader = `Key ${ONESIGNAL_REST_API_KEY.trim()}`;

    // Yeni API endpoint: /notifications?c=push
    const oneSignalApiUrl = 'https://api.onesignal.com/notifications?c=push';

    console.log('üîµ OneSignal API √ßaƒürƒ±sƒ± detaylarƒ± (Yeni API v2):', {
      url: oneSignalApiUrl,
      method: 'POST',
      app_id: ONESIGNAL_APP_ID,
      receiver_ids_count: payload.receiver_ids.length,
      authorization_header_preview: `${authorizationHeader.substring(0, 25)}...`,
      api_key_length: ONESIGNAL_REST_API_KEY.length,
      api_key_preview: apiKeyPreview,
      api_key_starts_with: ONESIGNAL_REST_API_KEY.substring(0, 10),
      api_key_ends_with: ONESIGNAL_REST_API_KEY.substring(ONESIGNAL_REST_API_KEY.length - 10),
    });

    const oneSignalResponse = await fetch(oneSignalApiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': authorizationHeader,
      },
      body: JSON.stringify(oneSignalPayload),
    });

    if (!oneSignalResponse.ok) {
      const errorText = await oneSignalResponse.text();
      let errorDetails: any = {
        status: oneSignalResponse.status,
        statusText: oneSignalResponse.statusText,
        error: errorText,
      };

      // 403 Forbidden hatasƒ± i√ßin √∂zel kontrol
      if (oneSignalResponse.status === 403) {
        errorDetails.diagnosis = {
          possible_causes: [
            'API Key yanlƒ±≈ü veya ge√ßersiz',
            'API Key formatƒ± hatalƒ± (ba≈üƒ±nda/sonunda bo≈üluk olabilir)',
            'API Key bu App ID i√ßin yetkisiz',
            'API Key s√ºresi dolmu≈ü veya iptal edilmi≈ü',
          ],
          api_key_length: ONESIGNAL_REST_API_KEY.length,
          api_key_preview: apiKeyPreview,
          authorization_header_preview: `${authorizationHeader.substring(0, 20)}...`,
          troubleshooting: 'Supabase Dashboard ‚Üí Edge Functions ‚Üí Settings ‚Üí Secrets\'dan ONESIGNAL_REST_API_KEY\'i kontrol edin. OneSignal Dashboard ‚Üí Settings ‚Üí Keys & IDs\'den REST API Key\'i doƒürulayƒ±n.',
        };
      }

      console.error('‚ùå OneSignal API hatasƒ±:', errorDetails);
      
      return new Response(
        JSON.stringify({ 
          error: 'OneSignal bildirim g√∂nderme hatasƒ±', 
          details: errorText,
          status: oneSignalResponse.status,
          diagnosis: errorDetails.diagnosis || undefined,
        }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const oneSignalResult = await oneSignalResponse.json();
    console.log('‚úÖ OneSignal bildirim g√∂nderildi:', {
      id: oneSignalResult.id,
      recipients: oneSignalResult.recipients,
      errors: oneSignalResult.errors,
    });

    return new Response(
      JSON.stringify({ success: true, result: oneSignalResult }),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*',
        },
      }
    );
  } catch (error) {
    console.error('‚ùå Bildirim g√∂nderme hatasƒ± (catch bloƒüu):', error);
    const errorMessage = error instanceof Error ? error.message : 'Bilinmeyen hata';
    const errorStack = error instanceof Error ? error.stack : undefined;
    console.error('‚ùå Hata detaylarƒ±:', {
      message: errorMessage,
      stack: errorStack,
      error_type: error?.constructor?.name || typeof error,
    });
    return new Response(
      JSON.stringify({ 
        error: errorMessage,
        details: errorStack,
      }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
});
</file>

<file path=".cursor/rules/definiions.mdc">
---
alwaysApply: true
description: supabase table definitions
---

**users** 
create table public.users (
  id uuid not null,
  custom_user_id text not null,
  email text null,
  display_name text null,
  photo_url text null,
  show_mood boolean not null default false,
  onesignal_player_id text null,
  updated_at timestamp with time zone null default now(),
  mood_id integer null,
  constraint users_pkey primary key (id),
  constraint users_custom_user_id_key unique (custom_user_id),
  constraint users_id_fkey foreign KEY (id) references auth.users (id) on delete CASCADE,
  constraint users_mood_id_fkey foreign KEY (mood_id) references moods (id)
) TABLESPACE pg_default;

**user_statuses**
create table public.user_statuses (
  user_id uuid not null,
  status_id integer not null,
  updated_at timestamp with time zone null default now(),
  constraint user_statuses_pkey primary key (user_id),
  constraint user_statuses_status_id_fkey foreign KEY (status_id) references statuses (id),
  constraint user_statuses_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE
) TABLESPACE pg_default;

**subcriptions**
create table public.subscriptions (
  user_id uuid not null,
  status text not null default 'free'::text,
  expires_at timestamp with time zone null,
  constraint subscriptions_pkey primary key (user_id),
  constraint subscriptions_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE
) TABLESPACE pg_default;

**statuses**
create table public.statuses (
  id serial not null,
  text text not null,
  notifies boolean not null default false,
  is_custom boolean not null default false,
  owner_id uuid null,
  constraint statuses_pkey primary key (id),
  constraint statuses_owner_id_fkey foreign KEY (owner_id) references users (id) on delete set null
) TABLESPACE pg_default;

**scheduled_events**
create table public.scheduled_events (
  id uuid not null default gen_random_uuid (),
  group_id uuid not null,
  creator_id uuid not null,
  title text not null,
  event_time timestamp with time zone not null,
  notification_time timestamp with time zone null,
  created_at timestamp with time zone null default now(),
  constraint scheduled_events_pkey primary key (id),
  constraint scheduled_events_creator_id_fkey foreign KEY (creator_id) references users (id) on delete CASCADE,
  constraint scheduled_events_group_id_fkey foreign KEY (group_id) references groups (id) on delete CASCADE
) TABLESPACE pg_default;

**nicknames**
create table public.nicknames (
  group_id uuid not null,
  setter_user_id uuid not null,
  target_user_id uuid not null,
  nickname text not null,
  constraint nicknames_pkey primary key (group_id, setter_user_id, target_user_id),
  constraint nicknames_group_id_fkey foreign KEY (group_id) references groups (id) on delete CASCADE,
  constraint nicknames_setter_user_id_fkey foreign KEY (setter_user_id) references users (id) on delete CASCADE,
  constraint nicknames_target_user_id_fkey foreign KEY (target_user_id) references users (id) on delete CASCADE
) TABLESPACE pg_default;

**muted_notifications**
create table public.muted_notifications (
  muter_user_id uuid not null,
  muted_user_id uuid not null,
  constraint muted_notifications_pkey primary key (muter_user_id, muted_user_id),
  constraint muted_notifications_muted_user_id_fkey foreign KEY (muted_user_id) references users (id) on delete CASCADE,
  constraint muted_notifications_muter_user_id_fkey foreign KEY (muter_user_id) references users (id) on delete CASCADE
) TABLESPACE pg_default;

**moods**
create table public.moods (
  id serial not null,
  text text not null,
  emoji text null,
  constraint moods_pkey primary key (id),
  constraint moods_text_key unique (text)
) TABLESPACE pg_default;

**groups**
create table public.groups (
  id uuid not null default gen_random_uuid (),
  owner_id uuid not null,
  type text not null,
  name text not null,
  invite_code text not null,
  member_limit integer not null default 5,
  created_at timestamp with time zone null default now(),
  constraint groups_pkey primary key (id),
  constraint groups_invite_code_key unique (invite_code),
  constraint groups_owner_id_fkey foreign KEY (owner_id) references users (id) on delete CASCADE
) TABLESPACE pg_default;

**group_members**
create table public.group_members (
  group_id uuid not null,
  user_id uuid not null,
  joined_at timestamp with time zone null default now(),
  constraint group_members_pkey primary key (group_id, user_id),
  constraint group_members_group_id_fkey foreign KEY (group_id) references groups (id) on delete CASCADE,
  constraint group_members_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE
) TABLESPACE pg_default;
</file>

<file path="api/events.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import type {
    CreateScheduledEvent,
    ScheduledEvent,
    ScheduledEventWithDetails,
    UpdateScheduledEvent
} from '../types/database';
import { supabase } from './supabase';

// Query Keys
export const eventKeys = {
  all: ['events'] as const,
  lists: () => [...eventKeys.all, 'list'] as const,
  list: (filters: string) => [...eventKeys.lists(), { filters }] as const,
  details: () => [...eventKeys.all, 'detail'] as const,
  detail: (id: string) => [...eventKeys.details(), id] as const,
  group: (groupId: string) => [...eventKeys.all, 'group', groupId] as const,
  user: (userId: string) => [...eventKeys.all, 'user', userId] as const,
  upcoming: (groupId: string) => [...eventKeys.group(groupId), 'upcoming'] as const,
};

// Queries
export const useGroupEvents = (groupId: string) => {
  return useQuery({
    queryKey: eventKeys.group(groupId),
    queryFn: async (): Promise<ScheduledEventWithDetails[]> => {
      const { data, error } = await supabase
        .from('scheduled_events')
        .select(`
          *,
          group:groups(*),
          creator:users(*)
        `)
        .eq('group_id', groupId)
        .order('event_time');
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!groupId,
  });
};

export const useUpcomingGroupEvents = (groupId: string) => {
  return useQuery({
    queryKey: eventKeys.upcoming(groupId),
    queryFn: async (): Promise<ScheduledEventWithDetails[]> => {
      const now = new Date().toISOString();
      
      const { data, error } = await supabase
        .from('scheduled_events')
        .select(`
          *,
          group:groups(*),
          creator:users(*)
        `)
        .eq('group_id', groupId)
        .gte('event_time', now)
        .order('event_time');
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!groupId,
  });
};

export const useUserCreatedEvents = (userId: string) => {
  return useQuery({
    queryKey: eventKeys.user(userId),
    queryFn: async (): Promise<ScheduledEventWithDetails[]> => {
      const { data, error } = await supabase
        .from('scheduled_events')
        .select(`
          *,
          group:groups(*),
          creator:users(*)
        `)
        .eq('creator_id', userId)
        .order('event_time');
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!userId,
  });
};

export const useEvent = (id: string) => {
  return useQuery({
    queryKey: eventKeys.detail(id),
    queryFn: async (): Promise<ScheduledEventWithDetails | null> => {
      const { data, error } = await supabase
        .from('scheduled_events')
        .select(`
          *,
          group:groups(*),
          creator:users(*)
        `)
        .eq('id', id)
        .single();
      
      if (error) throw error;
      return data;
    },
    enabled: !!id,
  });
};

// Kullanƒ±cƒ±nƒ±n dahil olduƒüu t√ºm gruplardaki eventleri getir
export const useUserGroupsEvents = (userId: string) => {
  return useQuery({
    queryKey: [...eventKeys.all, 'user-groups', userId],
    queryFn: async (): Promise<ScheduledEventWithDetails[]> => {
      // √ñnce kullanƒ±cƒ±nƒ±n dahil olduƒüu gruplarƒ± al
      const { data: userGroups, error: groupsError } = await supabase
        .from('group_members')
        .select('group_id')
        .eq('user_id', userId);
      
      if (groupsError) throw groupsError;
      
      if (!userGroups || userGroups.length === 0) return [];
      
      const groupIds = userGroups.map(g => g.group_id);
      
      // Bu gruplardaki eventleri al
      const { data, error } = await supabase
        .from('scheduled_events')
        .select(`
          *,
          group:groups(*),
          creator:users(*)
        `)
        .in('group_id', groupIds)
        .order('event_time');
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!userId,
  });
};

// Mutations
export const useCreateEvent = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (eventData: CreateScheduledEvent): Promise<ScheduledEvent> => {
      const { data, error } = await supabase
        .from('scheduled_events')
        .insert(eventData)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: eventKeys.all });
      queryClient.invalidateQueries({ queryKey: eventKeys.group(data.group_id) });
      queryClient.invalidateQueries({ queryKey: eventKeys.user(data.creator_id) });
    },
  });
};

export const useUpdateEvent = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ 
      id, 
      updates 
    }: { 
      id: string; 
      updates: UpdateScheduledEvent;
    }): Promise<ScheduledEvent> => {
      const { data, error } = await supabase
        .from('scheduled_events')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: eventKeys.all });
      queryClient.invalidateQueries({ queryKey: eventKeys.detail(data.id) });
      queryClient.invalidateQueries({ queryKey: eventKeys.group(data.group_id) });
      queryClient.invalidateQueries({ queryKey: eventKeys.user(data.creator_id) });
    },
  });
};

export const useDeleteEvent = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (id: string): Promise<void> => {
      const { error } = await supabase
        .from('scheduled_events')
        .delete()
        .eq('id', id);
      
      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: eventKeys.all });
    },
  });
};

// Realtime Subscription Hooks
export const useGroupEventsRealtime = (groupId: string) => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['group-events-realtime', groupId],
    queryFn: () => {
      const channel = supabase
        .channel(`group-events-changes-${groupId}`)
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'scheduled_events',
            filter: `group_id=eq.${groupId}`,
          },
          () => {
            queryClient.invalidateQueries({ queryKey: eventKeys.group(groupId) });
            queryClient.invalidateQueries({ queryKey: eventKeys.upcoming(groupId) });
          }
        )
        .subscribe();

      return channel;
    },
    enabled: !!groupId,
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};

export const useEventsRealtime = () => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['events-realtime'],
    queryFn: () => {
      const channel = supabase
        .channel('events-changes')
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'scheduled_events',
          },
          () => {
            queryClient.invalidateQueries({ queryKey: eventKeys.all });
          }
        )
        .subscribe();

      return channel;
    },
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};
</file>

<file path="api/groups.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import type {
  CreateGroup,
  CreateGroupJoinRequest,
  CreateGroupMember,
  Group,
  GroupJoinRequest,
  GroupJoinRequestWithDetails,
  GroupMember,
  GroupMemberWithUser,
  GroupWithOwner,
  UpdateGroup
} from '../types/database';
import { supabase } from './supabase';

// Query Keys
export const groupKeys = {
  all: ['groups'] as const,
  lists: () => [...groupKeys.all, 'list'] as const,
  list: (filters: string) => [...groupKeys.lists(), { filters }] as const,
  details: () => [...groupKeys.all, 'detail'] as const,
  detail: (id: string) => [...groupKeys.details(), id] as const,
  members: (groupId: string) => [...groupKeys.detail(groupId), 'members'] as const,
  userGroups: (userId: string) => [...groupKeys.all, 'user', userId] as const,
  joinRequests: (groupId: string) => [...groupKeys.detail(groupId), 'join-requests'] as const,
  myJoinRequests: (userId: string) => [...groupKeys.all, 'join-requests', 'user', userId] as const,
};

// Group Queries
export const useGroups = () => {
  return useQuery({
    queryKey: groupKeys.lists(),
    queryFn: async (): Promise<GroupWithOwner[]> => {
      const { data, error } = await supabase
        .from('groups')
        .select(`
          *,
          owner:users!groups_owner_id_fkey(*)
        `)
        .order('created_at', { ascending: false });
      
      if (error) throw error;
      return data || [];
    },
  });
};

export const useGroup = (id: string) => {
  return useQuery({
    queryKey: groupKeys.detail(id),
    queryFn: async (): Promise<GroupWithOwner | null> => {
      const { data, error } = await supabase
        .from('groups')
        .select(`
          *,
          owner:users!groups_owner_id_fkey(*)
        `)
        .eq('id', id)
        .single();
      
      if (error) throw error;
      return data;
    },
    enabled: !!id,
  });
};

export const useGroupByInviteCode = (inviteCode: string) => {
  return useQuery({
    queryKey: [...groupKeys.lists(), { inviteCode }],
    queryFn: async (): Promise<GroupWithOwner | null> => {
      const { data, error } = await supabase
        .from('groups')
        .select(`
          *,
          owner:users!groups_owner_id_fkey(*)
        `)
        .eq('invite_code', inviteCode)
        .single();
      
      if (error) throw error;
      return data;
    },
    enabled: !!inviteCode,
  });
};

export const useUserGroups = (userId: string) => {
  return useQuery({
    queryKey: groupKeys.userGroups(userId),
    queryFn: async (): Promise<GroupWithOwner[]> => {
      if (!userId) {
        return [];
      }
      
      // √ñnce kullanƒ±cƒ±nƒ±n gruplarƒ±nƒ± al
      const { data: memberData, error: memberError } = await supabase
        .from('group_members')
        .select(`
          group_id,
          group:groups(
            *,
            owner:users!groups_owner_id_fkey(*)
          )
        `)
        .eq('user_id', userId);
      
      if (memberError) {
        console.error('Error fetching user groups:', memberError);
        throw memberError;
      }
      
      if (!memberData || memberData.length === 0) {
        return [];
      }

      // Her grup i√ßin √ºye sayƒ±sƒ±nƒ± al
      const groupIds = memberData.map(item => item.group_id).filter(Boolean) as string[];
      
      if (groupIds.length === 0) {
        return [];
      }
      
      const { data: countData, error: countError } = await supabase
        .from('group_members')
        .select('group_id')
        .in('group_id', groupIds);
      
      if (countError) {
        console.error('Error fetching group member counts:', countError);
        throw countError;
      }

      // √úye sayƒ±larƒ±nƒ± hesapla
      const memberCounts: Record<string, number> = {};
      countData?.forEach(item => {
        if (item.group_id) {
          memberCounts[item.group_id] = (memberCounts[item.group_id] || 0) + 1;
        }
      });

      // Gruplarƒ± √ºye sayƒ±larƒ± ile birle≈ütir
      const groups = memberData
        .map(item => {
          const group = item.group;
          if (!group) return null;
          return {
            ...group,
            member_count: memberCounts[item.group_id] || 0,
          };
        })
        .filter(Boolean) as unknown as GroupWithOwner[];
      
      return groups;
    },
    enabled: !!userId,
    structuralSharing: false, // Her zaman yeni array referansƒ± - context g√ºncellemeleri i√ßin gerekli
  });
};

// Group Member Queries
export const useGroupMembers = (groupId: string) => {
  return useQuery({
    queryKey: groupKeys.members(groupId),
    queryFn: async (): Promise<GroupMemberWithUser[]> => {
      const { data, error } = await supabase
        .from('group_members')
        .select(`
          *,
          user:users(*)
        `)
        .eq('group_id', groupId)
        .order('joined_at');
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!groupId,
  });
};

export const useIsGroupMember = (groupId: string, userId: string) => {
  return useQuery({
    queryKey: [...groupKeys.members(groupId), 'check', userId],
    queryFn: async (): Promise<boolean> => {
      const { data, error } = await supabase
        .from('group_members')
        .select('user_id')
        .eq('group_id', groupId)
        .eq('user_id', userId)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      return !!data;
    },
    enabled: !!(groupId && userId),
  });
};

// Group Mutations
export const useCreateGroup = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (groupData: CreateGroup): Promise<Group> => {
      const { data, error } = await supabase
        .from('groups')
        .insert(groupData)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: groupKeys.all });
    },
  });
};

export const useUpdateGroup = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ id, updates }: { id: string; updates: UpdateGroup }): Promise<Group> => {
      const { data, error } = await supabase
        .from('groups')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: groupKeys.all });
      queryClient.invalidateQueries({ queryKey: groupKeys.detail(data.id) });
      queryClient.invalidateQueries({ queryKey: groupKeys.members(data.id) });
    },
  });
};

// Transfer group ownership (sadece mevcut owner yapabilir)
export const useTransferGroupOwnership = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ groupId, newOwnerId }: { groupId: string; newOwnerId: string }): Promise<Group> => {
      const { data, error } = await supabase
        .from('groups')
        .update({ owner_id: newOwnerId })
        .eq('id', groupId)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: groupKeys.all });
      queryClient.invalidateQueries({ queryKey: groupKeys.detail(data.id) });
      queryClient.invalidateQueries({ queryKey: groupKeys.members(data.id) });
    },
  });
};

export const useDeleteGroup = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (id: string): Promise<void> => {
      const { error } = await supabase
        .from('groups')
        .delete()
        .eq('id', id);
      
      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: groupKeys.all });
    },
  });
};

// Group Member Mutations
export const useJoinGroup = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (memberData: CreateGroupMember): Promise<GroupMember> => {
      const { data, error } = await supabase
        .from('group_members')
        .insert(memberData)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: groupKeys.all });
      queryClient.invalidateQueries({ queryKey: groupKeys.members(data.group_id) });
      queryClient.invalidateQueries({ queryKey: groupKeys.userGroups(data.user_id) });
    },
  });
};

export const useLeaveGroup = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ groupId, userId }: { groupId: string; userId: string }): Promise<void> => {
      // √ñnce grup √ºyeliƒüini sil
      const { error: memberError } = await supabase
        .from('group_members')
        .delete()
        .eq('group_id', groupId)
        .eq('user_id', userId);
      
      if (memberError) throw memberError;

      // Kullanƒ±cƒ± gruptan atƒ±ldƒ±ƒüƒ±nda, group_join_requests'teki approved/rejected kayƒ±tlarƒ±nƒ± sil
      // Bu sayede kullanƒ±cƒ± tekrar istek atabilir
      const { error: joinRequestError } = await supabase
        .from('group_join_requests')
        .delete()
        .eq('group_id', groupId)
        .eq('requester_id', userId)
        .in('status', ['approved', 'rejected']);

      if (joinRequestError) {
        console.error('Join request temizleme hatasƒ± (non-blocking):', joinRequestError);
        // Hata olsa bile devam et (non-blocking)
      } else {
        console.log('‚úÖ Join request kayƒ±tlarƒ± temizlendi:', { groupId, userId });
      }
    },
    onSuccess: (_, { groupId, userId }) => {
      queryClient.invalidateQueries({ queryKey: groupKeys.all });
      queryClient.invalidateQueries({ queryKey: groupKeys.members(groupId) });
      queryClient.invalidateQueries({ queryKey: groupKeys.userGroups(userId) });
      queryClient.invalidateQueries({ queryKey: groupKeys.joinRequests(groupId) });
      queryClient.invalidateQueries({ queryKey: groupKeys.myJoinRequests(userId) });
    },
  });
};

// Realtime Subscription Hooks
export const useGroupsRealtime = () => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['groups-realtime'],
    queryFn: () => {
      const channel = supabase
        .channel('groups-changes')
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'groups',
          },
          () => {
            queryClient.invalidateQueries({ queryKey: groupKeys.all });
          }
        )
        .subscribe();

      return channel;
    },
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};

export const useGroupMembersRealtime = (groupId: string) => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['group-members-realtime', groupId],
    queryFn: () => {
      const channel = supabase
        .channel(`group-members-changes-${groupId}`)
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'group_members',
            filter: `group_id=eq.${groupId}`,
          },
          () => {
            queryClient.invalidateQueries({ queryKey: groupKeys.members(groupId) });
          }
        )
        .subscribe();

      return channel;
    },
    enabled: !!groupId,
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};

// Group Join Request Queries
export const useGroupJoinRequests = (groupId: string, status?: 'pending' | 'approved' | 'rejected') => {
  return useQuery({
    queryKey: [...groupKeys.joinRequests(groupId), status],
    queryFn: async (): Promise<GroupJoinRequestWithDetails[]> => {
      let query = supabase
        .from('group_join_requests')
        .select(`
          *,
          group:groups(
            *,
            owner:users!groups_owner_id_fkey(*)
          ),
          requester:users!group_join_requests_requester_id_fkey(*)
        `)
        .eq('group_id', groupId)
        .order('created_at', { ascending: false });

      if (status) {
        query = query.eq('status', status);
      }

      const { data, error } = await query;

      if (error) throw error;
      return data || [];
    },
    enabled: !!groupId,
  });
};

export const useMyJoinRequests = (userId: string) => {
  return useQuery({
    queryKey: groupKeys.myJoinRequests(userId),
    queryFn: async (): Promise<GroupJoinRequestWithDetails[]> => {
      const { data, error } = await supabase
        .from('group_join_requests')
        .select(`
          *,
          group:groups(
            *,
            owner:users!groups_owner_id_fkey(*)
          ),
          requester:users!group_join_requests_requester_id_fkey(*)
        `)
        .eq('requester_id', userId)
        .order('created_at', { ascending: false });

      if (error) throw error;
      return data || [];
    },
    enabled: !!userId,
  });
};

// Realtime Subscription Hooks for Join Requests
export const useGroupJoinRequestsRealtime = (groupId: string) => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['group-join-requests-realtime', groupId],
    queryFn: () => {
      const channel = supabase
        .channel(`group-join-requests-changes-${groupId}`)
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'group_join_requests',
            filter: `group_id=eq.${groupId}`,
          },
          () => {
            // T√ºm status'ler i√ßin query'leri invalidate et
            queryClient.invalidateQueries({ queryKey: groupKeys.joinRequests(groupId) });
            queryClient.invalidateQueries({ queryKey: [...groupKeys.joinRequests(groupId), 'pending'] });
            queryClient.invalidateQueries({ queryKey: [...groupKeys.joinRequests(groupId), 'approved'] });
            queryClient.invalidateQueries({ queryKey: [...groupKeys.joinRequests(groupId), 'rejected'] });
          }
        )
        .subscribe();

      return channel;
    },
    enabled: !!groupId,
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};

export const useMyJoinRequestsRealtime = (userId: string) => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['my-join-requests-realtime', userId],
    queryFn: () => {
      const channel = supabase
        .channel(`my-join-requests-changes-${userId}`)
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'group_join_requests',
            filter: `requester_id=eq.${userId}`,
          },
          () => {
            queryClient.invalidateQueries({ queryKey: groupKeys.myJoinRequests(userId) });
          }
        )
        .subscribe();

      return channel;
    },
    enabled: !!userId,
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};

// Group Join Request Mutations
export const useCreateJoinRequest = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (request: CreateGroupJoinRequest): Promise<GroupJoinRequest> => {
      // √ñnce kullanƒ±cƒ±nƒ±n zaten √ºye olup olmadƒ±ƒüƒ±nƒ± kontrol et
      const { data: existingMember } = await supabase
        .from('group_members')
        .select('user_id')
        .eq('group_id', request.group_id)
        .eq('user_id', request.requester_id)
        .single();

      if (existingMember) {
        throw new Error('Zaten bu grubun √ºyesisiniz');
      }

      // Bekleyen bir istek var mƒ± kontrol et
      const { data: existingPendingRequest } = await supabase
        .from('group_join_requests')
        .select('id')
        .eq('group_id', request.group_id)
        .eq('requester_id', request.requester_id)
        .eq('status', 'pending')
        .single();

      if (existingPendingRequest) {
        throw new Error('Bu grup i√ßin zaten bekleyen bir isteƒüiniz var');
      }

      // Approved veya rejected olan ama group_members'ta olmayan kayƒ±tlarƒ± temizle
      // Bu, kullanƒ±cƒ± onaylandƒ±ktan sonra gruptan atƒ±ldƒ±ƒüƒ±nda tekrar istek atabilmesi i√ßin
      const { data: existingCompletedRequest } = await supabase
        .from('group_join_requests')
        .select('id, status')
        .eq('group_id', request.group_id)
        .eq('requester_id', request.requester_id)
        .in('status', ['approved', 'rejected'])
        .single();

      if (existingCompletedRequest) {
        // Kullanƒ±cƒ± ger√ßekten √ºye mi kontrol et
        const { data: isMember } = await supabase
          .from('group_members')
          .select('user_id')
          .eq('group_id', request.group_id)
          .eq('user_id', request.requester_id)
          .single();

        // Eƒüer √ºye deƒüilse, eski kaydƒ± sil (kullanƒ±cƒ± onaylandƒ±ktan sonra atƒ±lmƒ±≈ü olabilir)
        if (!isMember) {
          console.log('Eski join request kaydƒ± temizleniyor (kullanƒ±cƒ± √ºye deƒüil):', existingCompletedRequest.id);
          const { error: deleteError } = await supabase
            .from('group_join_requests')
            .delete()
            .eq('id', existingCompletedRequest.id);

          if (deleteError) {
            console.error('Eski join request kaydƒ± silme hatasƒ± (non-blocking):', deleteError);
            // Hata olsa bile devam et, yeni istek olu≈ütur
          }
        } else {
          // Kullanƒ±cƒ± zaten √ºye, hata fƒ±rlat (yukarƒ±daki kontrol zaten bunu yakalayacak ama ekstra g√ºvenlik)
          throw new Error('Zaten bu grubun √ºyesisiniz');
        }
      }

      const { data, error } = await supabase
        .from('group_join_requests')
        .insert({
          ...request,
          status: 'pending',
        })
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: async (data) => {
      // ƒ∞lgili query'leri invalidate et
      queryClient.invalidateQueries({ queryKey: groupKeys.joinRequests(data.group_id) });
      queryClient.invalidateQueries({ queryKey: groupKeys.myJoinRequests(data.requester_id) });

      // Bildirim g√∂nder (async, hata olsa bile devam et)
      try {
        // Grup bilgilerini ve sahibini al
        const { data: groupData } = await supabase
          .from('groups')
          .select(`
            name,
            owner_id,
            owner:users!groups_owner_id_fkey(
              id,
              onesignal_player_id
            )
          `)
          .eq('id', data.group_id)
          .single();

        // ƒ∞stek yapan kullanƒ±cƒ±nƒ±n bilgilerini al
        const { data: requesterData } = await supabase
          .from('users')
          .select('display_name, custom_user_id')
          .eq('id', data.requester_id)
          .single();

        if (groupData?.owner_id && groupData?.name && requesterData) {
          const { sendJoinRequestNotification } = await import('./notifications');
          await sendJoinRequestNotification(
            groupData.owner_id, // Supabase user ID (external_id olarak kullanƒ±lacak)
            data.group_id,
            groupData.name,
            requesterData.display_name || requesterData.custom_user_id,
            data.requester_id // Rate limiting i√ßin
          );
        }
      } catch (error) {
        console.error('Bildirim g√∂nderme hatasƒ± (non-blocking):', error);
      }
    },
  });
};

export const useApproveJoinRequest = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ requestId, groupId }: { requestId: string; groupId: string }): Promise<void> => {
      // ƒ∞steƒüi onayla
      const { data: request, error: requestError } = await supabase
        .from('group_join_requests')
        .select('requester_id')
        .eq('id', requestId)
        .single();

      if (requestError) throw requestError;
      if (!request) throw new Error('ƒ∞stek bulunamadƒ±');

      // Gruba √ºye ekle
      const { error: memberError } = await supabase
        .from('group_members')
        .insert({
          group_id: groupId,
          user_id: request.requester_id,
        });

      if (memberError) throw memberError;

      // ƒ∞stek durumunu g√ºncelle
      const { error: updateError } = await supabase
        .from('group_join_requests')
        .update({ status: 'approved', updated_at: new Date().toISOString() })
        .eq('id', requestId);

      if (updateError) throw updateError;
    },
    onSuccess: async (_, variables) => {
      // ƒ∞lgili query'leri invalidate et
      queryClient.invalidateQueries({ queryKey: groupKeys.joinRequests(variables.groupId) });
      queryClient.invalidateQueries({ queryKey: groupKeys.members(variables.groupId) });
      queryClient.invalidateQueries({ queryKey: groupKeys.userGroups(variables.groupId) });

      // Bildirim g√∂nder (async, hata olsa bile devam et)
      try {
        // ƒ∞stek bilgilerini al
        const { data: requestData } = await supabase
          .from('group_join_requests')
          .select('requester_id, group_id')
          .eq('id', variables.requestId)
          .single();

        if (!requestData) return;

        // Grup bilgilerini al (owner_id dahil)
        const { data: groupData } = await supabase
          .from('groups')
          .select('name, owner_id')
          .eq('id', requestData.group_id)
          .single();

        if (groupData?.name && groupData?.owner_id && requestData.requester_id) {
          const { sendJoinRequestStatusNotification } = await import('./notifications');
          await sendJoinRequestStatusNotification(
            requestData.requester_id, // Supabase user ID (external_id olarak kullanƒ±lacak)
            variables.groupId,
            groupData.name,
            'approved',
            groupData.owner_id // Rate limiting i√ßin
          );
        }
      } catch (error) {
        console.error('Bildirim g√∂nderme hatasƒ± (non-blocking):', error);
      }
    },
  });
};

export const useRejectJoinRequest = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ requestId, groupId }: { requestId: string; groupId: string }): Promise<void> => {
      const { error } = await supabase
        .from('group_join_requests')
        .update({ status: 'rejected', updated_at: new Date().toISOString() })
        .eq('id', requestId);

      if (error) throw error;
    },
    onSuccess: async (_, variables) => {
      // ƒ∞lgili query'leri invalidate et
      queryClient.invalidateQueries({ queryKey: groupKeys.joinRequests(variables.groupId) });
      queryClient.invalidateQueries({ queryKey: groupKeys.myJoinRequests(variables.groupId) });

      // Bildirim g√∂nder (async, hata olsa bile devam et)
      try {
        // ƒ∞stek bilgilerini al
        const { data: requestData } = await supabase
          .from('group_join_requests')
          .select('requester_id, group_id')
          .eq('id', variables.requestId)
          .single();

        if (!requestData) return;

        // Grup bilgilerini al (owner_id dahil)
        const { data: groupData } = await supabase
          .from('groups')
          .select('name, owner_id')
          .eq('id', requestData.group_id)
          .single();

        if (groupData?.name && groupData?.owner_id && requestData.requester_id) {
          const { sendJoinRequestStatusNotification } = await import('./notifications');
          await sendJoinRequestStatusNotification(
            requestData.requester_id, // Supabase user ID (external_id olarak kullanƒ±lacak)
            variables.groupId,
            groupData.name,
            'rejected',
            groupData.owner_id // Rate limiting i√ßin
          );
        }
      } catch (error) {
        console.error('Bildirim g√∂nderme hatasƒ± (non-blocking):', error);
      }
    },
  });
};
</file>

<file path="api/index.ts">
// Supabase client
export { supabase } from './supabase';

// Types
export * from '../types/database';

// Users API
export {
  // Mutations
  useCreateUser, useCurrentUser, useDeleteUser,
  // Query Keys
  userKeys, useUpdateUser, useUser, useUserByCustomId,
  // Queries
  useUsers,
  // Realtime
  useUsersRealtime
} from './users';

// Moods API
export {
  // Query Keys
  moodKeys,
  // Mutations
  useCreateMood, useDeleteMood, useMood,
  useMoodByText,
  // Queries
  useMoods,
  // Realtime
  useMoodsRealtime, useUpdateMood
} from './moods';

// Groups API
export {
  // Query Keys
  groupKeys, useApproveJoinRequest,
  // Mutations
  useCreateGroup,
  // Join Requests
  useCreateJoinRequest, useDeleteGroup, useGroup,
  useGroupByInviteCode, useGroupJoinRequests,
  // Join Requests Realtime
  useGroupJoinRequestsRealtime, useGroupMembers, useGroupMembersRealtime,
  // Queries
  useGroups,
  // Realtime
  useGroupsRealtime, useIsGroupMember, useJoinGroup,
  useLeaveGroup, useMyJoinRequests, useMyJoinRequestsRealtime, useRejectJoinRequest, useTransferGroupOwnership, useUpdateGroup, useUserGroups
} from './groups';

// Nicknames API
export {
  // Query Keys
  nicknameKeys,
  // Mutations
  useCreateNickname, useDeleteNickname,
  // Queries
  useGroupNicknames, useNickname,
  // Realtime
  useNicknamesRealtime, useUpdateNickname, useUpsertNickname, useUserNicknames,
  useUserSetNicknames
} from './nicknames';

// Statuses API
export {
  // Query Keys
  statusKeys,
  // Mutations
  useCreateStatus, useCustomStatuses, useDefaultStatuses, useDeleteStatus, useRemoveUserStatus, userStatusKeys, useSetUserStatus, useStatus,
  // Queries
  useStatuses,
  // Realtime
  useStatusesRealtime, useUpdateStatus, useUserStatus, useUserStatusesRealtime, useUsersWithStatuses
} from './statuses';

// Notifications API (Bildirim g√∂nderme fonksiyonlarƒ±)
export {
  sendEventReminderNotification, sendJoinRequestNotification,
  sendJoinRequestStatusNotification, sendMoodUpdateNotification, sendNotification, sendStatusUpdateNotification
} from './notifications';

// Muted Notifications API
export {
  mutedKeys,
  useIsMuted as useIsUserMuted,
  useMutedNotifications as useMutedNotificationsList,
  useMuteUser,
  useToggleMuteUser,
  useUnmuteUser
} from './muted';

// Subscriptions API
export {
  // Query Keys
  subscriptionKeys, useCancelSubscription,
  // Mutations
  useCreateSubscription, useCurrentUserSubscription, useDeleteSubscription, useIsSubscriptionActive,
  // Realtime
  useSubscriptionRealtime, useUpdateSubscription,
  // Queries
  useUserSubscription
} from './subscriptions';

// Events API
export {
  // Query Keys
  eventKeys,
  // Mutations
  useCreateEvent, useDeleteEvent, useEvent, useEventsRealtime,
  // Queries
  useGroupEvents,
  // Realtime
  useGroupEventsRealtime, useUpcomingGroupEvents, useUpdateEvent, useUserCreatedEvents, useUserGroupsEvents
} from './events';

// Utility functions for common operations
import { supabase } from './supabase';

export const apiUtils = {
  // Auth helpers
  getCurrentUserId: async () => {
    const { data: { user } } = await supabase.auth.getUser();
    return user?.id || null;
  },
  
  // Check if user is group member
  checkGroupMembership: async (groupId: string, userId: string) => {
    const { data, error } = await supabase
      .from('group_members')
      .select('user_id')
      .eq('group_id', groupId)
      .eq('user_id', userId)
      .single();
    
    if (error && error.code !== 'PGRST116') throw error;
    return !!data;
  },
  
  // Check if user owns group
  checkGroupOwnership: async (groupId: string, userId: string) => {
    const { data, error } = await supabase
      .from('groups')
      .select('owner_id')
      .eq('id', groupId)
      .eq('owner_id', userId)
      .single();
    
    if (error && error.code !== 'PGRST116') throw error;
    return !!data;
  },
  
  // Generate unique invite code
  generateInviteCode: () => {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let result = '';
    for (let i = 0; i < 8; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  },
  
  // Format date for display
  formatEventDate: (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('tr-TR', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  },
  
  // Check if subscription is active
  isSubscriptionActive: (subscription: { status: string; expires_at?: string | null }) => {
    if (subscription.status !== 'active') return false;
    
    if (subscription.expires_at) {
      const expiresAt = new Date(subscription.expires_at);
      const now = new Date();
      return expiresAt > now;
    }
    
    return true; // expires_at null ise sƒ±nƒ±rsƒ±z abonelik
  },
};
</file>

<file path="api/nicknames.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import type {
    CreateNickname,
    Nickname,
    UpdateNickname
} from '../types/database';
import { supabase } from './supabase';

// Query Keys
export const nicknameKeys = {
  all: ['nicknames'] as const,
  lists: () => [...nicknameKeys.all, 'list'] as const,
  list: (filters: string) => [...nicknameKeys.lists(), { filters }] as const,
  group: (groupId: string) => [...nicknameKeys.all, 'group', groupId] as const,
  user: (userId: string) => [...nicknameKeys.all, 'user', userId] as const,
  specific: (groupId: string, setterUserId: string, targetUserId: string) => 
    [...nicknameKeys.all, 'specific', groupId, setterUserId, targetUserId] as const,
};

// Queries
export const useGroupNicknames = (groupId: string) => {
  return useQuery({
    queryKey: nicknameKeys.group(groupId),
    queryFn: async (): Promise<Nickname[]> => {
      const { data, error } = await supabase
        .from('nicknames')
        .select('*')
        .eq('group_id', groupId);
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!groupId,
  });
};

export const useUserNicknames = (userId: string) => {
  return useQuery({
    queryKey: nicknameKeys.user(userId),
    queryFn: async (): Promise<Nickname[]> => {
      const { data, error } = await supabase
        .from('nicknames')
        .select('*')
        .eq('target_user_id', userId);
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!userId,
  });
};

export const useUserSetNicknames = (userId: string) => {
  return useQuery({
    queryKey: [...nicknameKeys.user(userId), 'set'],
    queryFn: async (): Promise<Nickname[]> => {
      const { data, error } = await supabase
        .from('nicknames')
        .select('*')
        .eq('setter_user_id', userId);
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!userId,
  });
};

export const useNickname = (groupId: string, setterUserId: string, targetUserId: string) => {
  return useQuery({
    queryKey: nicknameKeys.specific(groupId, setterUserId, targetUserId),
    queryFn: async (): Promise<Nickname | null> => {
      const { data, error } = await supabase
        .from('nicknames')
        .select('*')
        .eq('group_id', groupId)
        .eq('setter_user_id', setterUserId)
        .eq('target_user_id', targetUserId)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      return data || null;
    },
    enabled: !!(groupId && setterUserId && targetUserId),
  });
};

// Mutations
export const useCreateNickname = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (nicknameData: CreateNickname): Promise<Nickname> => {
      const { data, error } = await supabase
        .from('nicknames')
        .insert(nicknameData)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: nicknameKeys.all });
      queryClient.invalidateQueries({ queryKey: nicknameKeys.group(data.group_id) });
      queryClient.invalidateQueries({ queryKey: nicknameKeys.user(data.target_user_id) });
    },
  });
};

export const useUpdateNickname = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ 
      groupId, 
      setterUserId, 
      targetUserId, 
      updates 
    }: { 
      groupId: string; 
      setterUserId: string; 
      targetUserId: string; 
      updates: UpdateNickname;
    }): Promise<Nickname> => {
      const { data, error } = await supabase
        .from('nicknames')
        .update(updates)
        .eq('group_id', groupId)
        .eq('setter_user_id', setterUserId)
        .eq('target_user_id', targetUserId)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: nicknameKeys.all });
      queryClient.invalidateQueries({ queryKey: nicknameKeys.group(data.group_id) });
      queryClient.invalidateQueries({ queryKey: nicknameKeys.user(data.target_user_id) });
      queryClient.invalidateQueries({ 
        queryKey: nicknameKeys.specific(data.group_id, data.setter_user_id, data.target_user_id) 
      });
    },
  });
};

export const useDeleteNickname = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ 
      groupId, 
      setterUserId, 
      targetUserId 
    }: { 
      groupId: string; 
      setterUserId: string; 
      targetUserId: string;
    }): Promise<void> => {
      const { error } = await supabase
        .from('nicknames')
        .delete()
        .eq('group_id', groupId)
        .eq('setter_user_id', setterUserId)
        .eq('target_user_id', targetUserId);
      
      if (error) throw error;
    },
    onSuccess: (_, { groupId, targetUserId }) => {
      queryClient.invalidateQueries({ queryKey: nicknameKeys.all });
      queryClient.invalidateQueries({ queryKey: nicknameKeys.group(groupId) });
      queryClient.invalidateQueries({ queryKey: nicknameKeys.user(targetUserId) });
    },
  });
};

// Upsert Nickname (Create or Update)
export const useUpsertNickname = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (nicknameData: CreateNickname): Promise<Nickname> => {
      const { data, error } = await supabase
        .from('nicknames')
        .upsert(nicknameData, {
          onConflict: 'group_id,setter_user_id,target_user_id'
        })
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: nicknameKeys.all });
      queryClient.invalidateQueries({ queryKey: nicknameKeys.group(data.group_id) });
      queryClient.invalidateQueries({ queryKey: nicknameKeys.user(data.target_user_id) });
      queryClient.invalidateQueries({ 
        queryKey: nicknameKeys.specific(data.group_id, data.setter_user_id, data.target_user_id) 
      });
    },
  });
};

// Realtime Subscription Hook
export const useNicknamesRealtime = (groupId?: string) => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['nicknames-realtime', groupId],
    queryFn: () => {
      const channel = supabase
        .channel(`nicknames-changes${groupId ? `-${groupId}` : ''}`)
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'nicknames',
            ...(groupId && { filter: `group_id=eq.${groupId}` }),
          },
          () => {
            queryClient.invalidateQueries({ queryKey: nicknameKeys.all });
            if (groupId) {
              queryClient.invalidateQueries({ queryKey: nicknameKeys.group(groupId) });
            }
          }
        )
        .subscribe();

      return channel;
    },
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};
</file>

<file path="api/notifications.ts">
import { supabase } from './supabase';

/**
 * Bildirim g√∂nderme API'si
 * Supabase Edge Function'ƒ± √ßaƒüƒ±rƒ±r
 */

interface SendNotificationParams {
  user_ids?: string[]; // DEPRECATED - Artƒ±k kullanƒ±lmƒ±yor, receiver_ids kullanƒ±lacak
  receiver_ids: string[]; // Alƒ±cƒ± kullanƒ±cƒ± ID'leri (Supabase user IDs - external_id olarak kullanƒ±lacak)
  sender_id?: string; // Bildirim g√∂nderen kullanƒ±cƒ± ID (rate limiting i√ßin)
  receiver_id_to_player_id?: Record<string, string>; // DEPRECATED - Artƒ±k kullanƒ±lmƒ±yor
  group_id: string;
  group_name: string;
  title: string;
  message: string;
  type: 'join_request' | 'join_request_status' | 'status_update' | 'mood_update' | 'event_reminder';
}

/**
 * Bildirim g√∂nder
 */
export const sendNotification = async (params: SendNotificationParams) => {
  const { data, error } = await supabase.functions.invoke('send-notification', {
    body: params,
  });
      
  if (error) {
    // Rate limit hatasƒ± kontrol√º
    if (error.message?.includes('rate_limit_exceeded') || data?.error === 'rate_limit_exceeded') {
      const rateLimitError = new Error(data?.message || '√áok sƒ±k bildirim g√∂nderiyorsunuz. L√ºtfen bekleyin.');
      (rateLimitError as any).code = 'RATE_LIMIT_EXCEEDED';
      (rateLimitError as any).wait_until = data?.wait_until;
      (rateLimitError as any).wait_seconds = data?.wait_seconds;
      throw rateLimitError;
    }
    
    console.error('Bildirim g√∂nderme hatasƒ±:', error);
    throw error;
  }

      return data;
};

/**
 * Grup katƒ±lma isteƒüi bildirimi g√∂nder
 */
export const sendJoinRequestNotification = async (
  groupOwnerId: string, // Supabase user ID (external_id olarak kullanƒ±lacak)
  groupId: string,
  groupName: string,
  requesterName: string,
  requesterId: string // Rate limiting i√ßin
) => {
  return sendNotification({
    receiver_ids: [groupOwnerId], // Supabase user ID = OneSignal external_id
    sender_id: requesterId,
    group_id: groupId,
    group_name: groupName,
    title: 'Yeni Katƒ±lma ƒ∞steƒüi',
    message: `${requesterName} grubunuza katƒ±lmak istiyor`,
    type: 'join_request',
  });
};

/**
 * Katƒ±lma isteƒüi durumu bildirimi g√∂nder (onaylandƒ±/reddedildi)
 */
export const sendJoinRequestStatusNotification = async (
  requesterId: string, // Supabase user ID (external_id olarak kullanƒ±lacak)
  groupId: string,
  groupName: string,
  status: 'approved' | 'rejected',
  groupOwnerId: string // Rate limiting i√ßin
) => {
  const title = status === 'approved' ? 'Katƒ±lma ƒ∞steƒüi Onaylandƒ±' : 'Katƒ±lma ƒ∞steƒüi Reddedildi';
  const message =
    status === 'approved'
      ? `${groupName} grubuna katƒ±lma isteƒüiniz onaylandƒ±!`
      : `${groupName} grubuna katƒ±lma isteƒüiniz reddedildi.`;

  return sendNotification({
    receiver_ids: [requesterId], // Supabase user ID = OneSignal external_id
    sender_id: groupOwnerId,
    group_id: groupId,
    group_name: groupName,
    title,
    message,
    type: 'join_request_status',
  });
};

/**
 * Durum g√ºncellemesi bildirimi g√∂nder
 */
export const sendStatusUpdateNotification = async (
  receiverIds: string[], // Supabase user IDs (external_id olarak kullanƒ±lacak)
  groupId: string,
  groupName: string,
  userName: string,
  statusText: string,
  senderId: string // Rate limiting i√ßin
) => {
  return sendNotification({
    receiver_ids: receiverIds, // Supabase user IDs = OneSignal external_id
    sender_id: senderId,
    group_id: groupId,
    group_name: groupName,
    title: 'Durum G√ºncellendi',
    message: `${userName} durumunu "${statusText}" olarak g√ºncelledi`,
    type: 'status_update',
  });
};

/**
 * Mood g√ºncellemesi bildirimi g√∂nder
 */
export const sendMoodUpdateNotification = async (
  receiverIds: string[], // Supabase user IDs (external_id olarak kullanƒ±lacak)
  groupId: string,
  groupName: string,
  userName: string,
  moodText: string,
  senderId: string // Rate limiting i√ßin
) => {
  return sendNotification({
    receiver_ids: receiverIds, // Supabase user IDs = OneSignal external_id
    sender_id: senderId,
    group_id: groupId,
    group_name: groupName,
    title: 'Mood G√ºncellendi',
    message: `${userName} mood'unu "${moodText}" olarak g√ºncelledi`,
    type: 'mood_update',
  });
};

/**
 * Etkinlik hatƒ±rlatƒ±cƒ±sƒ± bildirimi g√∂nder
 */
export const sendEventReminderNotification = async (
  receiverIds: string[], // Supabase user IDs (external_id olarak kullanƒ±lacak)
  groupId: string,
  groupName: string,
  eventTitle: string
) => {
  return sendNotification({
    receiver_ids: receiverIds, // Supabase user IDs = OneSignal external_id
    group_id: groupId,
    group_name: groupName,
    title: 'Etkinlik Hatƒ±rlatƒ±cƒ±sƒ±',
    message: `${eventTitle} i√ßin 1 saat kaldƒ±!`,
    type: 'event_reminder',
  });
};
</file>

<file path="api/README.md">
# Geliom API Documentation

Bu klas√∂r, Supabase tabanlƒ± React Query API'lerini i√ßerir. T√ºm CRUD i≈ülemleri ve realtime √∂zellikler burada tanƒ±mlanmƒ±≈ütƒ±r.

## üìÅ Dosya Yapƒ±sƒ±

```
api/
‚îú‚îÄ‚îÄ index.ts           # Ana export dosyasƒ± - t√ºm API'leri buradan import edin
‚îú‚îÄ‚îÄ supabase.ts        # Supabase client konfig√ºrasyonu
‚îú‚îÄ‚îÄ users.ts           # Kullanƒ±cƒ± i≈ülemleri
‚îú‚îÄ‚îÄ moods.ts           # Mood i≈ülemleri
‚îú‚îÄ‚îÄ groups.ts          # Grup ve grup √ºyelik i≈ülemleri
‚îú‚îÄ‚îÄ nicknames.ts       # Takma ad i≈ülemleri
‚îú‚îÄ‚îÄ statuses.ts        # Durum ve kullanƒ±cƒ± durumu i≈ülemleri
‚îú‚îÄ‚îÄ notifications.ts   # Bildirim susturma i≈ülemleri
‚îú‚îÄ‚îÄ subscriptions.ts   # Abonelik i≈ülemleri
‚îî‚îÄ‚îÄ events.ts          # Zamanlanmƒ±≈ü etkinlik i≈ülemleri
```

## üöÄ Kullanƒ±m

### Temel Import

```typescript
import { 
  useUsers, 
  useCreateUser, 
  useUsersRealtime,
  apiUtils 
} from '../api';
```

### √ñrnek Kullanƒ±mlar

#### 1. Kullanƒ±cƒ±larƒ± Listele
```typescript
function UsersList() {
  const { data: users, isLoading, error } = useUsers();
  
  if (isLoading) return <div>Y√ºkleniyor...</div>;
  if (error) return <div>Hata: {error.message}</div>;
  
  return (
    <div>
      {users?.map(user => (
        <div key={user.id}>
          {user.display_name} - {user.mood?.emoji}
        </div>
      ))}
    </div>
  );
}
```

#### 2. Grup Olu≈ütur
```typescript
function CreateGroup() {
  const createGroup = useCreateGroup();
  const { mutate, isPending } = createGroup;
  
  const handleSubmit = async (formData: CreateGroup) => {
    mutate({
      ...formData,
      invite_code: apiUtils.generateInviteCode(),
    });
  };
  
  return (
    <form onSubmit={handleSubmit}>
      {/* Form alanlarƒ± */}
    </form>
  );
}
```

#### 3. Realtime Dinleme
```typescript
function GroupChat({ groupId }: { groupId: string }) {
  // Grup √ºyelerini realtime dinle
  useGroupMembersRealtime(groupId);
  
  const { data: members } = useGroupMembers(groupId);
  
  return (
    <div>
      {members?.map(member => (
        <div key={member.user_id}>
          {member.user?.display_name}
        </div>
      ))}
    </div>
  );
}
```

## üîê G√ºvenlik Kurallarƒ±

### Kullanƒ±cƒ± Yetkilendirme
- Kullanƒ±cƒ±lar sadece kendi verilerine eri≈üebilir
- Grup i≈ülemleri i√ßin grup √ºyeliƒüi kontrol edilir
- Supabase RLS (Row Level Security) politikalarƒ± ile korunur

### √ñrnek G√ºvenlik Kontrolleri
```typescript
// Grup √ºyeliƒüi kontrol et
const isMember = await apiUtils.checkGroupMembership(groupId, userId);
if (!isMember) {
  throw new Error('Bu gruba eri≈üim yetkiniz yok');
}

// Grup sahipliƒüi kontrol et
const isOwner = await apiUtils.checkGroupOwnership(groupId, userId);
if (!isOwner) {
  throw new Error('Bu i≈ülem i√ßin grup sahibi olmalƒ±sƒ±nƒ±z');
}
```

## üìä Tablo ƒ∞li≈ükileri

### Users (Kullanƒ±cƒ±lar)
- `mood_id` ‚Üí `moods.id`
- Grup √ºyelikleri: `group_members` tablosu √ºzerinden

### Groups (Gruplar)
- `owner_id` ‚Üí `users.id`
- √úyeler: `group_members` tablosu √ºzerinden

### Nicknames (Takma Adlar)
- `group_id` ‚Üí `groups.id`
- `setter_user_id` ‚Üí `users.id`
- `target_user_id` ‚Üí `users.id`

### User Statuses (Kullanƒ±cƒ± Durumlarƒ±)
- `user_id` ‚Üí `users.id`
- `status_id` ‚Üí `statuses.id`

### Scheduled Events (Etkinlikler)
- `group_id` ‚Üí `groups.id`
- `creator_id` ‚Üí `users.id`

## üîÑ Realtime √ñzellikler

Her tablo i√ßin realtime subscription hook'larƒ± mevcuttur:

- `useUsersRealtime()` - T√ºm kullanƒ±cƒ± deƒüi≈üiklikleri
- `useGroupsRealtime()` - T√ºm grup deƒüi≈üiklikleri
- `useGroupMembersRealtime(groupId)` - Belirli grup √ºyelik deƒüi≈üiklikleri
- `useNicknamesRealtime(groupId?)` - Takma ad deƒüi≈üiklikleri
- `useStatusesRealtime()` - Durum deƒüi≈üiklikleri
- `useUserStatusesRealtime()` - Kullanƒ±cƒ± durumu deƒüi≈üiklikleri
- `useMutedNotificationsRealtime(userId?)` - Bildirim susturma deƒüi≈üiklikleri
- `useSubscriptionRealtime(userId)` - Abonelik deƒüi≈üiklikleri
- `useGroupEventsRealtime(groupId)` - Grup etkinlik deƒüi≈üiklikleri

## üõ† Utility Fonksiyonlar

`apiUtils` objesi yararlƒ± yardƒ±mcƒ± fonksiyonlar i√ßerir:

```typescript
// Mevcut kullanƒ±cƒ± ID'sini al
const userId = await apiUtils.getCurrentUserId();

// Grup √ºyeliƒüi kontrol et
const isMember = await apiUtils.checkGroupMembership(groupId, userId);

// Grup sahipliƒüi kontrol et
const isOwner = await apiUtils.checkGroupOwnership(groupId, userId);

// Davet kodu olu≈ütur
const inviteCode = apiUtils.generateInviteCode();

// Tarih formatla
const formattedDate = apiUtils.formatEventDate(event.event_time);

// Abonelik durumu kontrol et
const isActive = apiUtils.isSubscriptionActive(subscription);
```

## üìù TypeScript Tipleri

T√ºm tipler `types/database.ts` dosyasƒ±nda tanƒ±mlanmƒ±≈ütƒ±r:

- `User`, `CreateUser`, `UpdateUser`
- `Group`, `CreateGroup`, `UpdateGroup`
- `Mood`, `CreateMood`, `UpdateMood`
- `Status`, `CreateStatus`, `UpdateStatus`
- `ScheduledEvent`, `CreateScheduledEvent`, `UpdateScheduledEvent`
- Ve daha fazlasƒ±...

## üîß Hata Y√∂netimi

React Query otomatik hata y√∂netimi saƒülar:

```typescript
const { data, error, isLoading, isError } = useUsers();

if (isError) {
  console.error('Kullanƒ±cƒ±lar y√ºklenirken hata:', error);
}
```

## üö® √ñnemli Notlar

1. **RLS Politikalarƒ±**: Supabase'de Row Level Security politikalarƒ±nƒ± mutlaka ayarlayƒ±n
2. **Auth Kontrolleri**: Her i≈ülem √∂ncesi kullanƒ±cƒ± kimlik doƒürulamasƒ± yapƒ±n
3. **Realtime Subscriptions**: Gereksiz subscription'larƒ± kapatmayƒ± unutmayƒ±n
4. **Error Boundaries**: React Error Boundary kullanarak hata yakalama yapƒ±n
5. **Loading States**: Kullanƒ±cƒ± deneyimi i√ßin loading durumlarƒ±nƒ± g√∂sterin
</file>

<file path="api/subscriptions.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import type {
    CreateSubscription,
    Subscription,
    UpdateSubscription
} from '../types/database';
import { supabase } from './supabase';

// Query Keys
export const subscriptionKeys = {
  all: ['subscriptions'] as const,
  user: (userId: string) => [...subscriptionKeys.all, 'user', userId] as const,
  active: (userId: string) => [...subscriptionKeys.user(userId), 'active'] as const,
};

// Queries
export const useUserSubscription = (userId: string) => {
  return useQuery({
    queryKey: subscriptionKeys.user(userId),
    queryFn: async (): Promise<Subscription | null> => {
      const { data, error } = await supabase
        .from('subscriptions')
        .select('*')
        .eq('user_id', userId)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      return data || null;
    },
    enabled: !!userId,
  });
};

export const useCurrentUserSubscription = () => {
  return useQuery({
    queryKey: ['current-user-subscription'],
    queryFn: async (): Promise<Subscription | null> => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return null;

      const { data, error } = await supabase
        .from('subscriptions')
        .select('*')
        .eq('user_id', user.id)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      return data || null;
    },
  });
};

export const useIsSubscriptionActive = (userId: string) => {
  return useQuery({
    queryKey: subscriptionKeys.active(userId),
    queryFn: async (): Promise<boolean> => {
      const { data, error } = await supabase
        .from('subscriptions')
        .select('expires_at')
        .eq('user_id', userId)
        .eq('status', 'active')
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      
      if (!data) return false;
      
      // Abonelik s√ºresi kontrol et
      if (data.expires_at) {
        const expiresAt = new Date(data.expires_at);
        const now = new Date();
        return expiresAt > now;
      }
      
      return true; // expires_at null ise sƒ±nƒ±rsƒ±z abonelik
    },
    enabled: !!userId,
  });
};

// Mutations
export const useCreateSubscription = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (subscriptionData: CreateSubscription): Promise<Subscription> => {
      const { data, error } = await supabase
        .from('subscriptions')
        .upsert(subscriptionData, {
          onConflict: 'user_id'
        })
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: subscriptionKeys.all });
      queryClient.invalidateQueries({ queryKey: subscriptionKeys.user(data.user_id) });
    },
  });
};

export const useUpdateSubscription = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ 
      userId, 
      updates 
    }: { 
      userId: string; 
      updates: UpdateSubscription;
    }): Promise<Subscription> => {
      const { data, error } = await supabase
        .from('subscriptions')
        .update(updates)
        .eq('user_id', userId)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: subscriptionKeys.all });
      queryClient.invalidateQueries({ queryKey: subscriptionKeys.user(data.user_id) });
    },
  });
};

export const useCancelSubscription = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (userId: string): Promise<Subscription> => {
      const { data, error } = await supabase
        .from('subscriptions')
        .update({ status: 'cancelled' })
        .eq('user_id', userId)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: subscriptionKeys.all });
      queryClient.invalidateQueries({ queryKey: subscriptionKeys.user(data.user_id) });
    },
  });
};

export const useDeleteSubscription = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (userId: string): Promise<void> => {
      const { error } = await supabase
        .from('subscriptions')
        .delete()
        .eq('user_id', userId);
      
      if (error) throw error;
    },
    onSuccess: (_, userId) => {
      queryClient.invalidateQueries({ queryKey: subscriptionKeys.all });
      queryClient.invalidateQueries({ queryKey: subscriptionKeys.user(userId) });
    },
  });
};

// Realtime Subscription Hook - Sadece kendi aboneliƒüini dinler
export const useSubscriptionRealtime = (userId: string) => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['subscription-realtime', userId],
    queryFn: () => {
      const channel = supabase
        .channel(`subscription-changes-${userId}`)
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'subscriptions',
            filter: `user_id=eq.${userId}`,
          },
          () => {
            queryClient.invalidateQueries({ queryKey: subscriptionKeys.user(userId) });
          }
        )
        .subscribe();

      return channel;
    },
    enabled: !!userId,
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};
</file>

<file path="api/supabase.ts">
import AsyncStorage from '@react-native-async-storage/async-storage';
import { createClient } from '@supabase/supabase-js';
import 'react-native-url-polyfill/auto'; // Supabase'in React Native'de d√ºzg√ºn √ßalƒ±≈ümasƒ± i√ßin gerekli

// Supabase projenizin bilgilerini buraya girin.
// En iyi pratik, bu bilgileri bir .env dosyasƒ±nda saklamaktƒ±r.
const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL || '';
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || '';

// Supabase istemcisini olu≈üturuyoruz.
// AsyncStorage'ƒ± oturum bilgilerini saklamak i√ßin kullanƒ±yoruz.
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: AsyncStorage,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
  realtime: {
    params: {
      eventsPerSecond: 10,
    },
  },
});
</file>

<file path="app/(drawer)/(group)/_layout.tsx">
import { Stack } from 'expo-router';
import React from 'react';

export default function GroupStackLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: false, // T√ºm stack ekranlarƒ±nda header kapalƒ±
      }}
    >
      <Stack.Screen
        name="create-group"
        options={{
          headerShown: false,
        }}
      />
      <Stack.Screen
        name="join-group"
        options={{
          headerShown: false,
        }}
      />
      <Stack.Screen
        name="join-requests"
        options={{
          headerShown: false,
        }}
      />
      <Stack.Screen
        name="search-user"
        options={{
          headerShown: false,
        }}
      />
      <Stack.Screen
        name="manage-members"
        options={{
          headerShown: false,
        }}
      />
    </Stack>
  );
}
</file>

<file path="app/(drawer)/(group)/create-group.tsx">
import { apiUtils } from "@/api";
import { useCreateGroup, useJoinGroup } from "@/api/groups";
import KeyboardAwareView from "@/components/KeyboardAwareView";
import { BaseLayout, GeliomButton, Typography } from "@/components/shared";
import { useAuth } from "@/contexts/AuthContext";
import { useGroupContext } from "@/contexts/GroupContext";
import { useTheme } from "@/contexts/ThemeContext";
import type { GroupWithOwner } from "@/types/database";
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useState } from "react";
import { Alert, StyleSheet, TextInput, TouchableOpacity, View } from "react-native";
import { useSafeAreaInsets } from 'react-native-safe-area-context';

const GROUP_TYPES = [
  { value: 'family', label: 'Aile', icon: 'home', desc: 'Ev halkƒ± i√ßin' },
  { value: 'friends', label: 'Arkada≈ülar', icon: 'people', desc: 'En yakƒ±nlar i√ßin' },
  { value: 'work', label: 'ƒ∞≈ü', icon: 'briefcase', desc: 'Ekip i√ßin' },
  { value: 'other', label: 'Diƒüer', icon: 'shapes', desc: '√ñzel gruplar' },
];

export default function CreateGroupScreen() {
  const { user } = useAuth();
  const { setSelectedGroup } = useGroupContext();
  const { colors } = useTheme();
  const router = useRouter();
  const insets = useSafeAreaInsets();
  
  // Hook'larƒ± component'in en √ºst seviyesinde tanƒ±mla
  const createGroupMutation = useCreateGroup();
  const joinGroupMutation = useJoinGroup();
  
  const headerHeight = 56 + insets.top;

  const [name, setName] = useState('');
  const [type, setType] = useState('family');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [nameError, setNameError] = useState<string | null>(null);
  
  const MEMBER_LIMIT = 5;

  const handleCreateGroup = async () => {
    if (!name.trim() || name.trim().length < 3) {
      setNameError('En az 3 karakter gerekli');
      return;
    }
    if (!user?.id) return;

    try {
      setIsSubmitting(true);
      const inviteCode = apiUtils.generateInviteCode();
      const group = await createGroupMutation.mutateAsync({
        owner_id: user.id,
        type,
        name: name.trim(),
        invite_code: inviteCode,
        member_limit: MEMBER_LIMIT,
      });
      await joinGroupMutation.mutateAsync({ group_id: group.id, user_id: user.id });
      
      const groupWithOwner: GroupWithOwner = { ...group, owner: user };
      await setSelectedGroup(groupWithOwner);
      router.replace('/(drawer)/home');
    } catch (error: any) {
      console.error('Grup olu≈üturma hatasƒ±:', error);
      Alert.alert('Hata', error.message || 'Grup olu≈üturulamadƒ±');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <BaseLayout
      headerShow={true}
      header={{
        leftIcon: { icon: <Ionicons name="arrow-back" size={24} color={colors.text} />, onPress: () => router.back() },
        title: <Typography variant="h5" color={colors.text}>Yeni Birlik Kur</Typography>,
        backgroundColor: colors.background,
      }}
    >
      <KeyboardAwareView contentContainerStyle={styles.contentContainer} keyboardVerticalOffset={headerHeight}>
        <View style={styles.headerSection}>
          <Typography variant="h3" color={colors.primary} style={{ marginBottom: 8 }}>
            {name ? name : 'ƒ∞simsiz Grup'}
          </Typography>
          <Typography variant="body" color={colors.secondaryText} style={{ textAlign: 'center' }}>
            Sevdiklerinle anlƒ±k durumlarƒ±nƒ± payla≈ümak i√ßin √∂zel bir alan.
          </Typography>
        </View>

        <View style={styles.form}>
          <View style={styles.inputGroup}>
            <Typography variant="label" color={colors.text} style={{ marginBottom: 8 }}>Grup ƒ∞smi</Typography>
            <TextInput
              style={[styles.input, { backgroundColor: colors.cardBackground, color: colors.text, borderColor: nameError ? colors.error : colors.stroke }]}
              placeholder="√ñrn: Canƒ±m Ailem"
              placeholderTextColor={colors.secondaryText + '80'}
              value={name}
              onChangeText={(t) => { setName(t); setNameError(null); }}
              maxLength={30}
            />
          </View>

          <View style={styles.inputGroup}>
            <Typography variant="label" color={colors.text} style={{ marginBottom: 12 }}>Grup Tipi</Typography>
            <View style={styles.typeGrid}>
              {GROUP_TYPES.map((groupType) => {
                const isSelected = type === groupType.value;
                return (
                  <TouchableOpacity
                    key={groupType.value}
                    style={[styles.typeCard, { backgroundColor: isSelected ? colors.primary + '10' : colors.cardBackground, borderColor: isSelected ? colors.primary : colors.stroke }]}
                    onPress={() => setType(groupType.value)}
                    activeOpacity={0.7}
                  >
                    <View style={[styles.iconBadge, { backgroundColor: isSelected ? colors.primary : colors.tertiary }]}>
                      <Ionicons name={groupType.icon as any} size={20} color={isSelected ? colors.white : colors.primary} />
                    </View>
                    <Typography variant="body" fontWeight="semibold" color={colors.text} style={{ marginTop: 8 }}>{groupType.label}</Typography>
                  </TouchableOpacity>
                );
              })}
            </View>
          </View>

          <GeliomButton
            state={isSubmitting ? 'loading' : 'active'}
            layout="full-width"
            size="large"
            icon="checkmark-circle"
            onPress={handleCreateGroup}
            disabled={isSubmitting}
          >
            {isSubmitting ? 'Olu≈üturuluyor...' : 'Grubu Olu≈ütur'}
          </GeliomButton>
        </View>
      </KeyboardAwareView>
    </BaseLayout>
  );
}

const styles = StyleSheet.create({
  contentContainer: { padding: 24, paddingBottom: 100 },
  headerSection: { alignItems: 'center', marginBottom: 32, paddingHorizontal: 20 },
  form: { gap: 28 },
  inputGroup: { gap: 4 },
  input: { borderWidth: 1.5, borderRadius: 16, paddingHorizontal: 16, paddingVertical: 16, fontSize: 18, fontFamily: 'Comfortaa-Medium' },
  typeGrid: { flexDirection: 'row', flexWrap: 'wrap', gap: 12 },
  typeCard: { width: '48%', padding: 12, borderRadius: 16, borderWidth: 1.5, alignItems: 'center', justifyContent: 'center' },
  iconBadge: { width: 40, height: 40, borderRadius: 20, justifyContent: 'center', alignItems: 'center' },
});
</file>

<file path="app/(drawer)/showroom.tsx">
import { BaseLayout, GeliomButton, Typography } from "@/components/shared";
import { useTheme } from "@/contexts/ThemeContext";
import React from 'react';
import { ScrollView, View } from "react-native";

export default function ShowroomScreen() {
  const { colors } = useTheme();

  return (
    <BaseLayout
      headerShow={false} // Drawer navigation kendi header'ƒ±nƒ± kullanacak
    >
      <ScrollView 
        style={{ flex: 1 }}
        contentContainerStyle={{ paddingHorizontal: 20, paddingTop: 8, paddingBottom: 20 }}
        showsVerticalScrollIndicator={false}
      >
        <Typography 
          variant="h2" 
          color={colors.text}
          style={{ marginBottom: 6, textAlign: 'center' }}
        >
          üåø GeliomButton Showroom
        </Typography>
        
        <Typography 
          variant="body" 
          color={colors.secondaryText}
          style={{ marginBottom: 24, textAlign: 'center' }}
        >
          Forest-Sage-Pine temalƒ± ana button sistemi
        </Typography>

        {/* GeliomButton - Ana Button Sistemi */}
        <View style={{ marginBottom: 32 }}>
          <Typography
            variant="h3"
            color={colors.primary}
            style={{ marginBottom: 16 }}
          >
            üåø GeliomButton - Ana Button Sistemi
          </Typography>
          <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 20 }}>
            Forest (Active), Sage (Passive), Pine (Loading) - Ada√ßayƒ± tarzƒ± organik tasarƒ±m
          </Typography>

          {/* Button States */}
          <View style={{ gap: 16 }}>
            <View>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 12 }}>
                Button Durumlarƒ±:
              </Typography>
              <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 12 }}>
                <GeliomButton state="active" onPress={() => console.log('Active pressed')}>
                  üå≤ Active (Forest)
                </GeliomButton>
                <GeliomButton state="passive" onPress={() => console.log('Passive pressed')}>
                  üåæ Passive (Sage)
                </GeliomButton>
                <GeliomButton state="loading" onPress={() => console.log('Loading pressed')}>
                  üå≤ Loading (Pine)
                </GeliomButton>
              </View>
            </View>

            {/* Button Sizes */}
            <View>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 12 }}>
                Boyutlar (Ada√ßayƒ± Tarzƒ± Organik):
              </Typography>
              <View style={{ flexDirection: 'row', flexWrap: 'wrap', alignItems: 'center', gap: 12 }}>
                <GeliomButton state="active" size="small">
                  Small
                </GeliomButton>
                <GeliomButton state="active" size="medium">
                  Medium
                </GeliomButton>
                <GeliomButton state="active" size="large">
                  Large
                </GeliomButton>
                <GeliomButton state="active" size="xl">
                  XL
                </GeliomButton>
              </View>
            </View>

            {/* Icon Layouts */}
            <View>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 12 }}>
                Icon Layout'larƒ±:
              </Typography>
              <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 12 }}>
                <GeliomButton 
                  state="active" 
                  layout="icon-left" 
                  icon="leaf"
                  onPress={() => console.log('Icon left')}
                >
                  Sol Icon
                </GeliomButton>
                <GeliomButton 
                  state="passive" 
                  layout="icon-right" 
                  icon="flower"
                  onPress={() => console.log('Icon right')}
                >
                  Saƒü Icon
                </GeliomButton>
                <GeliomButton 
                  state="active" 
                  layout="icon-only" 
                  icon="heart"
                  onPress={() => console.log('Icon only')}
                />
              </View>
            </View>

            {/* Size + Layout Combinations */}
            <View>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 12 }}>
                Boyut + Layout Kombinasyonlarƒ±:
              </Typography>
              <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 12 }}>
                <GeliomButton 
                  state="active" 
                  size="small"
                  layout="icon-left" 
                  icon="leaf"
                >
                  üåø K√º√ß√ºk
                </GeliomButton>
                <GeliomButton 
                  state="passive" 
                  size="large"
                  layout="icon-right" 
                  icon="flower"
                >
                  üå∏ B√ºy√ºk
                </GeliomButton>
                <GeliomButton 
                  state="active" 
                  size="xl"
                  layout="icon-left" 
                  icon="leaf"
                >
                  üå≥ Extra Large
                </GeliomButton>
              </View>
            </View>

            {/* Icon Only Different Sizes */}
            <View>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 12 }}>
                Icon-Only Farklƒ± Boyutlar:
              </Typography>
              <View style={{ flexDirection: 'row', flexWrap: 'wrap', alignItems: 'center', gap: 12 }}>
                <GeliomButton 
                  state="active" 
                  size="small"
                  layout="icon-only" 
                  icon="heart"
                />
                <GeliomButton 
                  state="passive" 
                  size="medium"
                  layout="icon-only" 
                  icon="star"
                />
                <GeliomButton 
                  state="active" 
                  size="large"
                  layout="icon-only" 
                  icon="diamond"
                />
                <GeliomButton 
                  state="loading" 
                  size="xl"
                  layout="icon-only" 
                  icon="flash"
                />
              </View>
            </View>

            {/* Full Width Examples */}
            <View>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 12 }}>
                Full Width √ñrnekleri:
              </Typography>
              <View style={{ gap: 12 }}>
                <GeliomButton 
                  state="active" 
                  layout="full-width"
                  icon="checkmark-circle"
                  onPress={() => console.log('Full width active')}
                >
                  üå≤ Tam Geni≈ülik Active Button
                </GeliomButton>
                <GeliomButton 
                  state="passive" 
                  layout="full-width"
                  size="large"
                  icon="information-circle"
                  onPress={() => console.log('Full width passive')}
                >
                  üåæ B√ºy√ºk Passive Button
                </GeliomButton>
              </View>
            </View>

            {/* Mixed State Examples */}
            <View>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 12 }}>
                Karƒ±≈üƒ±k Durum √ñrnekleri:
              </Typography>
              <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 12 }}>
                <GeliomButton 
                  state="active" 
                  size="small"
                  layout="icon-left" 
                  icon="leaf"
                >
                  üåø Aktif
                </GeliomButton>
                <GeliomButton 
                  state="passive" 
                  size="medium"
                  layout="icon-right" 
                  icon="pause"
                >
                  ‚è∏Ô∏è Pasif
                </GeliomButton>
                <GeliomButton 
                  state="loading" 
                  size="large"
                  layout="icon-left" 
                  icon="refresh"
                >
                  üîÑ Y√ºkleniyor
                </GeliomButton>
              </View>
            </View>

            {/* Disabled Examples */}
            <View>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 12 }}>
                Disabled Durumlarƒ±:
              </Typography>
              <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 12 }}>
                <GeliomButton 
                  state="active" 
                  disabled
                  icon="ban"
                >
                  Disabled Active
                </GeliomButton>
                <GeliomButton 
                  state="passive" 
                  disabled
                  layout="icon-right"
                  icon="close"
                >
                  Disabled Passive
                </GeliomButton>
              </View>
            </View>
          </View>
        </View>

        <View style={{ marginBottom: 32 }}>
          <Typography 
            variant="h3" 
            color={colors.text}
            style={{ marginBottom: 16 }}
          >
            Diƒüer Component'ler
          </Typography>
          
          <View style={{
            backgroundColor: colors.disabled,
            padding: 20,
            borderRadius: 12,
            alignItems: 'center',
          }}>
            <Typography variant="body" color={colors.secondaryText}>
              Daha fazla component yakƒ±nda...
            </Typography>
          </View>
        </View>
      </ScrollView>
    </BaseLayout>
  );
}
</file>

<file path="components/shared/BaseLayout.tsx">
import { useTheme } from '@/contexts/ThemeContext';
import React, { ReactNode } from 'react';
import {
  ImageBackground,
  Platform,
  StatusBar,
  StyleSheet,
  TouchableOpacity,
  View,
  ViewStyle
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

// Header i√ßin icon tipini tanƒ±mla
export interface HeaderIconProps {
  icon: ReactNode;
  onPress?: () => void;
}

// Header props interface'i
export interface HeaderProps {
  leftIcon?: HeaderIconProps;
  rightIcon?: HeaderIconProps;
  title?: ReactNode;
  backgroundColor?: string;
  height?: number;
  style?: ViewStyle;
}

// BaseLayout props interface'i
export interface BaseLayoutProps {
  children: ReactNode;
  fullScreen?: boolean;
  headerShow?: boolean;
  header?: HeaderProps;
  backgroundImage?: any;
  backgroundColor?: string;
  style?: ViewStyle;
  contentStyle?: ViewStyle;
}

// Header Component'i
const Header: React.FC<HeaderProps> = ({
  leftIcon,
  rightIcon,
  title,
  backgroundColor,
  height = 56,
  style,
}) => {
  const { colors } = useTheme();
  const insets = useSafeAreaInsets();

  return (
    <View
      style={[
        styles.headerContainer,
        {
          backgroundColor: backgroundColor || colors.background,
          height: height + insets.top,
          paddingTop: insets.top,
        },
        style,
      ]}
    >
      <View style={styles.headerContent}>
        {/* Sol taraf - Icon ve Title */}
        <View style={styles.headerLeft}>
          {leftIcon && (
            <TouchableOpacity 
              style={styles.iconContainer}
              onPress={leftIcon.onPress}
              activeOpacity={0.7}
            >
              {leftIcon.icon}
            </TouchableOpacity>
          )}
          {title && <View style={styles.titleContainer}>{title}</View>}
        </View>

        {/* Saƒü taraf - Icon */}
        {rightIcon && (
          <View style={styles.headerRight}>
            <TouchableOpacity 
              style={styles.iconContainer}
              onPress={rightIcon.onPress}
              activeOpacity={0.7}
            >
              {rightIcon.icon}
            </TouchableOpacity>
          </View>
        )}
      </View>
    </View>
  );
};

// Ana BaseLayout Component'i
const BaseLayout: React.FC<BaseLayoutProps> = ({
  children,
  fullScreen = false,
  headerShow = true,
  header,
  backgroundImage,
  backgroundColor,
  style,
  contentStyle,
}) => {
  const { colors, isDark } = useTheme();
  const insets = useSafeAreaInsets();

  // Status bar style'ƒ±nƒ± tema g√∂re ayarla
  const statusBarStyle = isDark ? 'light-content' : 'dark-content';
  const statusBarBackgroundColor = header?.backgroundColor || backgroundColor || colors.background;

  // Container style'ƒ±nƒ± hazƒ±rla
  const containerStyle: ViewStyle = {
    ...styles.container,
    backgroundColor: backgroundColor || colors.background,
    paddingTop: fullScreen ? 0 : (headerShow && header ? 0 : insets.top),
    paddingBottom: fullScreen ? 0 : insets.bottom,
    paddingLeft: fullScreen ? 0 : insets.left,
    paddingRight: fullScreen ? 0 : insets.right,
    ...style,
  };

  // Content style'ƒ±nƒ± hazƒ±rla
  const finalContentStyle: ViewStyle = {
    ...styles.content,
    ...contentStyle,
  };

  return (
    <>
      {/* Status Bar */}
      <StatusBar
        barStyle={statusBarStyle}
        backgroundColor={Platform.OS === 'android' ? statusBarBackgroundColor : undefined}
        translucent={fullScreen}
      />

      {/* Ana Container */}
      {backgroundImage ? (
        <ImageBackground source={backgroundImage} style={containerStyle}>
          {/* Header */}
          {headerShow && header && (
            <Header {...header} />
          )}

          {/* Content */}
          <View style={finalContentStyle}>
            {children}
          </View>
        </ImageBackground>
      ) : (
        <View style={containerStyle}>
          {/* Header */}
          {headerShow && header && (
            <Header {...header} />
          )}

          {/* Content */}
          <View style={finalContentStyle}>
            {children}
          </View>
        </View>
      )}
    </>
  );
};

// Styles
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
  },
  headerContainer: {
    justifyContent: 'flex-end',
    zIndex: 1000,
  },
  headerContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    height: 56,
    paddingHorizontal: 16,
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  headerRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconContainer: {
    minWidth: 40,
    minHeight: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  titleContainer: {
    marginLeft: 12,
    flex: 1,
  },
});

export default BaseLayout;
</file>

<file path="components/shared/BlurButton.tsx">
import { useTheme } from '@/contexts/ThemeContext';
import { fonts, typography } from '@/theme/typography';
import { BlurView } from 'expo-blur';
import { LinearGradient } from 'expo-linear-gradient';
import React, { ReactNode } from 'react';
import {
    StyleSheet,
    Text,
    TouchableOpacity,
    View,
    ViewStyle,
} from 'react-native';

// Button variant tipleri
export type BlurButtonVariant = 
  | 'primary'      // 1. Ana ye≈üil gradient
  | 'secondary'    // 2. ƒ∞kincil ye≈üil
  | 'tertiary'     // 3. A√ßƒ±k ye≈üil
  | 'success'      // 4. Ba≈üarƒ± ye≈üili
  | 'glass'        // 5. ≈ûeffaf cam efekti
  | 'outline'      // 6. √áer√ßeveli
  | 'ghost'        // 7. Hayalet buton
  | 'danger'       // 8. Hata/silme butonu
  | 'forest'       // 9. Orman ye≈üili
  | 'mint'         // 10. Nane ye≈üili
  | 'lime'         // 11. Limon ye≈üili
  | 'emerald'      // 12. Z√ºmr√ºt ye≈üili
  | 'sage'         // 13. Ada√ßayƒ± ye≈üili
  | 'olive'        // 14. Zeytin ye≈üili
  | 'jade'         // 15. Ye≈üim ye≈üili
  | 'teal'         // 16. √áamurcun ye≈üili
  | 'pine'         // 17. √áam ye≈üili
  | 'moss'         // 18. Yosun ye≈üili
  | 'seafoam'      // 19. Deniz k√∂p√ºƒü√º
  | 'spring'       // 20. Bahar ye≈üili

export type BlurButtonSize = 'small' | 'medium' | 'large';

export type BlurButtonRadius = 'none' | 'small' | 'medium' | 'large' | 'full';

export interface BlurButtonProps {
  children: ReactNode;
  variant?: BlurButtonVariant;
  size?: BlurButtonSize;
  radius?: BlurButtonRadius;
  disabled?: boolean;
  onPress?: () => void;
  style?: ViewStyle;
  icon?: ReactNode;
  iconPosition?: 'left' | 'right';
  fullWidth?: boolean;
  loading?: boolean;
}

const BlurButton: React.FC<BlurButtonProps> = ({
  children,
  variant = 'primary',
  size = 'medium',
  radius = 'medium',
  disabled = false,
  onPress,
  style,
  icon,
  iconPosition = 'left',
  fullWidth = false,
  loading = false,
}) => {
  const { colors, isDark } = useTheme();

  // Size configurations
  const sizeConfig = {
    small: {
      paddingHorizontal: 16,
      paddingVertical: 8,
      fontSize: typography.caption.fontSize,
      fontFamily: fonts[typography.caption.defaultFontWeight],
      minHeight: 36,
    },
    medium: {
      paddingHorizontal: 20,
      paddingVertical: 12,
      fontSize: typography.button.fontSize,
      fontFamily: fonts[typography.button.defaultFontWeight],
      minHeight: 44,
    },
    large: {
      paddingHorizontal: 24,
      paddingVertical: 16,
      fontSize: typography.h6.fontSize,
      fontFamily: fonts[typography.h6.defaultFontWeight],
      minHeight: 52,
    },
  };

  const currentSize = sizeConfig[size];

  // Radius configurations
  const radiusConfig = {
    none: 0,
    small: 6,
    medium: 12,
    large: 20,
    full: 9999,
  };

  const currentRadius = radiusConfig[radius];

  // Variant configurations
  const getVariantStyle = () => {
    switch (variant) {
      case 'primary':
        return {
          gradient: [colors.primary, colors.secondary] as const,
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: colors.primary,
          useGradient: true,
          useBlur: false,
        };
      
      case 'secondary':
        return {
          backgroundColor: colors.secondary,
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: colors.secondary,
          useGradient: false,
          useBlur: false,
        };
      
      case 'tertiary':
        return {
          backgroundColor: colors.tertiary,
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: colors.tertiary,
          useGradient: false,
          useBlur: false,
        };
      
      case 'success':
        return {
          backgroundColor: colors.success,
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: colors.success,
          useGradient: false,
          useBlur: false,
        };
      
      case 'glass':
        return {
          backgroundColor: 'transparent',
          textColor: colors.text,
          borderColor: colors.stroke,
          shadowColor: colors.shadow,
          useGradient: false,
          useBlur: true,
        };
      
      case 'outline':
        return {
          backgroundColor: 'transparent',
          textColor: colors.primary,
          borderColor: colors.primary,
          shadowColor: 'transparent',
          useGradient: false,
          useBlur: false,
        };
      
      case 'ghost':
        return {
          backgroundColor: colors.primary + '20',
          textColor: colors.primary,
          borderColor: 'transparent',
          shadowColor: 'transparent',
          useGradient: false,
          useBlur: false,
        };
      
      case 'danger':
        return {
          backgroundColor: colors.error,
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: colors.error,
          useGradient: false,
          useBlur: false,
        };
      
      case 'forest':
        return {
          backgroundColor: (colors as any).forest || '#1B5E20',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).forest || '#1B5E20',
          useGradient: false,
          useBlur: false,
        };
      
      case 'mint':
        return {
          backgroundColor: (colors as any).mint || '#00E676',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).mint || '#00E676',
          useGradient: false,
          useBlur: false,
        };
      
      case 'lime':
        return {
          backgroundColor: (colors as any).lime || '#8BC34A',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).lime || '#8BC34A',
          useGradient: false,
          useBlur: false,
        };
      
      case 'emerald':
        return {
          backgroundColor: (colors as any).emerald || '#009688',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).emerald || '#009688',
          useGradient: false,
          useBlur: false,
        };
      
      case 'sage':
        return {
          backgroundColor: (colors as any).sage || '#87A96B',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).sage || '#87A96B',
          useGradient: false,
          useBlur: false,
        };
      
      case 'olive':
        return {
          backgroundColor: (colors as any).olive || '#6B8E23',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).olive || '#6B8E23',
          useGradient: false,
          useBlur: false,
        };
      
      case 'jade':
        return {
          backgroundColor: (colors as any).jade || '#00A86B',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).jade || '#00A86B',
          useGradient: false,
          useBlur: false,
        };
      
      case 'teal':
        return {
          backgroundColor: (colors as any).teal || '#008080',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).teal || '#008080',
          useGradient: false,
          useBlur: false,
        };
      
      case 'pine':
        return {
          backgroundColor: (colors as any).pine || '#01796F',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).pine || '#01796F',
          useGradient: false,
          useBlur: false,
        };
      
      case 'moss':
        return {
          backgroundColor: (colors as any).moss || '#8A9A5B',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).moss || '#8A9A5B',
          useGradient: false,
          useBlur: false,
        };
      
      case 'seafoam':
        return {
          backgroundColor: (colors as any).seafoam || '#71BC78',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).seafoam || '#71BC78',
          useGradient: false,
          useBlur: false,
        };
      
      case 'spring':
        return {
          backgroundColor: (colors as any).spring || '#00FF7F',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).spring || '#00FF7F',
          useGradient: false,
          useBlur: false,
        };
      
      default:
        return {
          backgroundColor: colors.primary,
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: colors.primary,
          useGradient: false,
          useBlur: false,
        };
    }
  };

  const variantStyle = getVariantStyle();

  const buttonStyle: ViewStyle = {
    ...currentSize,
    borderRadius: currentRadius,
    borderWidth: variantStyle.borderColor !== 'transparent' ? 1 : 0,
    borderColor: variantStyle.borderColor,
    opacity: disabled ? 0.5 : 1,
    width: fullWidth ? '100%' : undefined,
    shadowColor: variantStyle.shadowColor,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 5,
    overflow: 'hidden',
    ...style,
  };

  const renderContent = () => (
    <View style={styles.contentContainer}>
      {icon && iconPosition === 'left' && (
        <View style={styles.iconContainer}>{icon}</View>
      )}
      
      <Text
        style={[
          styles.text,
          {
            color: variantStyle.textColor,
            fontSize: currentSize.fontSize,
            fontFamily: currentSize.fontFamily,
          },
        ]}
      >
        {loading ? 'Y√ºkleniyor...' : children}
      </Text>
      
      {icon && iconPosition === 'right' && (
        <View style={styles.iconContainer}>{icon}</View>
      )}
    </View>
  );

  const renderButton = () => {
    if (variantStyle.useBlur) {
      return (
        <BlurView
          intensity={20}
          tint={isDark ? 'dark' : 'light'}
          style={buttonStyle}
        >
          {renderContent()}
        </BlurView>
      );
    }

    if (variantStyle.useGradient && variantStyle.gradient) {
      return (
        <LinearGradient
          colors={variantStyle.gradient}
          style={buttonStyle}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        >
          {renderContent()}
        </LinearGradient>
      );
    }

    return (
      <View style={[buttonStyle, { backgroundColor: variantStyle.backgroundColor }]}>
        {renderContent()}
      </View>
    );
  };

  return (
    <TouchableOpacity
      onPress={onPress}
      disabled={disabled || loading}
      activeOpacity={0.8}
      style={styles.touchable}
    >
      {renderButton()}
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  touchable: {
    alignSelf: 'flex-start',
  },
  contentContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
  },
  text: {
    textAlign: 'center',
    fontWeight: '600',
  },
  iconContainer: {
    alignItems: 'center',
    justifyContent: 'center',
  },
});

export default BlurButton;
</file>

<file path="components/shared/Popover.tsx">
import { useTheme } from "@/contexts/ThemeContext";
import React, { useRef, useState } from "react";
import { Dimensions, Modal, StyleSheet, TouchableOpacity, TouchableWithoutFeedback, View } from "react-native";
import CustomText from "./Text";

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

export interface PopoverItem {
    id: string;
    label: string;
    icon?: React.ReactNode;
    onPress: () => void;
}

interface PopoverProps {
    items: PopoverItem[];
    trigger: React.ReactNode; // Tƒ±klanacak element (icon, button, vs.)
    width?: number; // Popover geni≈üliƒüi (default: 200)
}

interface Position {
    top?: number;
    bottom?: number;
    left?: number;
    right?: number;
}

export default function Popover({ items, trigger, width = 200 }: PopoverProps) {
    const { colors } = useTheme();
    const [visible, setVisible] = useState(false);
    const [position, setPosition] = useState<Position>({});
    const triggerRef = useRef<View>(null);

    const POPOVER_PADDING = 8; // Ekran kenarƒ±ndan minimum mesafe
    const ITEM_HEIGHT = 48; // Her item'ƒ±n y√ºksekliƒüi
    const POPOVER_HEIGHT = items.length * ITEM_HEIGHT;

    // Trigger'a tƒ±klandƒ±ƒüƒ±nda popover'ƒ± a√ß ve pozisyonu hesapla
    const handleOpen = () => {
        triggerRef.current?.measureInWindow((x, y, triggerWidth, triggerHeight) => {
            const calculatedPosition = calculatePosition(x, y, triggerWidth, triggerHeight);
            setPosition(calculatedPosition);
            setVisible(true);
        });
    };

    // En uygun pozisyonu hesapla
    const calculatePosition = (
        triggerX: number,
        triggerY: number,
        triggerWidth: number,
        triggerHeight: number
    ): Position => {
        const pos: Position = {};

        // Yatay pozisyon (saƒü veya sol)
        const spaceOnRight = SCREEN_WIDTH - (triggerX + triggerWidth);
        const spaceOnLeft = triggerX;

        if (spaceOnRight >= width + POPOVER_PADDING) {
            // Saƒüda yeterli alan var, saƒüa a√ß
            pos.left = triggerX + triggerWidth + POPOVER_PADDING;
        } else if (spaceOnLeft >= width + POPOVER_PADDING) {
            // Solda yeterli alan var, sola a√ß
            pos.right = SCREEN_WIDTH - triggerX + POPOVER_PADDING;
        } else {
            // Her iki tarafta da yeterli alan yok, trigger'ƒ±n altƒ±na/√ºst√ºne ortalƒ± a√ß
            const centeredLeft = triggerX + triggerWidth / 2 - width / 2;
            pos.left = Math.max(POPOVER_PADDING, Math.min(centeredLeft, SCREEN_WIDTH - width - POPOVER_PADDING));
        }

        // Dikey pozisyon (alt veya √ºst)
        const spaceBelow = SCREEN_HEIGHT - (triggerY + triggerHeight);
        const spaceAbove = triggerY;

        if (spaceBelow >= POPOVER_HEIGHT + POPOVER_PADDING) {
            // Altta yeterli alan var
            pos.top = triggerY + triggerHeight + POPOVER_PADDING;
        } else if (spaceAbove >= POPOVER_HEIGHT + POPOVER_PADDING) {
            // √ústte yeterli alan var
            pos.bottom = SCREEN_HEIGHT - triggerY + POPOVER_PADDING;
        } else {
            // Her iki tarafta da yeterli alan yok, trigger'ƒ±n yanƒ±na ortalƒ± a√ß
            if (pos.left !== undefined || pos.right !== undefined) {
                // Yatay a√ßƒ±lƒ±m yapƒ±lmƒ±≈üsa, dikey olarak trigger'la hizala
                pos.top = Math.max(POPOVER_PADDING, Math.min(triggerY, SCREEN_HEIGHT - POPOVER_HEIGHT - POPOVER_PADDING));
            } else {
                // Ekranƒ±n ortasƒ±na yerle≈ütir
                pos.top = (SCREEN_HEIGHT - POPOVER_HEIGHT) / 2;
            }
        }

        return pos;
    };

    const handleClose = () => {
        setVisible(false);
    };

    const handleItemPress = (item: PopoverItem) => {
        item.onPress();
        handleClose();
    };

    return (
        <>
            {/* Trigger Element */}
            <View ref={triggerRef} collapsable={false}>
                <TouchableOpacity onPress={handleOpen} activeOpacity={0.7}>
                    {trigger}
                </TouchableOpacity>
            </View>

            {/* Popover Modal */}
            <Modal
                visible={visible}
                transparent
                animationType="fade"
                onRequestClose={handleClose}
            >
                <TouchableWithoutFeedback onPress={handleClose}>
                    <View style={styles.overlay}>
                        <TouchableWithoutFeedback>
                            <View
                                style={[
                                    styles.popoverContainer,
                                    {
                                        backgroundColor: colors.background,
                                        borderColor: colors.stroke,
                                        width: width,
                                    },
                                    position,
                                ]}
                            >
                                {items.map((item, index) => (
                                    <React.Fragment key={item.id}>
                                        <TouchableOpacity
                                            style={styles.item}
                                            onPress={() => handleItemPress(item)}
                                            activeOpacity={0.7}
                                        >
                                            <CustomText
                                                variant="h7"
                                                fontWeight="regular"
                                                style={[styles.label, { color: colors.text }]}
                                            >
                                                {item.label}
                                            </CustomText>
                                            {item.icon && (
                                                <View style={styles.iconContainer}>
                                                    {item.icon}
                                                </View>
                                            )}
                                        </TouchableOpacity>
                                        {index < items.length - 1 && (
                                            <View style={[styles.divider, { backgroundColor: colors.stroke }]} />
                                        )}
                                    </React.Fragment>
                                ))}
                            </View>
                        </TouchableWithoutFeedback>
                    </View>
                </TouchableWithoutFeedback>
            </Modal>
        </>
    );
}

const styles = StyleSheet.create({
    overlay: {
        flex: 1,
        backgroundColor: 'transparent', // Overlay yok
    },
    popoverContainer: {
        position: 'absolute',
        borderRadius: 12,
        borderWidth: 1,
        overflow: 'hidden',
    },
    item: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        paddingHorizontal: 16,
        paddingVertical: 12,
        height: 48,
    },
    label: {
        flex: 1,
    },
    iconContainer: {
        marginLeft: 12,
    },
    divider: {
        height: 1,
        marginHorizontal: 0, // Kenarlara sƒ±fƒ±r
    },
});
</file>

<file path="components/shared/Text.tsx">
import { useTheme } from '@/contexts/ThemeContext';
import { fonts, typography, type Fonts, type TypographyKeys } from '@/theme/typography';
import { Platform, Text as RNText, TextProps as RNTextProps, StyleProp, TextStyle } from 'react-native';

interface TextProps extends RNTextProps {
    variant?: keyof TypographyKeys;
    fontWeight?: keyof Fonts;
    color?: string;
}

export default function CustomText({
    variant = 'body',
    fontWeight,
    children,
    style,
    color,
    ...props
}: TextProps) {
    const { colors } = useTheme();
    const variantStyle = typography[variant];
    const { defaultFontWeight, ...baseVariantStyles } = variantStyle;
    const finalWeight = fontWeight || defaultFontWeight;
    const fontFamily = fonts[finalWeight];

    let processedChildren = children;

    if (typeof children === 'string') {
        processedChildren = children
            .replace(/tt/g, 't\u200Bt') 
            .replace(/fi/g, 'f\u200Bi') 
            .replace(/fl/g, 'f\u200Bl') 
            .replace(/ti/g, 't\u200Bi') 
            .replace(/ff/g, 'f\u200Bf');
    }

    const combinedStyle = [
        { color: color || colors.text },
        baseVariantStyles,
        { fontFamily: fontFamily },
        style,
    ] as StyleProp<TextStyle>[];

    return (
        <RNText 
            style={[combinedStyle, Platform.OS === 'android' && {fontVariant: ['no-common-ligatures']}]} 
            {...props}
        >
            {processedChildren}
        </RNText>
    );
};
</file>

<file path="components/shared/Typography.tsx">
import { useTheme } from '@/contexts/ThemeContext';
import { fonts, typography, TypographyKeys } from '@/theme/typography';
import React from 'react';
import { Text, TextProps, TextStyle } from 'react-native';

// Typography component props
interface TypographyProps extends TextProps {
  variant?: keyof TypographyKeys;
  color?: string;
  fontWeight?: keyof typeof fonts;
  children: React.ReactNode;
}

// Typography component - Geliom i√ßin optimize edilmi≈ü
const Typography: React.FC<TypographyProps> = ({
  variant = 'body',
  color,
  fontWeight,
  style,
  children,
  ...props
}) => {
  const { colors } = useTheme();
  
  // Se√ßilen variant'ƒ±n stillerini al
  const variantStyle = typography[variant];
  
  // Font weight'i belirle (prop > variant default > regular)
  const finalFontWeight = fontWeight || variantStyle.defaultFontWeight;
  
  // Final style'ƒ± olu≈ütur
  const textStyle: TextStyle = {
    fontSize: variantStyle.fontSize,
    lineHeight: variantStyle.lineHeight,
    fontFamily: fonts[finalFontWeight],
    letterSpacing: variantStyle.letterSpacing,
    color: color || colors.text,
    ...(Array.isArray(style) ? Object.assign({}, ...style) : style),
  };

  return (
    <Text style={textStyle} {...props}>
      {children}
    </Text>
  );
};

export default Typography;
</file>

<file path="components/ui/NetworkToast.tsx">
import { useTheme } from "@/contexts/ThemeContext";
import { Ionicons } from "@expo/vector-icons";
import React, { useEffect } from "react";
import { StyleSheet, View } from "react-native";
import Animated, { useAnimatedStyle, useSharedValue, withSpring, withTiming } from "react-native-reanimated";
import { CustomText } from "../shared";

export type NetworkToastType = 'weak' | 'offline';

interface NetworkToastProps {
  type: NetworkToastType;
  message: string;
  visible: boolean;
  onHide?: () => void;
  duration?: number;
}

export default function NetworkToast({
  type,
  message,
  visible,
  onHide,
  duration = 3000,
}: NetworkToastProps) {
  const { colors } = useTheme();
  const translateY = useSharedValue(-100);
  const opacity = useSharedValue(0);

  useEffect(() => {
    if (visible) {
      // Show animation
      translateY.value = withSpring(0, {
        damping: 15,
        stiffness: 100,
      });
      opacity.value = withTiming(1, { duration: 300 });

      // Auto hide after duration
      if (duration > 0) {
        const timer = setTimeout(() => {
          hideToast();
        }, duration);

        return () => clearTimeout(timer);
      }
    } else {
      hideToast();
    }
  }, [visible]);

  const hideToast = () => {
    translateY.value = withTiming(-100, { duration: 300 });
    opacity.value = withTiming(0, { duration: 300 });
    
    setTimeout(() => {
      onHide?.();
    }, 300);
  };

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ translateY: translateY.value }],
    opacity: opacity.value,
  }));

  if (!visible) return null;

  const isWeak = type === 'weak';
  const iconBgColor = isWeak ? '#FFA500' : '#E50049'; // Orange for weak, Red for offline

  return (
    <Animated.View
      style={[
        styles.container,
        {
          backgroundColor: isWeak ? colors.secondarybackground : colors.secondarybackground,
        },
        animatedStyle,
      ]}
    >
      <View style={[styles.iconContainer, { backgroundColor: iconBgColor }]}>
        {isWeak ? (
          <Ionicons name="information" size={20} color={colors.white} />
        ) : (
          <View style={styles.crossIcon}>
            <View style={[styles.crossLine, styles.crossLine1, { backgroundColor: colors.text }]} />
            <View style={[styles.crossLine, styles.crossLine2, { backgroundColor: colors.text }]} />
          </View>
        )}
      </View>

      <View style={styles.messageContainer}>
        <CustomText
          variant="body"
          fontWeight="regular"
          color={colors.text}
          style={styles.message}
        >
          {message}
        </CustomText>
      </View>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    top: 60, // Below status bar
    left: 16,
    right: 16,
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 12,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
    zIndex: 9999,
  },
  iconContainer: {
    width: 32,
    height: 32,
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  crossIcon: {
    width: 20,
    height: 20,
    position: 'relative',
    justifyContent: 'center',
    alignItems: 'center',
  },
  crossLine: {
    position: 'absolute',
    width: 14,
    height: 2,
    borderRadius: 1,
  },
  crossLine1: {
    transform: [{ rotate: '45deg' }],
  },
  crossLine2: {
    transform: [{ rotate: '-45deg' }],
  },
  messageContainer: {
    flex: 1,
  },
  message: {
    lineHeight: 20,
  },
});
</file>

<file path="components/CustomDrawerContent.tsx">
import { Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useTheme } from '@/contexts/ThemeContext';
import { Ionicons } from '@expo/vector-icons';
import { DrawerContentComponentProps, DrawerContentScrollView, DrawerItem } from '@react-navigation/drawer';
import React from 'react';
import { StyleSheet, TouchableOpacity, View } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

const CustomDrawerContent: React.FC<DrawerContentComponentProps> = (props) => {
    const { colors, toggleTheme, isDark } = useTheme();
    const { user, signOut } = useAuth();
    const insets = useSafeAreaInsets();

    const handleSignOut = () => {
        props.navigation.closeDrawer();
        signOut();
    };

    const handleSettings = () => {
        props.navigation.closeDrawer();
        console.log('Navigate to Settings');
    };

    const handlePrivacy = () => {
        props.navigation.closeDrawer();
        console.log('Navigate to Privacy Policy');
    };

    const handleTerms = () => {
        props.navigation.closeDrawer();
        console.log('Navigate to Terms of Service');
    };

    const handleProfile = () => {
        props.navigation.closeDrawer();
        console.log('Navigate to Profile');
    };

    return (
        <View style={[styles.container, { backgroundColor: colors.background }]}>
            {/* Profil B√∂l√ºm√º */}
            <View
                style={[
                    styles.profileSection,
                    {
                        borderBottomColor: colors.stroke,
                        paddingTop: insets.top + 20,
                    }
                ]}
            >
                <View style={[styles.avatar, { backgroundColor: colors.forest }]}>
                    <Typography variant="h4" color={colors.white}>
                        {user?.display_name?.charAt(0).toUpperCase() || 'G'}
                    </Typography>
                </View>
                <View style={styles.profileInfo}>
                    <Typography variant="h5" color={colors.text} style={styles.profileName}>
                        {user?.display_name || 'Geliom User'}
                    </Typography>
                    <Typography variant="caption" color={colors.secondaryText}>
                        {user?.email || 'user@geliom.app'}
                    </Typography>
                    <TouchableOpacity
                        style={[styles.profileButton, { backgroundColor: colors.sage }]}
                        onPress={handleProfile}
                    >
                        <Typography variant="caption" color={colors.white}>
                            Profili G√∂r√ºnt√ºle
                        </Typography>
                    </TouchableOpacity>
                </View>
            </View>

            {/* Navigation Items */}
            <DrawerContentScrollView {...props} contentContainerStyle={styles.scrollContent}>
                <DrawerItem
                    label="Ana Sayfa"
                    onPress={() => props.navigation.navigate('home')}
                    icon={({ color, size }) => <Ionicons name="home" size={size} color={color} />}
                    labelStyle={[styles.drawerLabel, { color: colors.text }]}
                    focused={props.state.index === 0}
                    activeTintColor={colors.primary}
                    inactiveTintColor={colors.secondaryText}
                />

                <DrawerItem
                    label="Showroom"
                    onPress={() => props.navigation.navigate('showroom')}
                    icon={({ color, size }) => <Ionicons name="color-palette" size={size} color={color} />}
                    labelStyle={[styles.drawerLabel, { color: colors.text }]}
                    focused={props.state.index === 1}
                    activeTintColor={colors.primary}
                    inactiveTintColor={colors.secondaryText}
                />

                <DrawerItem
                    label="API Test"
                    onPress={() => props.navigation.navigate('api-test')}
                    icon={({ color, size }) => <Ionicons name="code-slash" size={size} color={color} />}
                    labelStyle={[styles.drawerLabel, { color: colors.text }]}
                    focused={props.state.index === 2}
                    activeTintColor={colors.primary}
                    inactiveTintColor={colors.secondaryText}
                />

                {/* Divider */}
                <View style={[styles.divider, { backgroundColor: colors.stroke }]} />

                {/* Settings Items */}
                <DrawerItem
                    label="Ayarlar"
                    onPress={handleSettings}
                    icon={({ color, size }) => <Ionicons name="settings" size={size} color={color} />}
                    labelStyle={[styles.drawerLabel, { color: colors.text }]}
                    activeTintColor={colors.primary}
                    inactiveTintColor={colors.secondaryText}
                />

                <DrawerItem
                    label={isDark ? "A√ßƒ±k Tema" : "Koyu Tema"}
                    onPress={toggleTheme}
                    icon={({ color, size }) => (
                        <Ionicons name={isDark ? "sunny" : "moon"} size={size} color={color} />
                    )}
                    labelStyle={[styles.drawerLabel, { color: colors.text }]}
                    activeTintColor={colors.primary}
                    inactiveTintColor={colors.secondaryText}
                />

                <DrawerItem
                    label="Gizlilik Politikasƒ±"
                    onPress={handlePrivacy}
                    icon={({ color, size }) => <Ionicons name="shield-checkmark" size={size} color={color} />}
                    labelStyle={[styles.drawerLabel, { color: colors.text }]}
                    activeTintColor={colors.primary}
                    inactiveTintColor={colors.secondaryText}
                />

                <DrawerItem
                    label="Kullanƒ±m ≈ûartlarƒ±"
                    onPress={handleTerms}
                    icon={({ color, size }) => <Ionicons name="document-text" size={size} color={color} />}
                    labelStyle={[styles.drawerLabel, { color: colors.text }]}
                    activeTintColor={colors.primary}
                    inactiveTintColor={colors.secondaryText}
                />

                <DrawerItem
                    label="Yardƒ±m & Destek"
                    onPress={() => {
                        props.navigation.closeDrawer();
                        console.log('Navigate to Help');
                    }}
                    icon={({ color, size }) => <Ionicons name="help-circle" size={size} color={color} />}
                    labelStyle={[styles.drawerLabel, { color: colors.text }]}
                    activeTintColor={colors.primary}
                    inactiveTintColor={colors.secondaryText}
                />
            </DrawerContentScrollView>

            {/* Alt B√∂l√ºm */}
            <View style={[styles.bottomSection, { paddingBottom: insets.bottom + 20 }]}>
                <DrawerItem
                    label="√áƒ±kƒ±≈ü Yap"
                    onPress={handleSignOut}
                    icon={({ color, size }) => <Ionicons name="log-out" size={size} color={color} />}
                    labelStyle={[styles.drawerLabel, { color: colors.error }]}
                    activeTintColor={colors.error}
                    inactiveTintColor={colors.error}
                />

                <View style={[styles.appInfo, { borderTopColor: colors.stroke }]}>
                    <Typography variant="caption" color={colors.secondaryText} style={styles.appVersion}>
                        Geliom v1.0.0
                    </Typography>
                    <Typography variant="caption" color={colors.secondaryText}>
                        üåø Doƒüa ile baƒülan
                    </Typography>
                </View>
            </View>
        </View>
    );
};

const styles = StyleSheet.create({
    container: {
        flex: 1,
    },
    profileSection: {
        flexDirection: 'row',
        alignItems: 'center',
        paddingHorizontal: 20,
        paddingBottom: 20,
        marginBottom: 20,
        borderBottomWidth: 1,
    },
    avatar: {
        width: 60,
        height: 60,
        borderRadius: 30,
        justifyContent: 'center',
        alignItems: 'center',
        marginRight: 16,
    },
    profileInfo: {
        flex: 1,
    },
    profileName: {
        marginBottom: 4,
    },
    profileButton: {
        paddingHorizontal: 12,
        paddingVertical: 6,
        borderRadius: 12,
        marginTop: 8,
        alignSelf: 'flex-start',
    },
    scrollContent: {
        paddingTop: 0,
    },
    drawerLabel: {
        fontFamily: 'Comfortaa-Medium',
        fontSize: 16,
        marginLeft: -16,
    },
    divider: {
        height: 1,
        marginVertical: 10,
        marginHorizontal: 20,
    },
    bottomSection: {
        borderTopWidth: 1,
        borderTopColor: '#E0E0E0',
    },
    appInfo: {
        paddingHorizontal: 20,
        paddingTop: 16,
        borderTopWidth: 1,
        alignItems: 'center',
    },
    appVersion: {
        marginBottom: 4,
    },
});

export default CustomDrawerContent;
</file>

<file path="components/index.ts">
export { default as CustomDrawerContent } from './CustomDrawerContent';
export { default as KeyboardAwareView } from './KeyboardAwareView';
export { NotificationHandler } from './NotificationHandler';
</file>

<file path="constants/adapty.ts">
export const SUBSCRIPTION_PLACEMENT = "test_subscription";
</file>

<file path="contexts/BottomSheetContext.tsx">
import BottomSheet, { BottomSheetBackdrop, BottomSheetView } from '@gorhom/bottom-sheet';
import React, { createContext, ReactNode, useCallback, useContext, useMemo, useRef, useState } from 'react';
import { StyleSheet } from 'react-native';
import { useTheme } from './ThemeContext';

// Bottom Sheet Options Interface
export interface BottomSheetOptions {
    enablePanDownToClose?: boolean;
    enableOverlayTap?: boolean;
    snapPoints?: (string | number)[];
    index?: number;
    handleIndicatorStyle?: any;
    backgroundStyle?: any;
}

// Context Interface
interface BottomSheetContextValue {
    openBottomSheet: (content: ReactNode, options?: BottomSheetOptions) => void;
    closeBottomSheet: () => void;
    snapToIndex: (index: number) => void;
    isOpen: boolean;
}

// Create Context
const BottomSheetContext = createContext<BottomSheetContextValue | undefined>(undefined);

// Provider Props
interface BottomSheetProviderProps {
    children: ReactNode;
}

export const BottomSheetProvider: React.FC<BottomSheetProviderProps> = ({ children }) => {
    const { colors } = useTheme();
    const bottomSheetRef = useRef<BottomSheet>(null);
    const [content, setContent] = useState<ReactNode>(null);
    const [isOpen, setIsOpen] = useState(false);
    const [options, setOptions] = useState<BottomSheetOptions>({
        enablePanDownToClose: true,
        enableOverlayTap: true,
        snapPoints: ['50%'],
        index: 0,
    });

    // Default snap points - dynamic sizing i√ßin CONTENT_HEIGHT kullanƒ±lacak
    const snapPoints = useMemo(() => options.snapPoints || ['60%'], [options.snapPoints]);

    // Open Bottom Sheet - Direkt content kabul ediyor
    const openBottomSheet = useCallback((newContent: ReactNode, newOptions?: BottomSheetOptions) => {
        setOptions({
            enablePanDownToClose: newOptions?.enablePanDownToClose ?? true,
            enableOverlayTap: newOptions?.enableOverlayTap ?? true,
            snapPoints: newOptions?.snapPoints || ['60%'],
            index: newOptions?.index ?? 0,
            handleIndicatorStyle: newOptions?.handleIndicatorStyle,
            backgroundStyle: newOptions?.backgroundStyle,
        });
        
        setContent(newContent);
        setIsOpen(true);
        bottomSheetRef.current?.snapToIndex(newOptions?.index ?? 0);
    }, []);

    // Close Bottom Sheet
    const closeBottomSheet = useCallback(() => {
        bottomSheetRef.current?.close();
        setIsOpen(false);
        // Animasyon bitene kadar i√ßeriƒüi temizleme
        setTimeout(() => setContent(null), 300);
    }, []);

    const snapToIndex = useCallback((index: number) => {
        bottomSheetRef.current?.snapToIndex(index);
    }, []);

    // Render backdrop
    const renderBackdrop = useCallback(
        (props: any) => {
            // Android'de backdrop touch event'leri blokluyor
            // Sadece bottom sheet a√ßƒ±ksa (index >= 0) backdrop g√∂ster
            if (props.animatedIndex?.value < 0) {
                return null;
            }
            return (
                <BottomSheetBackdrop
                    {...props}
                    disappearsOnIndex={-1}
                    appearsOnIndex={0}
                    opacity={0.5}
                    pressBehavior={options.enableOverlayTap ? 'close' : 'none'}
                />
            );
        },
        [options.enableOverlayTap]
    );

    // Context value
    const value = useMemo(
        () => ({
            openBottomSheet,
            closeBottomSheet,
            snapToIndex,
            isOpen,
        }),
        [openBottomSheet, closeBottomSheet, isOpen, snapToIndex]
    );

    return (
        <BottomSheetContext.Provider value={value}>
            {children}
            <BottomSheet
                ref={bottomSheetRef}
                index={-1}
                snapPoints={snapPoints}
                enablePanDownToClose={options.enablePanDownToClose}
                backdropComponent={renderBackdrop}
                handleIndicatorStyle={[
                    styles.handleIndicator,
                    { backgroundColor: colors.secondaryText },
                    options.handleIndicatorStyle,
                ]}
                backgroundStyle={[
                    { backgroundColor: colors.background },
                    options.backgroundStyle,
                ]}
                keyboardBehavior="extend"
                keyboardBlurBehavior="restore"
                android_keyboardInputMode="adjustResize"
                animateOnMount={false}
                onChange={(index) => {
                    if (index === -1) {
                        setIsOpen(false);
                        setTimeout(() => setContent(null), 300);
                    }
                }}
            >
                <BottomSheetView style={styles.contentContainer}>
                    {content}
                </BottomSheetView>
            </BottomSheet>
        </BottomSheetContext.Provider>
    );
};

// Custom Hook
export const useBottomSheet = (): BottomSheetContextValue => {
    const context = useContext(BottomSheetContext);
    if (!context) {
        throw new Error('useBottomSheet must be used within a BottomSheetProvider');
    }
    return context;
};

const styles = StyleSheet.create({
    handleIndicator: {
        width: 40,
        height: 4,
        borderRadius: 2,
    },
    contentContainer: {
        flex: 1,
        paddingHorizontal: 16,
        paddingBottom: 24,
    },
});
</file>

<file path="contexts/GroupContext.tsx">
import { useUserGroups } from '@/api/groups';
import { useAuth } from '@/contexts/AuthContext';
import type { GroupWithOwner } from '@/types/database';
import AsyncStorage from '@react-native-async-storage/async-storage';
import React, { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react';

const SELECTED_GROUP_STORAGE_KEY = '@geliom:selected_group_id';

interface GroupContextValue {
  selectedGroup: GroupWithOwner | null;
  setSelectedGroup: (group: GroupWithOwner | null) => Promise<void>;
  isLoading: boolean;
  groups: GroupWithOwner[];
}

const GroupContext = createContext<GroupContextValue>({
  selectedGroup: null,
  setSelectedGroup: async () => {},
  isLoading: true,
  groups: [],
});

export function GroupProvider({ children }: { children: React.ReactNode }) {
  const { user } = useAuth();
  const [selectedGroup, setSelectedGroupState] = useState<GroupWithOwner | null>(null);

  // Kullanƒ±cƒ±nƒ±n t√ºm gruplarƒ±nƒ± fetch et
  const { data: groups = [], isLoading: groupsLoading, error: groupsError } = useUserGroups(user?.id || '');

  // AsyncStorage'dan se√ßili grup ID'sini y√ºkle (sadece bir kez, gruplar y√ºklendiƒüinde)
  useEffect(() => {
    const loadSelectedGroup = async () => {
      if (!user?.id || groupsLoading) return;

      try {
        const storedGroupId = await AsyncStorage.getItem(SELECTED_GROUP_STORAGE_KEY);
        
        if (storedGroupId && groups.length > 0) {
          const group = groups.find(g => g.id === storedGroupId);
          if (group) {
            setSelectedGroupState(group);
            return;
          }
        }

        // Eƒüer stored group bulunamadƒ±ysa veya yoksa, ilk grubu se√ß
        if (groups.length > 0 && !selectedGroup) {
          const firstGroup = groups[0];
          setSelectedGroupState(firstGroup);
          await AsyncStorage.setItem(SELECTED_GROUP_STORAGE_KEY, firstGroup.id);
        }
      } catch (error) {
        console.error('Error loading selected group:', error);
      }
    };

    loadSelectedGroup();
  }, [user?.id, groups, groupsLoading, selectedGroup]);

  // Se√ßili grubu set et ve AsyncStorage'a kaydet
  const setSelectedGroup = useCallback(async (group: GroupWithOwner | null) => {
    try {
      setSelectedGroupState(group);
      if (group) {
        await AsyncStorage.setItem(SELECTED_GROUP_STORAGE_KEY, group.id);
      } else {
        await AsyncStorage.removeItem(SELECTED_GROUP_STORAGE_KEY);
      }
    } catch (error) {
      console.error('Error saving selected group:', error);
    }
  }, []);

  // Gruplar deƒüi≈ütiƒüinde, se√ßili grup hala ge√ßerli mi kontrol et
  useEffect(() => {
    if (selectedGroup && groups.length > 0) {
      const isStillValid = groups.some(g => g.id === selectedGroup.id);
      if (!isStillValid) {
        // Se√ßili grup artƒ±k ge√ßerli deƒüilse, ilk grubu se√ß
        if (groups.length > 0) {
          setSelectedGroup(groups[0]);
        } else {
          setSelectedGroup(null);
        }
      }
    } else if (!selectedGroup && groups.length > 0) {
      // Eƒüer se√ßili grup yoksa ama gruplar varsa, ilkini se√ß
      setSelectedGroup(groups[0]);
    }
  }, [groups, selectedGroup, setSelectedGroup]);

  // Context value'yu memoize et - groups array referansƒ± deƒüi≈ütiƒüinde g√ºncellenir
  // structuralSharing: false sayesinde her zaman yeni array referansƒ± gelir
  const value: GroupContextValue = useMemo(() => {
    return {
      selectedGroup,
      setSelectedGroup,
      isLoading: groupsLoading,
      groups,
    };
  }, [selectedGroup, setSelectedGroup, groupsLoading, groups]);

  return <GroupContext.Provider value={value}>{children}</GroupContext.Provider>;
}

export const useGroupContext = (): GroupContextValue => {
  const context = useContext(GroupContext);
  if (!context) {
    throw new Error('useGroupContext must be used within a GroupProvider');
  }
  
  return context;
};
</file>

<file path="contexts/NetworkToastContext.tsx">
import NetworkToast, { NetworkToastType } from "@/components/ui/NetworkToast";
import { useNetworkStatus } from "@/hooks/useNetworkStatus";
import React, { createContext, useContext, useState } from "react";

interface ToastState {
  visible: boolean;
  type: NetworkToastType;
  message: string;
}

interface NetworkToastContextType {
  showWeakConnectionToast: (message?: string) => void;
  showOfflineToast: (message?: string) => void;
  hideToast: () => void;
  checkAndShowToast: () => Promise<boolean>; // Returns true if connection is OK
}

const NetworkToastContext = createContext<NetworkToastContextType | undefined>(undefined);

const DEFAULT_MESSAGES = {
  weak: "Face not recognized in the photo. Please upload a clearer photo.",
  offline: "No social media profile found for this person. Please try another photo.",
};

export function NetworkToastProvider({ children }: { children: React.ReactNode }) {
  const [toastState, setToastState] = useState<ToastState>({
    visible: false,
    type: 'weak',
    message: '',
  });
  const { checkConnection } = useNetworkStatus();

  const showWeakConnectionToast = (message?: string) => {
    setToastState({
      visible: true,
      type: 'weak',
      message: message || DEFAULT_MESSAGES.weak,
    });
  };

  const showOfflineToast = (message?: string) => {
    setToastState({
      visible: true,
      type: 'offline',
      message: message || DEFAULT_MESSAGES.offline,
    });
  };

  const hideToast = () => {
    setToastState((prev) => ({ ...prev, visible: false }));
  };

  const checkAndShowToast = async (): Promise<boolean> => {
    const status = await checkConnection();

    if (status === 'offline') {
      showOfflineToast();
      return false;
    }

    if (status === 'weak') {
      showWeakConnectionToast();
      return false;
    }

    return true;
  };

  return (
    <NetworkToastContext.Provider
      value={{
        showWeakConnectionToast,
        showOfflineToast,
        hideToast,
        checkAndShowToast,
      }}
    >
      {children}
      <NetworkToast
        type={toastState.type}
        message={toastState.message}
        visible={toastState.visible}
        onHide={hideToast}
        duration={3000}
      />
    </NetworkToastContext.Provider>
  );
}

export function useNetworkToast() {
  const context = useContext(NetworkToastContext);
  if (!context) {
    throw new Error('useNetworkToast must be used within NetworkToastProvider');
  }
  return context;
}
</file>

<file path="contexts/PayContext.tsx">
import { SUBSCRIPTION_PLACEMENT } from '@/constants/adapty';
import { createContext, useContext, useEffect, useRef, useState } from 'react';
import { Linking } from 'react-native';
import { AdaptyPaywall, AdaptyProfile, adapty } from 'react-native-adapty';
import { createPaywallView } from 'react-native-adapty/dist/ui';


// Yeni aray√ºzler ve tipler
interface ShowPaywallOptions {
    placementId?: string;
    condition?: () => Promise<boolean>;
    onSuccess?: (purchase: any) => void;
    onFailure?: (error: Error) => void;
    onClose?: () => void;
    onPresent?: (paywall: AdaptyPaywall) => void;
    trackingContext?: Record<string, any>;
}

interface PayContextType {
    isSubscribed: boolean;
    loading: boolean;
    error: Error | null;
    isReady: boolean;
    checkSubscription: () => Promise<void>;
    showPaywall: (options: ShowPaywallOptions) => Promise<void>;
    reStorePurchases: () => Promise<void>;
}

const PayContext = createContext<PayContextType | undefined>(undefined);

const PayProvider = ({ children }: { children: React.ReactNode }) => {
    const [isSubscribed, setIsSubscribed] = useState<boolean>(false);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<Error | null>(null);
    const [isReady, setIsReady] = useState<boolean>(false);

    // Paywall view'ƒ± i√ßin ref'i tutuyoruz, sadece bir tane aktif olabilir.
    const paywallViewRef = useRef<any | null>(null);

    // Adapty'nin ba≈ülatƒ±lmasƒ±nƒ± bekle
    useEffect(() => {
        const initializeAdapty = async () => {
            try {
                // Adapty'nin hazƒ±r olmasƒ±nƒ± bekle
                await new Promise(resolve => setTimeout(resolve, 1000));
                setIsReady(true);
            } catch (err) {
                console.error('Adapty initialization error:', err);
                setIsReady(true); // Hata durumunda da devam et
            }
        };

        initializeAdapty();
    }, []);

    const checkSubscription = async () => {
        if (!isReady) return;
        setLoading(true);
        try {
            const profile: AdaptyProfile = await adapty.getProfile();
            const hasActiveSubscription = Object.values(profile.accessLevels || {}).some(level => level.isActive);
            setIsSubscribed(hasActiveSubscription);
        } catch (err) {
            setError(err instanceof Error ? err : new Error('Unknown error checking subscription'));
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        if (isReady) {
            checkSubscription();
        }
    }, [isReady]);

    const showPaywall = async (options: ShowPaywallOptions) => {
        const {
            placementId = SUBSCRIPTION_PLACEMENT,
            condition,
            onSuccess,
            onFailure,
            onClose,
            onPresent,
            trackingContext = {}
        } = options;
        if (condition && !(await condition())) {
            return;
        }
        setLoading(true);
        setError(null);
        try {
            const paywall = await adapty.getPaywall(placementId);
            const view = await createPaywallView(paywall);
            paywallViewRef.current = view;

            // 3. Olay dinleyicilerini (event handlers) ayarla
            view.registerEventHandlers({
                onPurchaseCompleted: (purchase: any) => {
                    if (purchase?.profile?.accessLevels?.['premium']?.isActive) {
                        setIsSubscribed(true);
                        onSuccess?.(purchase);
                    } else {
                        // Satƒ±n alma ba≈üarƒ±lƒ± ama yetki gelmedi durumu
                        onFailure?.(new Error('Purchase succeeded but no access level was granted.'));
                    }
                    view.dismiss();
                },
                onPurchaseFailed: (err) => {
                    setError(err);
                    onFailure?.(err);
                    view.dismiss();
                },
                onPaywallClosed: () => {
                    onClose?.();
                },
                onUrlPress: (url) => {
                    Linking.openURL(url);
                    return false; // Paywall'u a√ßƒ±k tut
                }
            });

            // 4. Paywall'u g√∂ster
            await view.present();
            setLoading(false);
            onPresent?.(paywall);

        } catch (err: any) {
            console.error('err paywall4', err);
            setError(err);
            setLoading(false);
            onFailure?.(err);
        }
    };

    const reStorePurchases = async (): Promise<void> => {
        setLoading(true);
        try {
            await adapty.restorePurchases();
            await checkSubscription();
        } catch (err) {
            setError(err instanceof Error ? err : new Error('Unknown error during restore'));
        } finally {
            setLoading(false);
        }
    };

    const value = {
        isSubscribed,
        loading,
        error,
        isReady,
        checkSubscription,
        showPaywall,
        reStorePurchases
    };

    return <PayContext.Provider value={value}>{children}</PayContext.Provider>;
};

const usePay = () => {
    const context = useContext(PayContext);
    if (context === undefined) {
        throw new Error('usePay must be used within a PayProvider');
    }
    return context;
};

export { usePay };
export default PayProvider;
</file>

<file path="contexts/ThemeContext.tsx">
import AsyncStorage from '@react-native-async-storage/async-storage';
import React, { createContext, useContext, useEffect, useState } from 'react';
import { useColorScheme } from 'react-native';
import { darkColors, lightColors } from '../theme/colors';

// 1. Context'i olu≈ütur
export const ThemeContext = createContext({
  isDark: false,
  colors: lightColors,
  toggleTheme: () => {},
});

// 2. Provider component'ini olu≈ütur
export const ThemeProvider = ({ children }: { children: React.ReactNode }) => {
  // Cihazƒ±n temasƒ±nƒ± al
  const colorScheme = useColorScheme(); 
  
  // State'i tanƒ±mla. Ba≈ülangƒ±√ßta cihazƒ±n temasƒ±na g√∂re ayarla.
  const [isDark, setIsDark] = useState(colorScheme === 'dark');

  // Tema deƒüi≈ütiƒüinde √ßalƒ±≈üacak olan effect
  useEffect(() => {
    // Kullanƒ±cƒ±nƒ±n daha √∂nce kaydettiƒüi bir tercih var mƒ± diye kontrol et
    const loadTheme = async () => {
      try {
        const savedTheme = await AsyncStorage.getItem('theme');
        if (savedTheme !== null) {
          setIsDark(savedTheme === 'dark');
        }
      } catch (error) {
        console.error("Failed to load theme from storage", error);
      }
    };

    loadTheme();
  }, []);

  // Temayƒ± deƒüi≈ütiren fonksiyon
  const toggleTheme = async () => {
    const newIsDark = !isDark;
    setIsDark(newIsDark);
    try {
      await AsyncStorage.setItem('theme', newIsDark ? 'dark' : 'light');
    } catch (error) {
      console.error("Failed to save theme to storage", error);
    }
  };

  // Mevcut temaya g√∂re doƒüru renk paletini se√ß
  const themeColors = isDark ? darkColors : lightColors;

  return (
    <ThemeContext.Provider value={{ isDark, colors: themeColors, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

// 3. Kolay kullanƒ±m i√ßin custom hook olu≈ütur
export const useTheme = () => useContext(ThemeContext);
</file>

<file path="docs/BaseLayout-usage.md">
# BaseLayout Kullanƒ±m Kƒ±lavuzu

BaseLayout component'i, t√ºm sayfalarda kullanabileceƒüiniz esnek ve performanslƒ± bir layout sistemidir.

## Temel Kullanƒ±m

```tsx
import { BaseLayout } from '@/components/shared';

export default function MyPage() {
  return (
    <BaseLayout>
      <Text>ƒ∞√ßerik buraya gelir</Text>
    </BaseLayout>
  );
}
```

## √ñzellikler

### 1. Header G√∂sterimi
```tsx
// Header'ƒ± gizle
<BaseLayout headerShow={false}>
  <Text>Header yok</Text>
</BaseLayout>

// Header'ƒ± g√∂ster (default: true)
<BaseLayout headerShow={true}>
  <Text>Header var</Text>
</BaseLayout>
```

### 2. Full Screen Modu
```tsx
// Tam ekran - Safe area yok
<BaseLayout fullScreen={true}>
  <Text>Tam ekran i√ßerik</Text>
</BaseLayout>

// Normal mod - Safe area var (default)
<BaseLayout fullScreen={false}>
  <Text>Safe area ile i√ßerik</Text>
</BaseLayout>
```

### 3. Header Konfig√ºrasyonu

#### Sol Icon + Title + Saƒü Icon
```tsx
<BaseLayout
  header={{
    leftIcon: {
      icon: <Ionicons name="menu" size={24} color={colors.text} />,
      onPress: () => console.log('Menu'),
    },
    title: <Text style={{ color: colors.text }}>Sayfa Ba≈ülƒ±ƒüƒ±</Text>,
    rightIcon: {
      icon: <Ionicons name="settings" size={24} color={colors.text} />,
      onPress: () => console.log('Settings'),
    },
  }}
>
  <Text>ƒ∞√ßerik</Text>
</BaseLayout>
```

#### Sadece Title
```tsx
<BaseLayout
  header={{
    title: <Text style={{ color: colors.text }}>Sadece Ba≈ülƒ±k</Text>,
  }}
>
  <Text>ƒ∞√ßerik</Text>
</BaseLayout>
```

#### Sadece Sol Icon
```tsx
<BaseLayout
  header={{
    leftIcon: {
      icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
      onPress: () => router.back(),
    },
  }}
>
  <Text>ƒ∞√ßerik</Text>
</BaseLayout>
```

### 4. Background Image
```tsx
<BaseLayout
  backgroundImage={require('@/assets/images/background.jpg')}
>
  <Text>Background image ile</Text>
</BaseLayout>
```

### 5. Custom Background Color
```tsx
<BaseLayout
  backgroundColor="#FF0000"
>
  <Text>Kƒ±rmƒ±zƒ± arkaplan</Text>
</BaseLayout>
```

### 6. Custom Styles
```tsx
<BaseLayout
  style={{ padding: 20 }}
  contentStyle={{ backgroundColor: 'rgba(0,0,0,0.5)' }}
>
  <Text>Custom style'lar</Text>
</BaseLayout>
```

### 7. Header Customization
```tsx
<BaseLayout
  header={{
    leftIcon: {
      icon: <Ionicons name="menu" size={24} color={colors.text} />,
      onPress: openMenu,
    },
    title: <Text>Ba≈ülƒ±k</Text>,
    backgroundColor: colors.primary,
    height: 60,
    style: { borderBottomWidth: 1, borderBottomColor: colors.stroke },
  }}
>
  <Text>ƒ∞√ßerik</Text>
</BaseLayout>
```

## Kompleks √ñrnek

```tsx
import { BaseLayout } from '@/components/shared';
import { useTheme } from '@/contexts/ThemeContext';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';

export default function ProfilePage() {
  const { colors, toggleTheme, isDark } = useTheme();

  return (
    <BaseLayout
      headerShow={true}
      header={{
        leftIcon: {
          icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
          onPress: () => router.back(),
        },
        title: (
          <Text style={{ 
            color: colors.text, 
            fontSize: 18, 
            fontWeight: 'bold' 
          }}>
            Profil
          </Text>
        ),
        rightIcon: {
          icon: <Ionicons name={isDark ? "sunny" : "moon"} size={24} color={colors.text} />,
          onPress: toggleTheme,
        },
        backgroundColor: colors.background,
      }}
      style={{ backgroundColor: colors.background }}
    >
      <ScrollView style={{ flex: 1, padding: 16 }}>
        <Text style={{ color: colors.text }}>Profil i√ßeriƒüi...</Text>
      </ScrollView>
    </BaseLayout>
  );
}
```

## Performans Notlarƒ±

- Component memoized deƒüil, gerekirse `React.memo` ile sarmalayƒ±n
- Header icon'larƒ± TouchableOpacity ile optimize edilmi≈ü
- Status bar otomatik tema rengine g√∂re ayarlanƒ±r
- Safe area insets otomatik hesaplanƒ±r
- Background image lazy load deƒüil, gerekirse optimize edin

## Props Referansƒ±

| Prop | Tip | Default | A√ßƒ±klama |
|------|-----|---------|----------|
| `children` | ReactNode | - | Sayfa i√ßeriƒüi |
| `fullScreen` | boolean | false | Tam ekran modu |
| `headerShow` | boolean | true | Header g√∂sterimi |
| `header` | HeaderProps | - | Header konfig√ºrasyonu |
| `backgroundImage` | any | - | Arkaplan resmi |
| `backgroundColor` | string | theme.colors.background | Arkaplan rengi |
| `style` | ViewStyle | - | Container style |
| `contentStyle` | ViewStyle | - | ƒ∞√ßerik style |

### HeaderProps

| Prop | Tip | Default | A√ßƒ±klama |
|------|-----|---------|----------|
| `leftIcon` | HeaderIconProps | - | Sol icon |
| `rightIcon` | HeaderIconProps | - | Saƒü icon |
| `title` | ReactNode | - | Ba≈ülƒ±k |
| `backgroundColor` | string | theme.colors.background | Header arkaplan |
| `height` | number | 56 | Header y√ºksekliƒüi |
| `style` | ViewStyle | - | Header style |

### HeaderIconProps

| Prop | Tip | Default | A√ßƒ±klama |
|------|-----|---------|----------|
| `icon` | ReactNode | - | Icon component |
| `onPress` | () => void | - | Tƒ±klama fonksiyonu |
</file>

<file path="docs/Component-Showroom.md">
# Geliom - Component Showroom

Geliom uygulamasƒ±nƒ±n component'lerinin sergilendiƒüi ve test edildiƒüi alan.

## üé® Showroom Yapƒ±sƒ±

### Eri≈üim
- Ana sayfadan "üé® Component Showroom" butonuna tƒ±klayarak eri≈üilebilir
- Route: `/(app)/showroom`
- Header ile navigation ve theme toggle

### Ama√ß
- Component'leri g√∂rsel olarak test etmek
- Farklƒ± variant'larƒ± kar≈üƒ±la≈ütƒ±rmak
- Development s√ºrecinde hƒ±zlƒ± prototype
- Design system dok√ºmantasyonu

## üîò BlurButton Component

### 12 Farklƒ± Variant

#### 1. Primary - Gradient Ye≈üil
```tsx
<BlurButton variant="primary">1. Primary</BlurButton>
```
- **G√∂r√ºn√ºm**: Ye≈üil gradient (primary ‚Üí secondary)
- **Kullanƒ±m**: Ana CTA butonlarƒ±
- **√ñzellik**: LinearGradient ile blur efekti

#### 2. Secondary - D√ºz Ye≈üil
```tsx
<BlurButton variant="secondary">2. Secondary</BlurButton>
```
- **G√∂r√ºn√ºm**: D√ºz secondary ye≈üil
- **Kullanƒ±m**: ƒ∞kincil aksiyonlar
- **√ñzellik**: Solid background

#### 3. Tertiary - A√ßƒ±k Ye≈üil
```tsx
<BlurButton variant="tertiary">3. Tertiary</BlurButton>
```
- **G√∂r√ºn√ºm**: A√ßƒ±k ye≈üil ton
- **Kullanƒ±m**: √ú√ß√ºnc√ºl aksiyonlar
- **√ñzellik**: Soft appearance

#### 4. Success - Ba≈üarƒ± Ye≈üili
```tsx
<BlurButton variant="success">4. Success</BlurButton>
```
- **G√∂r√ºn√ºm**: Ba≈üarƒ± ye≈üili
- **Kullanƒ±m**: Onay, ba≈üarƒ± mesajlarƒ±
- **√ñzellik**: Positive feedback

#### 5. Glass - Cam Efekti
```tsx
<BlurButton variant="glass">5. Glass</BlurButton>
```
- **G√∂r√ºn√ºm**: ≈ûeffaf cam efekti
- **Kullanƒ±m**: Overlay butonlarƒ±
- **√ñzellik**: BlurView ile glassmorphism

#### 6. Outline - √áer√ßeveli
```tsx
<BlurButton variant="outline">6. Outline</BlurButton>
```
- **G√∂r√ºn√ºm**: ≈ûeffaf arkaplan, ye≈üil √ßer√ßeve
- **Kullanƒ±m**: ƒ∞kincil aksiyonlar
- **√ñzellik**: Minimal appearance

#### 7. Ghost - Hayalet
```tsx
<BlurButton variant="ghost">7. Ghost</BlurButton>
```
- **G√∂r√ºn√ºm**: ≈ûeffaf ye≈üil arkaplan
- **Kullanƒ±m**: Subtle aksiyonlar
- **√ñzellik**: %20 opacity background

#### 8. Danger - Hata/Silme
```tsx
<BlurButton variant="danger">8. Danger</BlurButton>
```
- **G√∂r√ºn√ºm**: Kƒ±rmƒ±zƒ± arkaplan
- **Kullanƒ±m**: Silme, iptal aksiyonlarƒ±
- **√ñzellik**: Warning appearance

#### 9. Forest - Orman Ye≈üili
```tsx
<BlurButton variant="forest">9. Forest</BlurButton>
```
- **G√∂r√ºn√ºm**: Koyu orman ye≈üili (#1B5E20)
- **Kullanƒ±m**: Doƒüa temalƒ± aksiyonlar
- **√ñzellik**: Deep green tone

#### 10. Mint - Nane Ye≈üili
```tsx
<BlurButton variant="mint">10. Mint</BlurButton>
```
- **G√∂r√ºn√ºm**: Parlak nane ye≈üili (#00E676)
- **Kullanƒ±m**: Fresh, energetic aksiyonlar
- **√ñzellik**: Bright vibrant green

#### 11. Lime - Limon Ye≈üili
```tsx
<BlurButton variant="lime">11. Lime</BlurButton>
```
- **G√∂r√ºn√ºm**: Limon ye≈üili (#8BC34A)
- **Kullanƒ±m**: Playful, friendly aksiyonlar
- **√ñzellik**: Light green tone

#### 12. Emerald - Z√ºmr√ºt Ye≈üili
```tsx
<BlurButton variant="emerald">12. Emerald</BlurButton>
```
- **G√∂r√ºn√ºm**: Z√ºmr√ºt ye≈üili (#009688)
- **Kullanƒ±m**: Premium, elegant aksiyonlar
- **√ñzellik**: Sophisticated green

### 3 Farklƒ± Boyut

#### Small - K√º√ß√ºk
```tsx
<BlurButton size="small">Small</BlurButton>
```
- **Boyut**: 36px min height
- **Padding**: 16px horizontal, 8px vertical
- **Font**: Caption size

#### Medium - Orta (Default)
```tsx
<BlurButton size="medium">Medium</BlurButton>
```
- **Boyut**: 44px min height
- **Padding**: 20px horizontal, 12px vertical
- **Font**: Button size

#### Large - B√ºy√ºk
```tsx
<BlurButton size="large">Large</BlurButton>
```
- **Boyut**: 52px min height
- **Padding**: 24px horizontal, 16px vertical
- **Font**: H6 size

### 5 Farklƒ± Radius

#### None - K√∂≈üesiz
```tsx
<BlurButton radius="none">Radius: None</BlurButton>
```
- **Radius**: 0px
- **G√∂r√ºn√ºm**: Keskin k√∂≈üeler
- **Kullanƒ±m**: Modern, geometric tasarƒ±m

#### Small - K√º√ß√ºk
```tsx
<BlurButton radius="small">Radius: Small</BlurButton>
```
- **Radius**: 6px
- **G√∂r√ºn√ºm**: Hafif yuvarlaklƒ±k
- **Kullanƒ±m**: Subtle rounded corners

#### Medium - Orta (Default)
```tsx
<BlurButton radius="medium">Radius: Medium</BlurButton>
```
- **Radius**: 12px
- **G√∂r√ºn√ºm**: Standart yuvarlaklƒ±k
- **Kullanƒ±m**: Balanced appearance

#### Large - B√ºy√ºk
```tsx
<BlurButton radius="large">Radius: Large</BlurButton>
```
- **Radius**: 20px
- **G√∂r√ºn√ºm**: Belirgin yuvarlaklƒ±k
- **Kullanƒ±m**: Soft, friendly appearance

#### Full - Tam Yuvarlak
```tsx
<BlurButton radius="full">Radius: Full</BlurButton>
```
- **Radius**: 9999px (pill shape)
- **G√∂r√ºn√ºm**: Tam yuvarlak kenarlar
- **Kullanƒ±m**: Pill buttons, tags

### Icon Desteƒüi

#### Sol Icon
```tsx
<BlurButton 
  variant="primary" 
  icon={<Ionicons name="heart" size={20} color="white" />}
  iconPosition="left"
>
  Beƒüen
</BlurButton>
```

#### Saƒü Icon
```tsx
<BlurButton 
  variant="secondary" 
  icon={<Ionicons name="share" size={20} color="white" />}
  iconPosition="right"
>
  Payla≈ü
</BlurButton>
```

### √ñzel √ñzellikler

#### Full Width
```tsx
<BlurButton variant="primary" fullWidth>
  Tam Geni≈ülik Button
</BlurButton>
```

#### Disabled State
```tsx
<BlurButton variant="primary" disabled>
  Disabled
</BlurButton>
```

#### Loading State
```tsx
<BlurButton variant="secondary" loading>
  Loading
</BlurButton>
```

## üéØ Geliom'a √ñzel Tasarƒ±m

### Doƒüa Temalƒ± Renkler
- T√ºm variant'lar ye≈üil tonlarda
- Doƒüal gradient ge√ßi≈üleri
- Tema uyumlu renk paleti

### Blur Effects
- Glass variant'ta BlurView kullanƒ±mƒ±
- Modern glassmorphism tasarƒ±mƒ±
- iOS/Android uyumlu blur

### Typography Integration
- Comfortaa font ailesi
- Responsive font boyutlarƒ±
- Typography system entegrasyonu

### Shadow & Elevation
- Platform-specific shadow
- Depth hierarchy
- Visual feedback

## üì± Kullanƒ±m √ñrnekleri

### Ana Sayfa CTA
```tsx
<BlurButton variant="primary" size="large" fullWidth>
  Gruplarƒ±m üë•
</BlurButton>
```

### Navigation Button
```tsx
<BlurButton 
  variant="glass" 
  icon={<Ionicons name="settings" size={20} />}
  iconPosition="left"
>
  Ayarlar
</BlurButton>
```

### Action Buttons
```tsx
<BlurButton variant="success" size="small">
  Onayla
</BlurButton>

<BlurButton variant="danger" size="small">
  Sil
</BlurButton>
```

### Karƒ±≈üƒ±k √ñrnekler
```tsx
{/* Orman temalƒ± k√º√ß√ºk pill button */}
<BlurButton 
  variant="forest" 
  size="small" 
  radius="full"
  icon={<Ionicons name="leaf" size={16} color="white" />}
>
  Orman
</BlurButton>

{/* Nane temalƒ± b√ºy√ºk k√∂≈üesiz button */}
<BlurButton 
  variant="mint" 
  size="large" 
  radius="none"
  icon={<Ionicons name="flash" size={20} color="white" />}
  iconPosition="right"
>
  Nane
</BlurButton>

{/* Z√ºmr√ºt temalƒ± b√ºy√ºk radius button */}
<BlurButton 
  variant="emerald" 
  radius="large"
  icon={<Ionicons name="diamond" size={18} color="white" />}
>
  Z√ºmr√ºt
</BlurButton>
```

## üöÄ Performance

### Optimizasyonlar
- useCallback ile stable references
- Conditional rendering
- Platform-specific implementations
- Memory efficient blur effects

### Best Practices
- Variant se√ßimi kullanƒ±m amacƒ±na g√∂re
- Icon boyutlarƒ± button size'a uygun
- Loading state'lerde user feedback
- Accessibility considerations

Bu showroom Geliom'un component library'sinin temelini olu≈üturmaktadƒ±r. üåøüé®
</file>

<file path="docs/database-function-update.sql">
-- G√ºncellenmi≈ü Database Function
-- Bu function, auth.users tablosuna yeni kullanƒ±cƒ± eklendiƒüinde otomatik √ßalƒ±≈üƒ±r
-- custom_user_id, email ve diƒüer profil bilgilerini otomatik olu≈üturur

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  random_id TEXT;
  chars TEXT := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  i INTEGER;
  char_index INTEGER;
BEGIN
  -- Rastgele ve e≈üsiz bir custom_user_id olu≈ütur (tam 8 karakter)
  -- Sadece ƒ∞ngilizce harf (A-Z) ve sayƒ± (0-9) kullanƒ±lƒ±r
  LOOP
    -- 8 karakterlik random string olu≈ütur
    random_id := '';
    FOR i IN 1..8 LOOP
      -- Random bir index se√ß (0-35 arasƒ±: 26 harf + 10 sayƒ±)
      char_index := floor(random() * 36)::INTEGER;
      -- Index'e g√∂re karakteri al (1-based indexing i√ßin +1)
      random_id := random_id || substr(chars, char_index + 1, 1);
    END LOOP;
    
    -- Bu ID'nin ba≈üka bir kullanƒ±cƒ±da olmadƒ±ƒüƒ±ndan emin ol
    EXIT WHEN NOT EXISTS (SELECT 1 FROM public.users WHERE custom_user_id = random_id);
  END LOOP;

  -- `public.users` tablosuna yeni kullanƒ±cƒ±yƒ± ekle
  INSERT INTO public.users (
    id,
    custom_user_id,
    email,
    display_name,
    photo_url,
    show_mood
  )
  VALUES (
    new.id,
    random_id,
    new.email, -- auth.users'dan email al
    COALESCE(
      new.raw_user_meta_data->>'full_name',
      new.raw_user_meta_data->>'name',
      split_part(new.email, '@', 1) -- Email'den kullanƒ±cƒ± adƒ± √ßƒ±kar
    ),
    COALESCE(
      new.raw_user_meta_data->>'avatar_url',
      new.raw_user_meta_data->>'picture'
    ),
    false -- Varsayƒ±lan olarak mood g√∂sterimi kapalƒ±
  );

  -- `public.subscriptions` tablosuna varsayƒ±lan 'free' aboneliƒüi ekle
  INSERT INTO public.subscriptions (user_id, status)
  VALUES (new.id, 'free');

  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger'ƒ± olu≈ütur (eƒüer yoksa)
-- NOT: Trigger zaten varsa bu komut hataya sebep olmaz
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();
</file>

<file path="docs/database-migration-group-based-status-mood.sql">
-- Database Migration: Group-Based Status & Mood System
-- Bu migration, user_statuses ve moods sistemini grup bazlƒ± hale getirir

-- ============================================
-- 1. user_statuses Tablosu G√ºncellemesi
-- ============================================

-- √ñnce mevcut primary key constraint'i kaldƒ±r
ALTER TABLE public.user_statuses DROP CONSTRAINT IF EXISTS user_statuses_pkey;

-- group_id kolonu ekle (NULL olabilir - global status i√ßin)
ALTER TABLE public.user_statuses 
ADD COLUMN IF NOT EXISTS group_id UUID NULL;

-- Foreign key constraint ekle
ALTER TABLE public.user_statuses
ADD CONSTRAINT user_statuses_group_id_fkey 
FOREIGN KEY (group_id) REFERENCES public.groups(id) ON DELETE CASCADE;

-- Mevcut verileri group_id = NULL ile g√ºncelle (global status olarak)
UPDATE public.user_statuses 
SET group_id = NULL 
WHERE group_id IS NULL;

-- Yeni composite primary key olu≈ütur (user_id, group_id)
-- NOT: PostgreSQL'de NULL deƒüerler unique constraint'te farklƒ± davranƒ±r
-- Bu y√ºzden partial unique index kullanacaƒüƒ±z
ALTER TABLE public.user_statuses
ADD CONSTRAINT user_statuses_pkey PRIMARY KEY (user_id, group_id);

-- NULL group_id i√ßin unique constraint (bir kullanƒ±cƒ±nƒ±n tek global status'u olabilir)
CREATE UNIQUE INDEX IF NOT EXISTS user_statuses_user_id_null_group_unique 
ON public.user_statuses(user_id) 
WHERE group_id IS NULL;

-- Performance i√ßin index'ler
CREATE INDEX IF NOT EXISTS idx_user_statuses_group_id 
ON public.user_statuses(group_id);

CREATE INDEX IF NOT EXISTS idx_user_statuses_user_id_group_id 
ON public.user_statuses(user_id, group_id);

-- ============================================
-- 2. user_group_moods Tablosu Olu≈ütur
-- ============================================

CREATE TABLE IF NOT EXISTS public.user_group_moods (
  user_id UUID NOT NULL,
  group_id UUID NULL,
  mood_id INTEGER NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  CONSTRAINT user_group_moods_pkey PRIMARY KEY (user_id, group_id),
  CONSTRAINT user_group_moods_user_id_fkey 
    FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE,
  CONSTRAINT user_group_moods_group_id_fkey 
    FOREIGN KEY (group_id) REFERENCES public.groups(id) ON DELETE CASCADE,
  CONSTRAINT user_group_moods_mood_id_fkey 
    FOREIGN KEY (mood_id) REFERENCES public.moods(id) ON DELETE CASCADE
) TABLESPACE pg_default;

-- NULL group_id i√ßin unique constraint (bir kullanƒ±cƒ±nƒ±n tek global mood'u olabilir)
CREATE UNIQUE INDEX IF NOT EXISTS user_group_moods_user_id_null_group_unique 
ON public.user_group_moods(user_id) 
WHERE group_id IS NULL;

-- Performance i√ßin index'ler
CREATE INDEX IF NOT EXISTS idx_user_group_moods_group_id 
ON public.user_group_moods(group_id);

CREATE INDEX IF NOT EXISTS idx_user_group_moods_user_id_group_id 
ON public.user_group_moods(user_id, group_id);

CREATE INDEX IF NOT EXISTS idx_user_group_moods_mood_id 
ON public.user_group_moods(mood_id);

-- ============================================
-- 3. Mevcut users.mood_id Verilerini Migrate Et
-- ============================================

-- Mevcut users tablosundaki mood_id deƒüerlerini user_group_moods'a ta≈üƒ±
-- (sadece mood_id NULL olmayan kayƒ±tlar i√ßin)
INSERT INTO public.user_group_moods (user_id, group_id, mood_id, updated_at)
SELECT 
  id as user_id,
  NULL as group_id,  -- Global mood olarak
  mood_id,
  updated_at
FROM public.users
WHERE mood_id IS NOT NULL
ON CONFLICT (user_id, group_id) DO NOTHING;

-- ============================================
-- 4. RLS (Row Level Security) Policies
-- ============================================

-- user_statuses i√ßin RLS policy (eƒüer RLS aktifse)
-- Kullanƒ±cƒ±lar sadece kendi status'larƒ±nƒ± g√∂rebilir/g√ºncelleyebilir
-- Veya grup √ºyeleri grup status'larƒ±nƒ± g√∂rebilir

-- user_group_moods i√ßin RLS policy (eƒüer RLS aktifse)
-- Kullanƒ±cƒ±lar sadece kendi mood'larƒ±nƒ± g√∂rebilir/g√ºncelleyebilir
-- Veya grup √ºyeleri grup mood'larƒ±nƒ± g√∂rebilir

-- NOT: RLS policy'leri projenin g√ºvenlik gereksinimlerine g√∂re ayrƒ±ca eklenmelidir

-- ============================================
-- 5. Migration Tamamlandƒ±
-- ============================================

-- Migration sonrasƒ± kontrol sorgularƒ±:
-- SELECT COUNT(*) FROM public.user_statuses WHERE group_id IS NULL; -- Global status sayƒ±sƒ±
-- SELECT COUNT(*) FROM public.user_group_moods WHERE group_id IS NULL; -- Global mood sayƒ±sƒ±
-- SELECT COUNT(*) FROM public.user_group_moods; -- Toplam mood kaydƒ±
</file>

<file path="docs/GeliomButton-Documentation.md">
# GeliomButton - Ana Button Sistemi üåø

Geliom uygulamasƒ±nƒ±n ana button sistemi. Forest (Active), Sage (Passive), Pine (Loading) renklerini kullanarak ada√ßayƒ± tarzƒ± organik tasarƒ±m sunar.

## üé® Tasarƒ±m Felsefesi

GeliomButton, doƒüanƒ±n organik formlarƒ±ndan ilham alƒ±narak tasarlanmƒ±≈ütƒ±r. Ada√ßayƒ± yapraƒüƒ±nƒ±n yumu≈üak, organik ≈üekli button'larƒ±n radius ve padding sistemine yansƒ±tƒ±lmƒ±≈ütƒ±r.

### Renk Sistemi
- **üå≤ Forest (#1B5E20)** - Active State (9. numara)
- **üåæ Sage (#87A96B)** - Passive State (13. numara)  
- **üå≤ Pine (#01796F)** - Loading State (17. numara)

## üìê Ada√ßayƒ± Tarzƒ± Boyut Sistemi

### Organik Padding ve Radius
Her boyut, ada√ßayƒ± yapraƒüƒ±nƒ±n doƒüal formunu taklit eder:

```tsx
small: {
  paddingHorizontal: 14,
  paddingVertical: 8,
  borderRadius: 14,        // K√º√ß√ºk yaprak formu
  fontSize: 14,
  iconSize: 16,
  minHeight: 32,
}

medium: {
  paddingHorizontal: 18,
  paddingVertical: 12,
  borderRadius: 18,        // Orta yaprak formu
  fontSize: 16,
  iconSize: 18,
  minHeight: 42,
}

large: {
  paddingHorizontal: 24,
  paddingVertical: 16,
  borderRadius: 22,        // B√ºy√ºk yaprak formu
  fontSize: 18,
  iconSize: 20,
  minHeight: 52,
}

xl: {
  paddingHorizontal: 32,
  paddingVertical: 20,
  borderRadius: 26,        // Extra b√ºy√ºk yaprak formu
  fontSize: 20,
  iconSize: 24,
  minHeight: 62,
}
```

## üîß API Referansƒ±

### Props

```tsx
interface GeliomButtonProps {
  children?: ReactNode;           // Button metni
  state?: GeliomButtonState;      // 'active' | 'passive' | 'loading'
  size?: GeliomButtonSize;        // 'small' | 'medium' | 'large' | 'xl'
  layout?: GeliomButtonLayout;    // Layout tipi
  icon?: keyof typeof Ionicons.glyphMap; // Ionicons icon adƒ±
  onPress?: () => void;           // Tƒ±klama fonksiyonu
  disabled?: boolean;             // Disabled durumu
  style?: ViewStyle;              // Ek stil
}
```

### State Tipleri

```tsx
type GeliomButtonState = 'active' | 'passive' | 'loading';
```

- **active**: Ana aksiyonlar i√ßin (Forest ye≈üili)
- **passive**: ƒ∞kincil aksiyonlar i√ßin (Sage ye≈üili)
- **loading**: Y√ºkleme durumu i√ßin (Pine ye≈üili)

### Layout Tipleri

```tsx
type GeliomButtonLayout = 
  | 'default'     // Sadece metin
  | 'icon-left'   // Icon solda, metin saƒüda
  | 'icon-right'  // Metin solda, icon saƒüda
  | 'icon-only'   // Sadece icon (kare form)
  | 'full-width'  // Tam geni≈ülik
```

## üéØ Kullanƒ±m √ñrnekleri

### Temel Kullanƒ±m

```tsx
import { GeliomButton } from '@/components/shared';

// Active button
<GeliomButton state="active" onPress={handlePress}>
  Kaydet
</GeliomButton>

// Passive button
<GeliomButton state="passive" onPress={handleCancel}>
  ƒ∞ptal
</GeliomButton>

// Loading button
<GeliomButton state="loading">
  Y√ºkleniyor...
</GeliomButton>
```

### Icon'lu Kullanƒ±m

```tsx
// Sol icon
<GeliomButton 
  state="active" 
  layout="icon-left" 
  icon="checkmark-circle"
>
  Onayla
</GeliomButton>

// Saƒü icon
<GeliomButton 
  state="passive" 
  layout="icon-right" 
  icon="arrow-forward"
>
  ƒ∞leri
</GeliomButton>

// Sadece icon
<GeliomButton 
  state="active" 
  layout="icon-only" 
  icon="heart"
/>
```

### Boyut Varyasyonlarƒ±

```tsx
// K√º√ß√ºk button
<GeliomButton state="active" size="small">
  K√º√ß√ºk
</GeliomButton>

// B√ºy√ºk button
<GeliomButton state="active" size="large">
  B√ºy√ºk
</GeliomButton>

// Extra b√ºy√ºk button
<GeliomButton state="active" size="xl">
  Extra B√ºy√ºk
</GeliomButton>
```

### Full Width

```tsx
<GeliomButton 
  state="active" 
  layout="full-width"
  icon="save"
>
  Tam Geni≈ülik Kaydet
</GeliomButton>
```

### Kombinasyonlar

```tsx
// B√ºy√ºk, icon'lu, passive button
<GeliomButton 
  state="passive" 
  size="large"
  layout="icon-left" 
  icon="information-circle"
>
  Bilgi Al
</GeliomButton>

// XL boyutunda loading button
<GeliomButton 
  state="loading" 
  size="xl"
  layout="icon-left" 
  icon="refresh"
>
  Y√ºkleniyor...
</GeliomButton>
```

## üé® G√∂rsel √ñzellikler

### Shadow ve Elevation
- **shadowOffset**: `{ width: 0, height: 4 }`
- **shadowOpacity**: `0.25`
- **shadowRadius**: `8`
- **elevation**: `6` (Android)

### Typography
- **fontFamily**: `Comfortaa-SemiBold`
- **textAlign**: `center`
- **color**: Otomatik (state'e g√∂re)

### Animasyonlar
- **activeOpacity**: `0.8`
- **Disabled opacity**: `0.6`

## üå± Doƒüa Temalƒ± Kullanƒ±m Rehberi

### Duygusal Anlamlar

#### üå≤ Forest (Active)
- **Duygu**: G√º√ß, kararlƒ±lƒ±k, b√ºy√ºme
- **Kullanƒ±m**: Ana CTA'lar, √∂nemli aksiyonlar
- **√ñrnek**: "Kaydet", "G√∂nder", "Onayla"

#### üåæ Sage (Passive)
- **Duygu**: Bilgelik, sakinlik, denge
- **Kullanƒ±m**: ƒ∞kincil aksiyonlar, bilgi butonlarƒ±
- **√ñrnek**: "ƒ∞ptal", "Geri", "Bilgi"

#### üå≤ Pine (Loading)
- **Duygu**: Dayanƒ±klƒ±lƒ±k, s√ºreklilik, bekleme
- **Kullanƒ±m**: Y√ºkleme durumlarƒ±, i≈ülem s√ºre√ßleri
- **√ñrnek**: "Y√ºkleniyor...", "ƒ∞≈üleniyor..."

### Icon Se√ßimi Rehberi

#### Doƒüa Temalƒ± Icon'lar
```tsx
// Yaprak ve bitki icon'larƒ±
icon="leaf"          // üçÉ Genel doƒüa
icon="flower"        // üå∏ G√ºzellik, b√ºy√ºme
icon="tree"          // üå≥ G√º√ß, stabilite

// Doƒüal elementler
icon="water"         // üíß Temizlik, akƒ±≈ü
icon="sunny"         // ‚òÄÔ∏è Enerji, pozitiflik
icon="moon"          // üåô Sakinlik, gece modu
```

#### Aksiyon Icon'larƒ±
```tsx
// Pozitif aksiyonlar
icon="checkmark-circle"  // ‚úÖ Onay
icon="heart"            // ‚ù§Ô∏è Beƒüeni
icon="star"             // ‚≠ê Favorileme

// Navigasyon
icon="arrow-forward"    // ‚û°Ô∏è ƒ∞leri
icon="arrow-back"       // ‚¨ÖÔ∏è Geri
icon="home"             // üè† Ana sayfa
```

## üöÄ Performance ve Optimizasyon

### Best Practices
1. **State Management**: Button state'ini component dƒ±≈üƒ±nda y√∂net
2. **Icon Optimization**: Sadece gerekli icon'larƒ± import et
3. **Callback Optimization**: `useCallback` kullan
4. **Style Memoization**: Karma≈üƒ±k stiller i√ßin `useMemo`

### Accessibility
- **accessibilityRole**: "button" (otomatik)
- **accessibilityState**: disabled durumu otomatik
- **accessibilityLabel**: children text'i otomatik

## üéØ Geliom App'te Kullanƒ±m Senaryolarƒ±

### Ana Sayfa
```tsx
// Grup olu≈ütur butonu
<GeliomButton 
  state="active" 
  size="large"
  layout="full-width"
  icon="add-circle"
>
  üå± Yeni Grup Olu≈ütur
</GeliomButton>
```

### Profil Sayfasƒ±
```tsx
// Profil d√ºzenle
<GeliomButton 
  state="passive" 
  layout="icon-left"
  icon="create"
>
  ‚úèÔ∏è Profili D√ºzenle
</GeliomButton>
```

### Chat Interface
```tsx
// Mesaj g√∂nder
<GeliomButton 
  state="active" 
  size="small"
  layout="icon-only"
  icon="send"
/>
```

Bu button sistemi, Geliom'un doƒüa temalƒ± kimliƒüini g√º√ßlendirirken, kullanƒ±cƒ±ya tutarlƒ± ve anlamlƒ± bir etkile≈üim deneyimi sunar. üåø‚ú®
</file>

<file path="docs/Login-System-usage.md">
# Geliom - Login Sistemi Kullanƒ±m Kƒ±lavuzu

Geliom uygulamasƒ±nƒ±n doƒüa temalƒ±, blur efektli login sistemi ve Supabase OAuth entegrasyonu.

## üé® Tasarƒ±m √ñzellikleri

### Doƒüa Temalƒ± G√∂rsel Tasarƒ±m
- **Gradient Background**: Ye≈üil tonlarda doƒüal ge√ßi≈üler
- **Blur Effects**: Modern glassmorphism tasarƒ±mƒ±
- **Decorative Elements**: Doƒüal hissiyat i√ßin dekoratif daireler
- **Full Screen**: Tam ekran deneyimi
- **Responsive**: T√ºm ekran boyutlarƒ±na uyumlu

### Renk Paleti
- **Primary**: `#2E7D32` (Orman ye≈üili)
- **Secondary**: `#4CAF50` (√áimen ye≈üili)  
- **Tertiary**: `#81C784` (A√ßƒ±k ye≈üil)
- **Overlay**: ≈ûeffaf ye≈üil tonlar
- **Blur Background**: Dinamik blur efektleri

## üîê Authentication Sistemi

### Desteklenen Platformlar
- **Google OAuth**: T√ºm platformlarda
- **Apple Sign In**: Sadece iOS'ta g√∂r√ºn√ºr
- **Supabase Backend**: G√ºvenli auth y√∂netimi

### OAuth Flow
1. Kullanƒ±cƒ± login butonuna tƒ±klar
2. Supabase OAuth provider'ƒ±na y√∂nlendirilir
3. Kullanƒ±cƒ± kimlik doƒürulamasƒ± yapar
4. `geliom://auth/callback` URL'sine geri d√∂ner
5. Callback handler session'ƒ± kontrol eder
6. Ba≈üarƒ±lƒ± ise ana sayfaya y√∂nlendirir

## üì± Kullanƒ±m

### Login Sayfasƒ± √ñzellikleri
```tsx
// Temel kullanƒ±m
<BaseLayout fullScreen={true} headerShow={true}>
  <LinearGradient colors={[primary, secondary, tertiary]}>
    <BlurView intensity={20}>
      {/* Login i√ßeriƒüi */}
    </BlurView>
  </LinearGradient>
</BaseLayout>
```

### Login Butonlarƒ±
```tsx
// Google Login
<TouchableOpacity onPress={handleGoogleLogin}>
  <Ionicons name="logo-google" />
  <Typography variant="button">Google ile Giri≈ü Yap</Typography>
</TouchableOpacity>

// Apple Login (iOS only)
{Platform.OS === 'ios' && (
  <TouchableOpacity onPress={handleAppleLogin}>
    <Ionicons name="logo-apple" />
    <Typography variant="button">Apple ile Giri≈ü Yap</Typography>
  </TouchableOpacity>
)}
```

## ‚öôÔ∏è Konfig√ºrasyon

### app.json OAuth Ayarlarƒ±
```json
{
  "ios": {
    "infoPlist": {
      "CFBundleURLTypes": [
        {
          "CFBundleURLName": "geliom-auth",
          "CFBundleURLSchemes": ["geliom"]
        }
      ]
    }
  },
  "android": {
    "intentFilters": [
      {
        "action": "VIEW",
        "autoVerify": true,
        "data": [{ "scheme": "geliom" }],
        "category": ["BROWSABLE", "DEFAULT"]
      }
    ]
  }
}
```

### Supabase Konfig√ºrasyonu
```typescript
// api/supabase.ts
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: AsyncStorage,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
});
```

### Environment Variables
```bash
# .env
EXPO_PUBLIC_SUPABASE_URL=your_supabase_url
EXPO_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
```

## üîß OAuth Handler Fonksiyonlarƒ±

### Google Login
```typescript
const handleGoogleLogin = async () => {
  try {
    setIsLoading(true);
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: 'google',
      options: {
        redirectTo: 'geliom://auth/callback',
      },
    });

    if (error) {
      Alert.alert('Hata', 'Google ile giri≈ü yapƒ±lamadƒ±: ' + error.message);
      return;
    }

    if (data) {
      router.replace('/');
    }
  } catch (error) {
    Alert.alert('Hata', 'Beklenmeyen bir hata olu≈ütu');
  } finally {
    setIsLoading(false);
  }
};
```

### Apple Login
```typescript
const handleAppleLogin = async () => {
  try {
    setIsLoading(true);
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: 'apple',
      options: {
        redirectTo: 'geliom://auth/callback',
      },
    });

    if (error) {
      Alert.alert('Hata', 'Apple ile giri≈ü yapƒ±lamadƒ±: ' + error.message);
      return;
    }

    if (data) {
      router.replace('/');
    }
  } catch (error) {
    Alert.alert('Hata', 'Beklenmeyen bir hata olu≈ütu');
  } finally {
    setIsLoading(false);
  }
};
```

## üìÑ Callback Handler

### Auth Callback Sayfasƒ±
```typescript
// app/(auth)/callback.tsx
export default function AuthCallback() {
  useEffect(() => {
    const handleAuthCallback = async () => {
      try {
        const { data, error } = await supabase.auth.getSession();
        
        if (error) {
          router.replace('/(auth)/login');
          return;
        }

        if (data.session) {
          router.replace('/');
        } else {
          router.replace('/(auth)/login');
        }
      } catch (error) {
        router.replace('/(auth)/login');
      }
    };

    handleAuthCallback();
  }, []);
}
```

## üéØ Geliom √ñzel √ñzellikler

### Doƒüa Temalƒ± Mesajlar
- **Ho≈ü Geldin**: "Ho≈ü Geldin! üëã"
- **Tagline**: "üåø Doƒüal baƒülantƒ±lar kur"
- **A√ßƒ±klama**: "Arkada≈ülarƒ±nla ve ailenle baƒülantƒ± kurmak i√ßin giri≈ü yap"
- **Loading**: "Giri≈ü i≈ülemi tamamlanƒ±yor... üåø"

### Blur Efektleri
```typescript
<BlurView 
  intensity={20} 
  tint={isDark ? 'dark' : 'light'} 
  style={styles.loginContainer}
>
  {/* Login i√ßeriƒüi */}
</BlurView>
```

### Dekoratif Elementler
```typescript
// Doƒüal hissiyat i√ßin daireler
<View style={[styles.decorativeCircle, styles.circle1]} />
<View style={[styles.decorativeCircle, styles.circle2]} />
<View style={[styles.decorativeCircle, styles.circle3]} />
```

## üîí G√ºvenlik

### Best Practices
1. **Environment Variables**: Hassas bilgileri .env dosyasƒ±nda saklayƒ±n
2. **HTTPS**: Sadece g√ºvenli baƒülantƒ±lar kullanƒ±n
3. **Session Management**: Otomatik token yenileme aktif
4. **Error Handling**: Kullanƒ±cƒ± dostu hata mesajlarƒ±
5. **Deep Linking**: G√ºvenli callback URL'leri

### Hata Y√∂netimi
```typescript
if (error) {
  Alert.alert('Hata', 'Giri≈ü yapƒ±lamadƒ±: ' + error.message);
  return;
}
```

## üì± Platform Desteƒüi

### iOS
- Apple Sign In entegrasyonu
- CFBundleURLTypes konfig√ºrasyonu
- Native blur effects

### Android
- Intent filters konfig√ºrasyonu
- Google OAuth entegrasyonu
- Material Design uyumlu

### Web
- OAuth popup flow
- Responsive tasarƒ±m
- Cross-browser uyumluluk

Bu login sistemi Geliom'un doƒüal, samimi ve g√ºvenli hissiyatƒ±nƒ± desteklemek i√ßin √∂zel olarak tasarlanmƒ±≈ütƒ±r. üåø‚ú®
</file>

<file path="docs/Mock-Development-Setup.md">
# Geliom - Mock Development Setup

Geliom uygulamasƒ±nƒ±n mock data ile development ortamƒ±nda √ßalƒ±≈ümasƒ± i√ßin yapƒ±landƒ±rma.

## üéØ Ama√ß

Login sistemini ge√ßerek direkt uygulama geli≈ütirmesine odaklanmak i√ßin mock user data kullanƒ±mƒ±.

## üìä Mock Data Yapƒ±sƒ±

### GeliomUser Interface
```typescript
interface GeliomUser {
  id: string;                    // Unique user ID
  email: string;                 // User email
  display_name: string;          // Display name
  custom_user_id: string;        // Custom username (@handle)
  show_mood: boolean;            // Mood visibility setting
  current_mood_id?: string;      // Current mood ID
  onesignal_player_id?: string;  // Push notification ID
  created_at: string;            // Creation timestamp
  updated_at: string;            // Last update timestamp
}
```

### Mock User Data
```typescript
export const MOCK_USER: GeliomUser = {
  id: 'mock-user-123',
  email: 'hakan@geliom.app',
  display_name: 'Hakan Dursun',
  custom_user_id: 'hakan_dev',
  show_mood: true,
  current_mood_id: '1', // Mutlu
  onesignal_player_id: undefined,
  created_at: '2024-01-15T10:30:00Z',
  updated_at: new Date().toISOString(),
};
```

### Mock Moods
```typescript
export const MOCK_MOODS: UserMood[] = [
  { id: '1', name: 'Mutlu', emoji: 'üòä', color: '#4CAF50' },
  { id: '2', name: 'Heyecanlƒ±', emoji: 'ü§©', color: '#FF9800' },
  { id: '3', name: 'Sakin', emoji: 'üòå', color: '#2196F3' },
  { id: '4', name: 'Yorgun', emoji: 'üò¥', color: '#9E9E9E' },
  { id: '5', name: 'Enerjik', emoji: '‚ö°', color: '#FFEB3B' },
];
```

### Mock Statuses
```typescript
export const MOCK_STATUSES = [
  { id: '1', name: 'M√ºsaitim', emoji: '‚úÖ', color: '#4CAF50', notifies: true },
  { id: '2', name: 'Me≈ügul√ºm', emoji: 'üî¥', color: '#F44336', notifies: true },
  { id: '3', name: 'Dƒ±≈üarƒ±dayƒ±m', emoji: 'üö∂', color: '#2196F3', notifies: false },
  { id: '4', name: 'Evdeyim', emoji: 'üè†', color: '#795548', notifies: false },
  { id: '5', name: '√áalƒ±≈üƒ±yorum', emoji: 'üíª', color: '#607D8B', notifies: true },
];
```

## üîß Sistem Konfig√ºrasyonu

### AuthContext Mock Implementation
```typescript
// Mock session ve user data'yƒ± set et
const initializeAuth = async () => {
  setIsLoading(true);
  
  // Sim√ºle edilmi≈ü loading s√ºresi
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  setSession(MOCK_SESSION as any);
  setUser(MOCK_USER);
  
  setIsLoading(false);
};

// Mock sign out
const signOut = async () => {
  setSession(null);
  setUser(null);
};
```

### Routing Bypass
```typescript
// _layout.tsx - Login routing'i bypass et
useEffect(() => {
  if (isLoading) return;
  
  // Mock i√ßin login bypass - direkt ana sayfada kal
  console.log('Layout routing bypassed for mock data');
  
  // Ger√ßek auth kodu comment'te bekliyor
}, [session, isLoading, segments]);
```

## üì± UI G√∂sterimi

### Ana Sayfa Mock Data Display
```typescript
// User bilgileri
<Typography variant="body">
  {user?.display_name || 'Misafir Kullanƒ±cƒ±'}
</Typography>

<Typography variant="caption">
  @{user?.custom_user_id || 'kullanici'}
</Typography>

// User mood g√∂sterimi
{currentMood && user?.show_mood && (
  <View style={moodContainerStyle}>
    <Typography>{currentMood.emoji}</Typography>
    <Typography>{currentMood.name}</Typography>
  </View>
)}
```

### Session Status
```typescript
// Mock session her zaman aktif
<Typography variant="status">
  {session ? 'üü¢ √áevrimi√ßi' : 'üî¥ √áevrimdƒ±≈üƒ±'}
</Typography>
```

## üöÄ Development Workflow

### 1. Mock Mode Aktif
- Uygulama a√ßƒ±lƒ±nca direkt ana sayfa
- Login ekranƒ± bypass edilir
- Mock user data otomatik y√ºklenir

### 2. User Data G√∂r√ºnt√ºleme
- Display name: "Hakan Dursun"
- Username: "@hakan_dev"
- Email: "hakan@geliom.app"
- Mood: "üòä Mutlu" (show_mood: true)
- Status: "üü¢ √áevrimi√ßi"

### 3. Fonksiyonellik
- Sign out mock olarak √ßalƒ±≈üƒ±r
- Auth state deƒüi≈üiklikleri sim√ºle edilir
- Loading states normal √ßalƒ±≈üƒ±r

## üîÑ Production'a Ge√ßi≈ü

### Ger√ßek Auth Sistemi Aktifle≈ütirme
1. **AuthContext.tsx**: Mock kod yerine Supabase auth kodunu aktifle≈ütir
2. **_layout.tsx**: Routing comment'lerini a√ß
3. **types/user.ts**: Mock data'yƒ± kaldƒ±r veya development flag ile kontrol et

### Ge√ßi≈ü Adƒ±mlarƒ±
```typescript
// 1. Environment variable ile kontrol
const IS_MOCK_MODE = process.env.EXPO_PUBLIC_MOCK_AUTH === 'true';

// 2. Conditional auth implementation
const initializeAuth = async () => {
  if (IS_MOCK_MODE) {
    // Mock implementation
  } else {
    // Real Supabase implementation
  }
};

// 3. Routing conditional
if (!IS_MOCK_MODE && !session && !inAuthGroup) {
  router.replace('/(auth)/login');
}
```

## üìã Avantajlar

### Development Speed
- Login s√ºreci bypass edilir
- Direkt feature development
- Hƒ±zlƒ± test d√∂ng√ºs√º

### Data Consistency
- Tutarlƒ± test data
- Predictable user state
- Reliable development environment

### Team Collaboration
- Herkes aynƒ± mock data kullanƒ±r
- Backend baƒüƒ±msƒ±z development
- Parallel development m√ºmk√ºn

## üé® UI/UX Testing

### Mock Data ile Test Senaryolarƒ±
- User profile g√∂r√ºnt√ºleme
- Mood deƒüi≈üiklikleri
- Status updates
- Navigation flows
- Theme switching

Bu mock setup Geliom'un hƒ±zlƒ± development s√ºrecini desteklemek i√ßin optimize edilmi≈ütir. üåø‚ö°
</file>

<file path="docs/Professional-Auth-System.md">
# Geliom - Profesyonel Authentication Sistemi

Expo'nun resmi authentication paketleri ve Supabase entegrasyonu ile olu≈üturulmu≈ü kaliteli auth sistemi.

## üèóÔ∏è Mimari Yapƒ±

### Kullanƒ±lan Paketler
- **expo-apple-authentication**: iOS i√ßin resmi Apple Sign In
- **expo-auth-session**: OAuth flow y√∂netimi
- **expo-crypto**: G√ºvenli kriptografik i≈ülemler
- **@supabase/supabase-js**: Backend auth y√∂netimi

### Sistem Bile≈üenleri
```
AuthProvider (Context)
‚îú‚îÄ‚îÄ Session Management
‚îú‚îÄ‚îÄ User Profile Management
‚îú‚îÄ‚îÄ Auto Profile Creation
‚îî‚îÄ‚îÄ Auth State Listeners

Login Page
‚îú‚îÄ‚îÄ Google OAuth (Supabase)
‚îú‚îÄ‚îÄ Apple Sign In (Native)
‚îú‚îÄ‚îÄ Blur Effects
‚îî‚îÄ‚îÄ Error Handling

Auth Flow
‚îú‚îÄ‚îÄ OAuth Redirect Handling
‚îú‚îÄ‚îÄ Session Persistence
‚îî‚îÄ‚îÄ Auto Navigation
```

## üîê Authentication Flow

### Google Login Flow
1. Kullanƒ±cƒ± "Google ile Giri≈ü Yap" butonuna tƒ±klar
2. Supabase OAuth provider'ƒ±na y√∂nlendirilir
3. Google auth sayfasƒ± a√ßƒ±lƒ±r
4. Kullanƒ±cƒ± kimlik doƒürulamasƒ± yapar
5. Supabase session olu≈üturur
6. AuthContext listener session'ƒ± yakalar
7. User profili otomatik olu≈üturulur/g√ºncellenir
8. Ana sayfaya y√∂nlendirilir

### Apple Login Flow
1. Kullanƒ±cƒ± Apple Sign In butonuna tƒ±klar
2. iOS native Apple auth dialog a√ßƒ±lƒ±r
3. Kullanƒ±cƒ± Face ID/Touch ID ile doƒürular
4. Apple identity token alƒ±nƒ±r
5. Supabase'e token g√∂nderilir
6. Session olu≈üturulur ve flow devam eder

## üì± Kullanƒ±m

### Login Sayfasƒ±
```tsx
// Profesyonel Google Login
<TouchableOpacity onPress={handleGoogleLogin}>
  <Ionicons name="logo-google" size={24} color="#4285F4" />
  <Typography variant="button">Google ile Giri≈ü Yap</Typography>
</TouchableOpacity>

// Native Apple Login (iOS only)
<AppleAuthentication.AppleAuthenticationButton
  buttonType={AppleAuthentication.AppleAuthenticationButtonType.SIGN_IN}
  buttonStyle={isDark ? 
    AppleAuthentication.AppleAuthenticationButtonStyle.WHITE : 
    AppleAuthentication.AppleAuthenticationButtonStyle.BLACK
  }
  cornerRadius={16}
  onPress={handleAppleLogin}
/>
```

### Auth Context Kullanƒ±mƒ±
```tsx
const { session, user, isLoading, signOut } = useAuth();

// Giri≈ü durumu kontrol√º
if (isLoading) return <LoadingScreen />;
if (!session) return <LoginScreen />;

// Kullanƒ±cƒ± bilgileri
console.log(user.email, user.display_name);

// √áƒ±kƒ±≈ü yapma
await signOut();
```

## üõ†Ô∏è Konfig√ºrasyon

### Environment Variables
```bash
# .env
EXPO_PUBLIC_SUPABASE_URL=your_supabase_url
EXPO_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
```

### Supabase Auth Settings
```sql
-- Users tablosu (otomatik olu≈üturulur)
CREATE TABLE users (
  id UUID PRIMARY KEY REFERENCES auth.users(id),
  email TEXT,
  display_name TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own profile" ON users
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update own profile" ON users
  FOR UPDATE USING (auth.uid() = id);
```

### OAuth Providers (Supabase Dashboard)
```
Google OAuth:
- Client ID: your_google_client_id
- Client Secret: your_google_client_secret
- Redirect URL: your_app_scheme://auth/callback

Apple OAuth:
- Service ID: your_apple_service_id
- Team ID: your_apple_team_id
- Key ID: your_apple_key_id
- Private Key: your_apple_private_key
```

## üé® UI/UX √ñzellikleri

### Doƒüa Temalƒ± Tasarƒ±m
```tsx
// Gradient background
<LinearGradient colors={[primary, secondary, tertiary]}>
  {/* Decorative circles */}
  <View style={styles.decorativeCircle} />
</LinearGradient>

// Blur login container
<BlurView intensity={20} tint={isDark ? 'dark' : 'light'}>
  {/* Login content */}
</BlurView>
```

### Responsive Design
- Full screen experience
- Safe area handling
- Platform-specific components
- Theme-aware styling

## üîí G√ºvenlik √ñzellikleri

### Session Management
- Automatic token refresh
- Secure storage (AsyncStorage)
- Session persistence
- Logout functionality

### Error Handling
```tsx
try {
  const { data, error } = await supabase.auth.signInWithOAuth({
    provider: 'google',
  });
  
  if (error) {
    Alert.alert('Hata', error.message);
    return;
  }
} catch (error) {
  Alert.alert('Hata', 'Beklenmeyen bir hata olu≈ütu');
  console.error('Auth error:', error);
}
```

### User Cancellation Handling
```tsx
// Apple login cancellation
if (error.code === 'ERR_REQUEST_CANCELED') {
  // Kullanƒ±cƒ± iptal etti, hata g√∂sterme
  return;
}
```

## üìä State Management

### AuthContext Structure
```typescript
interface AuthContextType {
  session: Session | null;
  user: User | null;
  isLoading: boolean;
  initializeAuth: () => Promise<void>;
  signOut: () => Promise<void>;
}
```

### Auto Profile Creation
```typescript
// Yeni kullanƒ±cƒ± i√ßin otomatik profil olu≈üturma
if (error && error.code === 'PGRST116') {
  const { data: newUser } = await supabase
    .from('users')
    .insert([{
      id: session.user.id,
      email: session.user.email,
      display_name: session.user.user_metadata?.full_name || 
                   session.user.email?.split('@')[0],
      created_at: new Date().toISOString(),
    }])
    .select()
    .single();
}
```

## üöÄ Performance Optimizations

### Lazy Loading
- Auth state sadece gerektiƒüinde y√ºklenir
- User profile async olarak fetch edilir
- Error boundaries ile crash prevention

### Memory Management
- Auth listeners otomatik cleanup
- Session state optimized updates
- Minimal re-renders

## üß™ Testing & Debugging

### Debug Logs
```typescript
console.log('Auth state changed:', event, session?.user?.email);
```

### Error Monitoring
- Comprehensive error logging
- User-friendly error messages
- Fallback mechanisms

## üì± Platform Support

### iOS
- Native Apple Sign In button
- Face ID/Touch ID integration
- iOS-specific styling

### Android
- Google OAuth integration
- Material Design compliance
- Android-specific handling

### Web
- OAuth popup flow
- Responsive design
- Cross-browser compatibility

## üéØ Best Practices

1. **Security First**: Hassas bilgileri environment variables'da saklayƒ±n
2. **User Experience**: Loading states ve error handling
3. **Performance**: Minimal re-renders ve efficient state management
4. **Accessibility**: Screen reader uyumluluƒüu
5. **Testing**: Comprehensive error scenarios

Bu profesyonel auth sistemi Geliom'un g√ºvenlik ve kullanƒ±cƒ± deneyimi standartlarƒ±nƒ± kar≈üƒ±lamak i√ßin √∂zel olarak tasarlanmƒ±≈ütƒ±r. üåøüîê
</file>

<file path="docs/project-flow.md">
Geliom - Proje Detay Raporu ve Geli≈ütirme Planƒ±
Dok√ºman S√ºr√ºm√º: 2.0
Son G√ºncelleme: 2025-01-XX
1. Proje √ñzeti ve Vizyon
1.1. Proje Adƒ±
Geliom
1.2. Proje Vizyonu
ƒ∞nsanlarƒ±n dijital g√ºr√ºlt√ºden uzak, sadece en yakƒ±n √ßevreleriyle (arkada≈ülar ve aile) samimi ve anlƒ±k bir ≈üekilde baƒülantƒ± kurarak sosyal hayatlarƒ±nƒ± zahmetsizce organize etmelerini saƒülayan bir platform olmak.
1.3. √á√∂z√ºlen Temel Problem
"Ne yapsak?", "M√ºsait misin?", "Hadi bulu≈üalƒ±m!" gibi g√ºnl√ºk sosyal koordinasyon sorularƒ±nƒ±, uzun mesajla≈ümalara veya telefon trafiƒüine gerek kalmadan, tek bir dokunu≈üla √ß√∂zmek. Spontane bulu≈ümalarƒ± ve planlƒ± etkinlikleri te≈üvik etmek.
1.4. Hedef Kitle
Birincil: 16-25 ya≈ü arasƒ± lise/√ºniversite √∂ƒürencileri ve gen√ß profesyoneller.
ƒ∞kincil: Yakƒ±n aile baƒülarƒ±na sahip, teknolojiye yatkƒ±n yeti≈ükinler.
2. Teknoloji Yƒ±ƒüƒ±nƒ± ve Mimari
Bu teknoloji yƒ±ƒüƒ±nƒ±, hƒ±zlƒ± geli≈ütirme (Expo), √∂l√ßeklenebilirlik (Supabase) ve sekt√∂r standardƒ± ara√ßlarla (Firebase, Adapty) saƒülam bir temel olu≈üturmak i√ßin se√ßilmi≈ütir.
Alan
Teknoloji/Servis
Beklentiler ve Sorumluluklar
Frontend
React Native (Expo)
Hƒ±zlƒ± ve cross-platform (iOS/Android) geli≈ütirme. Kolay OTA (Over-the-Air) g√ºncellemeler.
Navigasyon
React Navigation
Ekranlar arasƒ± ge√ßi≈ülerin akƒ±cƒ± ve standartlara uygun y√∂netimi.
State Management
Zustand / Context API
Uygulama genelindeki state'in (kullanƒ±cƒ± bilgileri, gruplar vb.) verimli y√∂netimi.
Backend (BaaS)
Supabase
Projenin ana backend'i. T√ºm veri i≈ülemleri, kimlik doƒürulama ve anlƒ±k g√ºncellemeler buradan y√∂netilecek.
Veritabanƒ±
Supabase (PostgreSQL)
ƒ∞li≈ükisel veri yapƒ±sƒ±, g√º√ßl√º sorgulama ve veri b√ºt√ºnl√ºƒü√º. Satƒ±r Seviyesi G√ºvenlik (RLS) ile maksimum g√ºvenlik.
Kimlik Doƒürulama
Supabase Auth
Google ile g√ºvenli ve kolay giri≈ü. Kullanƒ±cƒ± y√∂netimi.
Anlƒ±k Veri
Supabase Realtime
Durum ve duygu durumu deƒüi≈üikliklerinin t√ºm grup √ºyelerine anƒ±nda yansƒ±tƒ±lmasƒ±.
Sunucu Fonksiyonlarƒ±
Supabase Edge Functions
Bildirim g√∂nderme, zamanlanmƒ±≈ü etkinlikleri kontrol etme gibi sunucu tarafƒ± mantƒ±klarƒ±n √ßalƒ±≈ütƒ±rƒ±lmasƒ±.
Push Bildirim
OneSignal
Segmentasyon, zengin bildirimler ve y√ºksek teslimat oranƒ±. Kullanƒ±cƒ±ya √∂zel bildirimlerin y√∂netimi.
Abonelik Y√∂netimi
Adapty
App Store/Play Store aboneliklerinin kolay entegrasyonu. Paywall A/B testi, gelir analizi ve kullanƒ±cƒ± segmentasyonu.
Analiz & Hata Takibi
Firebase
Analytics: Kullanƒ±cƒ± davranƒ±≈ülarƒ±nƒ± (en √ßok kullanƒ±lan √∂zellikler, ekran s√ºreleri vb.) izleyerek √ºr√ºn kararlarƒ± alma.
Crashlytics: Uygulama √ß√∂kmelerini anƒ±nda tespit edip detaylƒ± raporlar alarak hƒ±zlƒ±ca d√ºzeltme.

3. Veritabanƒ± Mimarisi
Veritabanƒ± yapƒ±sƒ±, projenin temelini olu≈üturur. T√ºm tablolar, ili≈ükiler ve g√ºvenlik politikalarƒ± supabase_setup.sql betiƒüinde tanƒ±mlanmƒ±≈ütƒ±r. Detaylƒ± g√∂rsel ≈üema i√ßin db_diagram.md dosyasƒ±na bakƒ±lmalƒ±dƒ±r.
Ana Tablolar:
users: Kullanƒ±cƒ± profilleri.
groups: Arkada≈ü ve aile gruplarƒ±.
group_members: Kullanƒ±cƒ±-grup ili≈ükisi.
group_join_requests: Grup katƒ±lma istekleri (onay sistemi i√ßin).
statuses / user_statuses: Anlƒ±k eylem durumlarƒ± (default + custom).
moods: Duygu durumlarƒ± (default + kullanƒ±cƒ±ya √∂zel).
subscriptions: Kullanƒ±cƒ± abonelik bilgileri.
scheduled_events: Zamanlanmƒ±≈ü etkinlikler (Premium).
nicknames, muted_notifications: Sosyal etkile≈üim tablolarƒ±.
4. √ñzellik Listesi ve Kullanƒ±cƒ± Akƒ±≈ülarƒ± (Features & Actions)
4.1. √úcretsiz √ñzellikler (MVP √áekirdeƒüi)
Kullanƒ±cƒ± Y√∂netimi ve Profil
[ ] Action: Kullanƒ±cƒ± Google hesabƒ± ile uygulamaya giri≈ü yapar.
[ ] Action: ƒ∞lk giri≈üte kullanƒ±cƒ± i√ßin otomatik olarak profil ve custom_user_id olu≈üturulur.
[ ] Ekran: Profilim Ekranƒ±
[ ] Action: Kullanƒ±cƒ± display_name ve custom_user_id'sini g√ºncelleyebilir.
[ ] Action: Kullanƒ±cƒ±, √∂nceden tanƒ±mlƒ± moods listesinden duygu durumunu se√ßebilir.
[ ] Action: Kullanƒ±cƒ±, duygu durumunun (show_mood) diƒüerleri tarafƒ±ndan g√∂r√ºl√ºp g√∂r√ºlmeyeceƒüini ayarlayabilir.
Grup Y√∂netimi
[ ] Ekran: Ana Ekran (Dashboard)
[ ] Action: Kullanƒ±cƒ±, √ºye olduƒüu gruplarƒ± ve aileleri listeler.
[ ] Action: "Grup Olu≈ütur" butonu ile yeni bir grup/aile olu≈üturur (1 adet grup, 1 adet aile limiti - Premium'da sƒ±nƒ±rsƒ±z).
[ ] Action: "Gruba Katƒ±l" alanƒ±na davet kodu girerek bir gruba katƒ±lma isteƒüi g√∂nderir.
[ ] Action: Custom user ID ile kullanƒ±cƒ± arama yaparak direkt davet g√∂nderebilir.
[ ] Ekran: Grup Katƒ±lma ƒ∞stekleri (Grup Kurucusu i√ßin)
[ ] Action: Grup kurucusu, gelen katƒ±lma isteklerini g√∂r√ºr (kullanƒ±cƒ± bilgisi, istek zamanƒ±).
[ ] Action: Grup kurucusu, katƒ±lma isteƒüini onaylar veya reddeder.
[ ] Backend: Onaylandƒ±ƒüƒ±nda kullanƒ±cƒ± otomatik olarak gruba eklenir (group_members).
[ ] Backend: Reddedildiƒüinde istek silinir ve kullanƒ±cƒ±ya bildirim g√∂nderilir.
[ ] Ekran: Grup Detaylarƒ± Ekranƒ±
[ ] Action: Grup √ºyelerini ve anlƒ±k durumlarƒ±nƒ±/duygularƒ±nƒ± g√∂r√ºr.
[ ] Action: Gruba √∂zel invite_code'u kopyalayƒ±p payla≈üabilir.
[ ] Action: Gruptan ayrƒ±labilir.
Sosyal Etkile≈üim
[ ] Component: Hƒ±zlƒ± Eylem Butonlarƒ± (Ana Ekranda)
[ ] Action: Kullanƒ±cƒ± default statuses listesinden birini se√ßer (M√ºsaitim, Me≈ügul√ºm vb.).
[ ] Action: Premium kullanƒ±cƒ±lar, olu≈üturduklarƒ± custom status'larƒ± da listede g√∂r√ºr ve se√ßebilir.
[ ] Backend: Status listesi: Default statuses + Kullanƒ±cƒ±nƒ±n custom status'larƒ± (is_custom=true, owner_id=kullanƒ±cƒ±_id) birle≈ütirilir.
[ ] Backend: Se√ßilen durum, user_statuses tablosunu g√ºnceller ve Realtime ile anƒ±nda diƒüer √ºyelere yansƒ±r.
[ ] Backend: Eƒüer durum notifies=true ise, Supabase Edge Function tetiklenir ve OneSignal √ºzerinden gruba bildirim g√∂nderilir.
[ ] Action: Kullanƒ±cƒ± default moods listesinden duygu durumunu se√ßer.
[ ] Action: Premium kullanƒ±cƒ±lar, olu≈üturduklarƒ± custom mood'larƒ± da listede g√∂r√ºr ve se√ßebilir.
[ ] Backend: Mood listesi: Default moods + Kullanƒ±cƒ±nƒ±n custom mood'larƒ± (owner_id=kullanƒ±cƒ±_id) birle≈ütirilir.
[ ] Action: Grup Detaylarƒ± ekranƒ±nda bir √ºyenin √ºzerine basƒ±lƒ± tutarak o √ºyeye √∂zel, sadece kendisinin g√∂rebileceƒüi bir nickname atayabilir.
[ ] Action: Grup Detaylarƒ± ekranƒ±nda bir √ºyeden gelen bildirimleri sessize alabilir (muted_notifications).
4.2. Premium √ñzellikler (Abonelikli)
Abonelik Y√∂netimi
[ ] Ekran: Premium/Paywall Ekranƒ±
[ ] Action: Kullanƒ±cƒ±ya premium √∂zellikler tanƒ±tƒ±lƒ±r ve abonelik se√ßenekleri sunulur (aylƒ±k/yƒ±llƒ±k).
[ ] Backend: Adapty SDK'sƒ± ile satƒ±n alma i≈ülemi y√∂netilir.
[ ] Backend: Ba≈üarƒ±lƒ± satƒ±n alma sonrasƒ± Adapty webhook'u veya client tarafƒ± callback ile subscriptions tablosu g√ºncellenir.
[ ] Action: Kullanƒ±cƒ±, profil ekranƒ±ndan mevcut abonelik durumunu ve biti≈ü tarihini g√∂rebilir.
Geni≈ületilmi≈ü Limitler
[ ] Backend: Kullanƒ±cƒ±nƒ±n subscriptions.status'u 'premium' ise grup ve aile olu≈üturma limitleri kaldƒ±rƒ±lƒ±r.
[ ] Backend: Premium kullanƒ±cƒ±larƒ±n olu≈üturduƒüu gruplarƒ±n member_limit'i daha y√ºksek olur (√∂rn: 15).
Zamanlanmƒ±≈ü Etkinlikler
[ ] Ekran: Etkinlik Olu≈üturma Ekranƒ± (Premium)
[ ] Action: Kullanƒ±cƒ± bir grup se√ßerek etkinlik adƒ±, tarihi ve saati belirler.
[ ] Action: Etkinlik i√ßin bildirim zamanƒ± ayarlar.
[ ] Backend: scheduled_events tablosuna yeni etkinlik kaydedilir.
[ ] Backend: Zamanlanmƒ±≈ü bir Supabase Edge Function (cron job), notification_time'ƒ± gelen etkinlikleri kontrol eder ve zamanƒ± geldiƒüinde gruba bildirim g√∂nderir.
√ñzelle≈ütirme
[ ] Ekran: Custom Status Olu≈üturma (Premium)
[ ] Action: Premium kullanƒ±cƒ±lar, kendilerine √∂zel durum ifadeleri (statuses) olu≈üturabilir (is_custom=true, owner_id=kullanƒ±cƒ±_id).
[ ] Action: Olu≈üturulan custom status'lar, default status'lar ile birlikte listede g√∂sterilir.
[ ] Action: Custom status'larƒ± d√ºzenleyebilir ve silebilir.
[ ] Ekran: Custom Mood Olu≈üturma (Premium)
[ ] Action: Premium kullanƒ±cƒ±lar, kendilerine √∂zel duygu durumlarƒ± (moods) olu≈üturabilir (owner_id=kullanƒ±cƒ±_id).
[ ] Action: Olu≈üturulan custom mood'lar, default mood'lar ile birlikte listede g√∂sterilir.
[ ] Action: Custom mood'larƒ± d√ºzenleyebilir ve silebilir.
[ ] Backend: Veritabanƒ±: moods tablosuna owner_id kolonu eklenmeli (nullable, FK to users.id).
5. Geli≈ütirme Yol Haritasƒ± (Fazlar)
Faz 1: Altyapƒ± ve √áekirdek MVP (Sprint 1-2) ‚úÖ TAMAMLANDI
Hedef: Kullanƒ±cƒ±larƒ±n giri≈ü yapƒ±p, grup kurup, anlƒ±k durumlarƒ±nƒ± g√∂rebildiƒüi temel bir uygulama.
Tamamlanan G√∂revler:
‚úÖ T√ºm servislerin (Supabase, OneSignal, Firebase, Adapty) projelerini olu≈ütur ve konfig√ºrasyonlarƒ±nƒ± yap.
‚úÖ Expo projesini ba≈ülat, navigasyon yapƒ±sƒ±nƒ± kur.
‚úÖ supabase_setup.sql betiƒüini √ßalƒ±≈ütƒ±rarak veritabanƒ±nƒ± olu≈ütur.
‚úÖ Supabase Auth ile Google Giri≈üini entegre et. handle_new_user trigger'ƒ±nƒ±n √ßalƒ±≈ütƒ±ƒüƒ±nƒ± doƒürula.
‚úÖ Profil ekranƒ±nƒ± ve kullanƒ±cƒ± bilgilerini g√ºncelleme i≈ülevini tamamla.
‚úÖ Grup olu≈üturma ve gruptan ayrƒ±lma akƒ±≈üƒ±nƒ± tamamla.
‚úÖ Ana ekranda grup √ºyelerini ve durumlarƒ±nƒ± Supabase Realtime ile anlƒ±k olarak g√∂ster.
‚úÖ Hƒ±zlƒ± eylem butonlarƒ± ile durum g√ºncelleme i≈ülevini tamamla.
‚úÖ Default status ve mood listelerini g√∂sterme.
‚úÖ Mood g√∂sterimi ve se√ßimi.
Faz 2: Grup Katƒ±lma Sistemi ve Bildirimler (Sprint 3)
Hedef: Grup katƒ±lma onay sistemi ve bildirim altyapƒ±sƒ±nƒ± kurmak.
G√∂revler:
[ ] Veritabanƒ±: group_join_requests tablosunu olu≈ütur (id, group_id, requester_id, status: 'pending'|'approved'|'rejected', created_at, updated_at).
[ ] Ekran: Grup Katƒ±lma ƒ∞steƒüi G√∂nderme
[ ] Action: Kullanƒ±cƒ± davet kodu girerek katƒ±lma isteƒüi g√∂nderir (group_join_requests tablosuna 'pending' kaydƒ±).
[ ] Backend: ƒ∞stek g√∂nderildiƒüinde grup kurucusuna bildirim g√∂nderilir (OneSignal).
[ ] Ekran: Grup Katƒ±lma ƒ∞stekleri Y√∂netimi (Grup Kurucusu i√ßin)
[ ] Action: Grup kurucusu, gelen katƒ±lma isteklerini listeler (pending durumundakiler).
[ ] Action: Grup kurucusu, isteƒüi onaylar ‚Üí group_members'e eklenir, istek 'approved' olur.
[ ] Action: Grup kurucusu, isteƒüi reddeder ‚Üí istek 'rejected' olur, kullanƒ±cƒ±ya bildirim g√∂nderilir.
[ ] Backend: Realtime ile istek durumu deƒüi≈üiklikleri anƒ±nda yansƒ±r.
[ ] Ekran: Kullanƒ±cƒ± Arama ve Davet G√∂nderme
[ ] Action: Kullanƒ±cƒ± custom_user_id ile arama yapar (useUserByCustomId hook kullanƒ±lƒ±r).
[ ] Action: Bulunan kullanƒ±cƒ±ya direkt davet g√∂nderme se√ßeneƒüi sunulur.
[ ] Backend: Davet g√∂nderildiƒüinde hedef kullanƒ±cƒ±ya bildirim g√∂nderilir.
[ ] OneSignal SDK'sƒ±nƒ± entegre et ve kullanƒ±cƒ± onesignal_player_id'sini users tablosuna kaydet.
[ ] Durum g√ºncellendiƒüinde bildirim g√∂nderecek Supabase Edge Function'ƒ± yaz ve deploy et.
[ ] Takma isim (nickname) ekleme ve g√∂sterme √∂zelliƒüini geli≈ütir.
[ ] Kullanƒ±cƒ± bildirimlerini sessize alma (mute) √∂zelliƒüini geli≈ütir.
Faz 3: Monetizasyon ve Premium Ge√ßi≈ü (Sprint 4)
Hedef: Uygulamadan gelir elde etme altyapƒ±sƒ±nƒ± kurmak.
G√∂revler:
[ ] Adapty SDK'sƒ±nƒ± entegre et. App Store Connect ve Google Play Console'da √ºr√ºnleri tanƒ±mla.
[ ] Paywall ekranƒ±nƒ± tasarla ve geli≈ütir.
[ ] Satƒ±n alma akƒ±≈üƒ±nƒ± ve abonelik durumu kontrol√ºn√º (hem client hem backend) tamamla.
[ ] Grup olu≈üturma ve √ºye ekleme gibi i≈ülemlerde abonelik durumunu kontrol eden RLS politikalarƒ±nƒ± veya backend mantƒ±ƒüƒ±nƒ± ekle.
[ ] Premium kontrol√º: Custom status ve mood olu≈üturma √∂zelliklerinde abonelik kontrol√º ekle.
Faz 4: Geli≈ümi≈ü Premium √ñzellikler (Sprint 5 ve sonrasƒ±)
Hedef: Premium abonelere daha fazla deƒüer sunmak.
G√∂revler:
[ ] Veritabanƒ±: moods tablosuna owner_id kolonu ekle (nullable, FK to users.id).
[ ] Ekran: Custom Status Olu≈üturma ve Y√∂netimi (Premium)
[ ] Action: Premium kullanƒ±cƒ±lar, kendi √∂zel status'larƒ±nƒ± olu≈üturabilir (is_custom=true, owner_id=kullanƒ±cƒ±_id).
[ ] Action: Olu≈üturulan custom status'lar, StatusSelector'da default status'lar ile birlikte g√∂sterilir.
[ ] Action: Custom status'larƒ± d√ºzenleyebilir ve silebilir.
[ ] Backend: Status listesi sorgusu: Default statuses (is_custom=false) + Kullanƒ±cƒ±nƒ±n custom status'larƒ± (is_custom=true, owner_id=kullanƒ±cƒ±_id) birle≈ütirilir.
[ ] Ekran: Custom Mood Olu≈üturma ve Y√∂netimi (Premium)
[ ] Action: Premium kullanƒ±cƒ±lar, kendi √∂zel mood'larƒ±nƒ± olu≈üturabilir (owner_id=kullanƒ±cƒ±_id).
[ ] Action: Olu≈üturulan custom mood'lar, mood se√ßici listede default mood'lar ile birlikte g√∂sterilir.
[ ] Action: Custom mood'larƒ± d√ºzenleyebilir ve silebilir.
[ ] Backend: Mood listesi sorgusu: Default moods (owner_id IS NULL) + Kullanƒ±cƒ±nƒ±n custom mood'larƒ± (owner_id=kullanƒ±cƒ±_id) birle≈ütirilir.
[ ] Zamanlanmƒ±≈ü etkinlik olu≈üturma ekranƒ±nƒ± ve akƒ±≈üƒ±nƒ± geli≈ütir.
[ ] Zamanlanmƒ±≈ü bildirimler i√ßin cron job mantƒ±ƒüƒ±nƒ± Supabase Edge Function ile kur.
[ ] Kullanƒ±cƒ± geri bildirimlerine g√∂re yeni √∂zellikler planla.
</file>

<file path="docs/project-mermaid.md">
```mermaid
erDiagram
    users {
        UUID id PK "auth.users'dan referans"
        TEXT custom_user_id UK
        TEXT display_name
        TEXT photo_url
        INT mood_id FK "moods tablosuna referans"
        BOOLEAN show_mood
        TEXT onesignal_player_id
        TIMESTAMPTZ updated_at
    }

    moods {
        INT id PK
        TEXT text UK
        TEXT emoji
    }

    groups {
        UUID id PK
        UUID owner_id FK
        TEXT type
        TEXT name
        TEXT invite_code UK
        INT member_limit
        TIMESTAMPTZ created_at
    }

    group_members {
        UUID group_id PK, FK
        UUID user_id PK, FK
        TIMESTAMPTZ joined_at
    }

    nicknames {
        UUID group_id PK, FK
        UUID setter_user_id PK, FK
        UUID target_user_id PK, FK
        TEXT nickname
    }

    statuses {
        INT id PK
        TEXT text
        BOOLEAN notifies
        BOOLEAN is_custom
        UUID owner_id FK "Eƒüer custom ise sahibi"
    }

    user_statuses {
        UUID user_id PK, FK
        INT status_id FK
        TIMESTAMPTZ updated_at
    }

    muted_notifications {
        UUID muter_user_id PK, FK
        UUID muted_user_id PK, FK
    }

    subscriptions {
        UUID user_id PK, FK
        TEXT status
        TIMESTAMPTZ expires_at
    }

    scheduled_events {
        UUID id PK
        UUID group_id FK
        UUID creator_id FK
        TEXT title
        TIMESTAMPTZ event_time
        TIMESTAMPTZ notification_time
        TIMESTAMPTZ created_at
    }

    users ||--|{ moods : "feels"
    users ||--o{ groups : "owns"
    users ||--o{ group_members : "participates in"
    groups ||--|{ group_members : "has"
    users ||--o{ nicknames : "sets nickname for"
    groups ||--|{ nicknames : "are set in"
    users ||--o{ user_statuses : "has status"
    statuses ||--o{ user_statuses : "is status type of"
    users ||--o{ muted_notifications : "mutes"
    users ||--o{ subscriptions : "has subscription"
    users ||--o{ scheduled_events : "creates"
    groups ||--|{ scheduled_events : "are scheduled in"


```
</file>

<file path="docs/supabase-oauth-setup.md">
# Supabase Google OAuth Yapƒ±landƒ±rma Kƒ±lavuzu

## Hata: "invalid_client" veya "the OAuth client was not found"

Bu hata, Google Cloud Console'da OAuth client'ƒ±n d√ºzg√ºn yapƒ±landƒ±rƒ±lmadƒ±ƒüƒ±nƒ± veya Supabase'de yanlƒ±≈ü credentials kullanƒ±ldƒ±ƒüƒ±nƒ± g√∂sterir.

## √ñnemli: Firebase vs Supabase OAuth

Firebase'de olu≈üturduƒüunuz OAuth credentials'larƒ± Supabase'de de kullanabilirsiniz, √ß√ºnk√º ikisi de Google Cloud Console'u kullanƒ±r. 

**Firebase'in olu≈üturduƒüu OAuth client'larƒ±:**
- `google-services.json` dosyasƒ±nda `client_type: 3` olan client = **Web application** (Supabase i√ßin kullanƒ±labilir)
- Bu client'ƒ±n **Client ID**'si zaten var
- **Client Secret**'ƒ± Google Cloud Console'dan g√∂rebilir veya reset edebilirsiniz

**Neden Client Secret gerekli?**
- Firebase native SDK kullanƒ±r ‚Üí Secret gerektirmez (SHA-1 ile doƒürulanƒ±r)
- Supabase web-based OAuth kullanƒ±r ‚Üí Server-side doƒürulama i√ßin secret gerektirir
- Aynƒ± OAuth client'ƒ± kullanabilirsiniz, sadece secret'ƒ± eklemeniz gerekir

## Adƒ±m Adƒ±m Yapƒ±landƒ±rma

### 1. Mevcut Firebase OAuth Client'ƒ±nƒ± Kullanma (√ñnerilen)

Firebase'in olu≈üturduƒüu OAuth client'ƒ± kullanabilirsiniz! `google-services.json` dosyanƒ±zda `client_type: 3` olan Web client var.

**Se√ßenek A: Mevcut Web Client'ƒ±n Secret'ƒ±nƒ± G√∂rme/Reset Etme**

1. [Google Cloud Console](https://console.cloud.google.com/) ‚Üí `geliom-8d06f` projesini se√ßin
2. **APIs & Services** ‚Üí **Credentials**
3. OAuth 2.0 Client IDs listesinde **Web client** bulun (Client ID: `53336710716-ocrnuvqlpq02lvss0hvjgeqc08539sqm.apps.googleusercontent.com`)
4. Client'ƒ± tƒ±klayƒ±n
5. **Authorized redirect URIs** b√∂l√ºm√ºne ≈üunu ekleyin:
   ```
   https://jtqmntczxkdmftoqspdx.supabase.co/auth/v1/callback
   ```
6. **SAVE** butonuna tƒ±klayƒ±n
7. **Client Secret**'ƒ± g√∂rmek i√ßin:
   - Eƒüer secret g√∂sterilmiyorsa ‚Üí **RESET SECRET** butonuna tƒ±klayƒ±n
   - Yeni secret'ƒ± kopyalayƒ±n (sadece bir kez g√∂sterilir!)
   - **Dƒ∞KKAT**: Secret'ƒ± reset ederseniz, Firebase'deki mevcut kullanƒ±mlar etkilenmez (Firebase native SDK secret kullanmaz)

**Se√ßenek B: Yeni OAuth Client Olu≈üturma (ƒ∞sterseniz)**

1. [Google Cloud Console](https://console.cloud.google.com/) ‚Üí `geliom-8d06f` projesini se√ßin
2. **APIs & Services** ‚Üí **Credentials**
3. **Create Credentials** ‚Üí **OAuth client ID**
4. Application type: **Web application**
5. **Name**: "Supabase OAuth" (veya istediƒüiniz bir isim)
6. **Authorized redirect URIs** ekleyin:
   ```
   https://jtqmntczxkdmftoqspdx.supabase.co/auth/v1/callback
   ```
   **NOT**: `geliom://auth/callback` eklemeyin! Google Cloud Console Web application type'ƒ±nda sadece HTTPS URL'leri kabul eder.
7. **Create** butonuna tƒ±klayƒ±n
8. **√ñNEMLƒ∞**: A√ßƒ±lan popup'ta **Client ID** ve **Client Secret**'ƒ± hemen kopyalayƒ±n

### 2. Supabase Dashboard'da Google OAuth Ayarlama

1. [Supabase Dashboard](https://app.supabase.com/) ‚Üí Projenizi se√ßin
2. **Authentication** ‚Üí **Providers** ‚Üí **Google**
3. **Enable Google** toggle'ƒ±nƒ± a√ßƒ±n
4. **Client ID (for OAuth)** alanƒ±na Google'dan aldƒ±ƒüƒ±nƒ±z Client ID'yi yapƒ±≈ütƒ±rƒ±n
5. **Client Secret (for OAuth)** alanƒ±na Google'dan aldƒ±ƒüƒ±nƒ±z Client Secret'ƒ± yapƒ±≈ütƒ±rƒ±n
6. **Save** butonuna tƒ±klayƒ±n

### 3. Redirect URL'leri Kontrol Etme

Supabase Dashboard'da **Authentication** ‚Üí **URL Configuration** b√∂l√ºm√ºnde:

**Redirect URLs** listesine ≈üunlarƒ± ekleyin:
```
geliom://auth/callback
exp://127.0.0.1:8081/--/auth/callback
exp://localhost:8081/--/auth/callback
```

**Site URL** alanƒ±nƒ± da kontrol edin (genelde otomatik doldurulur).

### 4. Firebase Client ID'sini Kullanma

`google-services.json` dosyanƒ±zdaki mevcut Web client:
- **Client ID**: `53336710716-ocrnuvqlpq02lvss0hvjgeqc08539sqm.apps.googleusercontent.com`
- **Client Type**: 3 (Web application)
- Bu client'ƒ± Supabase'de kullanabilirsiniz!

**Yapmanƒ±z gerekenler:**
1. Google Cloud Console'da bu client'ƒ± bulun
2. Redirect URI ekleyin: `https://jtqmntczxkdmftoqspdx.supabase.co/auth/v1/callback`
3. Client Secret'ƒ± reset edin (eƒüer g√∂remiyorsanƒ±z)
4. Supabase Dashboard'a Client ID ve yeni Secret'ƒ± ekleyin

**√ñnemli:** Secret'ƒ± reset etmek Firebase'i etkilemez √ß√ºnk√º Firebase native SDK kullanƒ±r ve secret gerektirmez.

### 4. Test Etme

1. Uygulamayƒ± yeniden ba≈ülatƒ±n
2. Google ile giri≈ü yapmayƒ± deneyin
3. Artƒ±k Google OAuth sayfasƒ± a√ßƒ±lmalƒ±

## √ñnemli Notlar

- **Client Secret** mutlaka doƒüru girilmelidir
- **Redirect URI** Google Cloud Console'da tam olarak e≈üle≈ümelidir
- Supabase'deki redirect URL'ler uygulama scheme'inizi i√ßermelidir (`geliom://`)

## Sorun Giderme

### "invalid_client" veya "the OAuth client was not found" hatasƒ±:
1. **Google Cloud Console'da OAuth client'ƒ±n aktif olduƒüundan emin olun**
2. **Client ID'nin doƒüru kopyalandƒ±ƒüƒ±ndan emin olun** (bo≈üluk olmamalƒ±)
3. **Client Secret'ƒ±n doƒüru kopyalandƒ±ƒüƒ±ndan emin olun** (bo≈üluk olmamalƒ±)
4. **Redirect URI'nin Google Cloud Console'da ekli olduƒüundan emin olun:**
   ```
   https://jtqmntczxkdmftoqspdx.supabase.co/auth/v1/callback
   ```
5. Supabase Dashboard'da Google provider ayarlarƒ±nƒ± kontrol edin
6. Sayfayƒ± yenileyin ve tekrar deneyin

### "missing OAuth secret" hatasƒ±:
1. Supabase Dashboard'da Google provider ayarlarƒ±nƒ± kontrol edin
2. Client Secret alanƒ±nƒ±n dolu olduƒüundan emin olun
3. Eƒüer bo≈üsa, yeni bir OAuth client olu≈üturun ve secret'ƒ± kopyalayƒ±n

### Redirect hatasƒ± alƒ±yorsanƒ±z:
1. Google Cloud Console'da redirect URI'nin **tam olarak** e≈üle≈ütiƒüinden emin olun:
   - `https://jtqmntczxkdmftoqspdx.supabase.co/auth/v1/callback` (tam olarak bu ≈üekilde)
2. Supabase Dashboard'da redirect URL'lerin eklendiƒüinden emin olun
3. URL'lerde trailing slash olmamalƒ±

### Firebase ile Supabase Arasƒ±nda Payla≈üƒ±m:
- Aynƒ± Google Cloud projesini kullanƒ±yorsanƒ±z, aynƒ± OAuth credentials'larƒ± kullanabilirsiniz
- Ancak her ikisi i√ßin de redirect URI'larƒ± eklemeniz gerekir
- Firebase i√ßin: `https://YOUR_PROJECT.firebaseapp.com/__/auth/handler`
- Supabase i√ßin: `https://YOUR_PROJECT.supabase.co/auth/v1/callback`
</file>

<file path="docs/Theme-Typography-usage.md">
# Geliom - Theme & Typography Kullanƒ±m Kƒ±lavuzu

Geliom uygulamasƒ± i√ßin √∂zel olarak tasarlanmƒ±≈ü doƒüa temalƒ± renk paleti ve Comfortaa font ailesi ile typography sistemi.

## üé® Renk Paleti

### Doƒüa Temalƒ± Ye≈üil Tonlar

#### Light Theme
- **Primary**: `#2E7D32` (Orman ye≈üili)
- **Secondary**: `#4CAF50` (√áimen ye≈üili)  
- **Tertiary**: `#81C784` (A√ßƒ±k ye≈üil)
- **Background**: `#F1F8E9` (√áok a√ßƒ±k ye≈üil arkaplan)
- **Text**: `#1B5E20` (Koyu ye≈üil metin)

#### Dark Theme
- **Primary**: `#4CAF50` (Parlak ye≈üil)
- **Secondary**: `#66BB6A` (Orta ye≈üil)
- **Background**: `#0D1B0F` (√áok koyu ye≈üil arkaplan)
- **Text**: `#E8F5E8` (A√ßƒ±k ye≈üil metin)

### Kullanƒ±m
```tsx
import { useTheme } from '@/contexts/ThemeContext';

const { colors } = useTheme();

// Renkleri kullan
<View style={{ backgroundColor: colors.primary }}>
  <Text style={{ color: colors.text }}>Metin</Text>
</View>
```

## üî§ Typography Sistemi

### Comfortaa Font Ailesi
- **Light**: Comfortaa-Light
- **Regular**: Comfortaa-Regular  
- **Medium**: Comfortaa-Medium
- **SemiBold**: Comfortaa-SemiBold
- **Bold**: Comfortaa-Bold

### Typography Variants

#### Ba≈ülƒ±k Seviyeleri
- **h1**: 32px, Bold - Ana ba≈ülƒ±k (Geliom logo)
- **h2**: 28px, SemiBold - Sayfa ba≈ülƒ±klarƒ±
- **h3**: 24px, SemiBold - B√∂l√ºm ba≈ülƒ±klarƒ±
- **h4**: 20px, Medium - Alt ba≈ülƒ±klar
- **h5**: 18px, Medium - K√º√ß√ºk ba≈ülƒ±klar
- **h6**: 16px, Medium - Mini ba≈ülƒ±klar

#### G√∂vde Metinleri
- **body**: 16px, Regular - Ana metin
- **bodyLarge**: 18px, Regular - B√ºy√ºk g√∂vde metni
- **bodySmall**: 14px, Regular - K√º√ß√ºk g√∂vde metni

#### √ñzel Kullanƒ±mlar
- **button**: 16px, SemiBold - Buton metinleri
- **status**: 15px, Medium - Durum metinleri
- **nickname**: 16px, Medium - Takma isimler
- **groupName**: 18px, SemiBold - Grup isimleri
- **caption**: 12px, Regular - K√º√ß√ºk a√ßƒ±klamalar
- **label**: 14px, Medium - Form etiketleri

## üì± Typography Component Kullanƒ±mƒ±

### Basit Kullanƒ±m
```tsx
import { Typography } from '@/components/shared';

<Typography variant="h1">Ana Ba≈ülƒ±k</Typography>
<Typography variant="body">Normal metin</Typography>
<Typography variant="caption">K√º√ß√ºk a√ßƒ±klama</Typography>
```

### Renk ile Kullanƒ±m
```tsx
import { useTheme } from '@/contexts/ThemeContext';

const { colors } = useTheme();

<Typography variant="h2" color={colors.primary}>
  Ye≈üil Ba≈ülƒ±k
</Typography>

<Typography variant="body" color={colors.secondaryText}>
  ƒ∞kincil metin
</Typography>
```

### Font Weight Override
```tsx
<Typography variant="body" fontWeight="bold">
  Kalƒ±n metin
</Typography>

<Typography variant="h3" fontWeight="light">
  ƒ∞nce ba≈ülƒ±k
</Typography>
```

### Style Override
```tsx
<Typography 
  variant="body" 
  style={{ textAlign: 'center', marginBottom: 16 }}
>
  Ortalanmƒ±≈ü metin
</Typography>
```

## üéØ Geliom √ñzel Kullanƒ±mlarƒ±

### Ana Sayfa Ba≈ülƒ±ƒüƒ±
```tsx
<Typography variant="h1" color={colors.primary}>
  Geliom üåø
</Typography>
```

### Durum G√∂stergesi
```tsx
<Typography variant="status" color={colors.success}>
  üü¢ √áevrimi√ßi
</Typography>
```

### Grup ƒ∞simleri
```tsx
<Typography variant="groupName" color={colors.text}>
  Arkada≈ülar üë•
</Typography>
```

### Butonlar
```tsx
<TouchableOpacity style={{ backgroundColor: colors.primary }}>
  <Typography variant="button" color={colors.white}>
    Gruplarƒ±m
  </Typography>
</TouchableOpacity>
```

### Takma ƒ∞simler
```tsx
<Typography variant="nickname" color={colors.secondaryText}>
  @ahmet_dostum
</Typography>
```

## üé® Tema Deƒüi≈ütirme

```tsx
import { useTheme } from '@/contexts/ThemeContext';

const { isDark, toggleTheme } = useTheme();

<TouchableOpacity onPress={toggleTheme}>
  <Ionicons 
    name={isDark ? "sunny" : "moon"} 
    size={24} 
    color={colors.text} 
  />
</TouchableOpacity>
```

## üìè Spacing ve Layout

### √ñnerilen Spacing Deƒüerleri
```tsx
const spacing = {
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32,
  xxl: 48,
};
```

### √ñnerilen Border Radius
```tsx
const borderRadius = {
  sm: 8,
  md: 12,
  lg: 16,
  xl: 20,
  full: 9999,
};
```

## üåü Best Practices

1. **Tutarlƒ±lƒ±k**: Her zaman Typography component'ini kullanƒ±n
2. **Renk Uyumu**: Theme colors'ƒ± kullanarak tutarlƒ± renk paleti saƒülayƒ±n
3. **Okunabilirlik**: Uygun contrast oranlarƒ±na dikkat edin
4. **Responsive**: Farklƒ± ekran boyutlarƒ± i√ßin test edin
5. **Accessibility**: Screen reader uyumluluƒüunu saƒülayƒ±n

## üîß √ñzelle≈ütirme

### Yeni Variant Ekleme
```tsx
// theme/typography.ts
export type TypographyKeys = {
  // ... mevcut variants
  customVariant: TypographyVariant;
};

export const typography: TypographyKeys = {
  // ... mevcut variants
  customVariant: {
    fontSize: 20,
    lineHeight: 28,
    defaultFontWeight: 'medium',
    letterSpacing: 0,
  },
};
```

### Yeni Renk Ekleme
```tsx
// theme/colors.ts
export const lightColors = {
  // ... mevcut renkler
  customColor: '#YOUR_COLOR',
};
```

Bu sistem Geliom'un doƒüal, samimi ve kullanƒ±cƒ± dostu hissini desteklemek i√ßin √∂zel olarak tasarlanmƒ±≈ütƒ±r. üåø
</file>

<file path="hooks/useNetworkStatus.ts">
import NetInfo, { NetInfoState } from '@react-native-community/netinfo';
import { useEffect, useState } from 'react';

export type NetworkStatus = 'online' | 'offline' | 'weak';

export interface NetworkState {
  isConnected: boolean | null;
  isInternetReachable: boolean | null;
  status: NetworkStatus;
  type: string | null;
}

export interface NetworkStatusHook {
  isOnline: boolean;
  isOffline: boolean;
  isWeak: boolean;
  status: NetworkStatus;
  checkConnection: () => Promise<NetworkStatus>;
  networkState: NetworkState;
}

const WEAK_CONNECTION_THRESHOLD = 2; // Mbps

export const useNetworkStatus = (): NetworkStatusHook => {
  const [networkState, setNetworkState] = useState<NetworkState>({
    isConnected: null,
    isInternetReachable: null,
    status: 'online',
    type: null,
  });

  const determineNetworkStatus = (state: NetInfoState): NetworkStatus => {
    // Baƒülantƒ± yoksa
    if (!state.isConnected || state.isInternetReachable === false) {
      return 'offline';
    }

    // Baƒülantƒ± var - hƒ±z kontrol√º
    if (state.details) {
      const details = state.details as any;
      
      // Cellular i√ßin
      if (state.type === 'cellular' && details.cellularGeneration) {
        // 2G zayƒ±f kabul edilir
        if (details.cellularGeneration === '2g') {
          return 'weak';
        }
      }

      // WiFi i√ßin (eƒüer effectiveConnectionType varsa)
      if (details.effectiveConnectionType) {
        const effectiveType = details.effectiveConnectionType;
        // slow-2g veya 2g zayƒ±f kabul edilir
        if (effectiveType === 'slow-2g' || effectiveType === '2g') {
          return 'weak';
        }
      }
    }

    return 'online';
  };

  const checkConnection = async (): Promise<NetworkStatus> => {
    try {
      const state = await NetInfo.fetch();
      const status = determineNetworkStatus(state);

      setNetworkState({
        isConnected: state.isConnected,
        isInternetReachable: state.isInternetReachable,
        status,
        type: state.type,
      });

      return status;
    } catch (error) {
      console.error('Network check failed:', error);
      return 'offline';
    }
  };

  useEffect(() => {
    // ƒ∞lk durumu kontrol et
    checkConnection();

    // Network deƒüi≈üikliklerini dinle
    const unsubscribe = NetInfo.addEventListener((state) => {
      const status = determineNetworkStatus(state);

      setNetworkState({
        isConnected: state.isConnected,
        isInternetReachable: state.isInternetReachable,
        status,
        type: state.type,
      });
    });

    return () => {
      unsubscribe();
    };
  }, []);

  return {
    isOnline: networkState.status === 'online',
    isOffline: networkState.status === 'offline',
    isWeak: networkState.status === 'weak',
    status: networkState.status,
    checkConnection,
    networkState,
  };
};
</file>

<file path="types/auth.ts">
/**
 * Auth Provider Types
 * Apple ve Google OAuth provider'larƒ±ndan gelen farklƒ± formatlarƒ± normalize eder
 */

export type AuthProvider = 'apple' | 'google';

/**
 * Normalized User Data
 * Apple ve Google'dan gelen farklƒ± formatlarƒ± tek bir formata √ßevirir
 * custom_user_id YOK - Supabase auth.users UUID direkt kullanƒ±lƒ±r
 */
export interface NormalizedUserData {
  id: string; // UUID - Supabase auth.users'dan
  email: string | null;
  displayName: string | null;
  photoUrl: string | null;
  provider: AuthProvider;
}

/**
 * Supabase User objesinden normalized data √ßƒ±karma i√ßin helper type
 */
export interface SupabaseUserMetadata {
  full_name?: string;
  name?: string;
  avatar_url?: string;
  picture?: string;
  email?: string;
}

/**
 * Auth Error Types
 */
export type AuthErrorCode =
  | 'NETWORK_ERROR'
  | 'CANCELLED'
  | 'INVALID_TOKEN'
  | 'PROVIDER_ERROR'
  | 'UNKNOWN_ERROR';

export interface AuthError {
  code: AuthErrorCode;
  message: string;
  originalError?: unknown;
}
</file>

<file path=".gitignore">
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts


# Native
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

app-example

# generated native folders
/ios
/android


# for repomix
/app/(drawer)/api-test.tsx
/docs/Green-Color-Palette.md
</file>

<file path="eas.json">
{
  "cli": {
    "version": ">= 16.26.0",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "distribution": "internal"
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}
</file>

<file path="eslint.config.js">
// https://docs.expo.dev/guides/using-eslint/
const { defineConfig } = require('eslint/config');
const expoConfig = require('eslint-config-expo/flat');

module.exports = defineConfig([
  expoConfig,
  {
    ignores: ['dist/*'],
  },
]);
</file>

<file path="google-services.json">
{
  "project_info": {
    "project_number": "53336710716",
    "project_id": "geliom-8d06f",
    "storage_bucket": "geliom-8d06f.firebasestorage.app"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:53336710716:android:3299f86178a303588c2d39",
        "android_client_info": {
          "package_name": "com.eoist.geliom"
        }
      },
      "oauth_client": [
        {
          "client_id": "53336710716-a6u8baf8pmvppr9vmhkv5rv8l8e8nti0.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "com.eoist.geliom",
            "certificate_hash": "610e3c94225cea2c04de558b63a847d751fc1664"
          }
        },
        {
          "client_id": "53336710716-ocrnuvqlpq02lvss0hvjgeqc08539sqm.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCSighX37jvoaj6gFSbfZvw4N9_wJbrwaY"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "53336710716-ocrnuvqlpq02lvss0hvjgeqc08539sqm.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "53336710716-ldovpft6789mdmqr2jflh3ugrbuagbom.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.eoist.geliom",
                "app_store_id": "6754461885"
              }
            }
          ]
        }
      }
    }
  ],
  "configuration_version": "1"
}
</file>

<file path="GoogleService-Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CLIENT_ID</key>
	<string>53336710716-ldovpft6789mdmqr2jflh3ugrbuagbom.apps.googleusercontent.com</string>
	<key>REVERSED_CLIENT_ID</key>
	<string>com.googleusercontent.apps.53336710716-ldovpft6789mdmqr2jflh3ugrbuagbom</string>
	<key>ANDROID_CLIENT_ID</key>
	<string>53336710716-a6u8baf8pmvppr9vmhkv5rv8l8e8nti0.apps.googleusercontent.com</string>
	<key>API_KEY</key>
	<string>AIzaSyDS7_WSCWuUuo2Z7EIMqIRvfVCf2FnlhOA</string>
	<key>GCM_SENDER_ID</key>
	<string>53336710716</string>
	<key>PLIST_VERSION</key>
	<string>1</string>
	<key>BUNDLE_ID</key>
	<string>com.eoist.geliom</string>
	<key>PROJECT_ID</key>
	<string>geliom-8d06f</string>
	<key>STORAGE_BUCKET</key>
	<string>geliom-8d06f.firebasestorage.app</string>
	<key>IS_ADS_ENABLED</key>
	<false></false>
	<key>IS_ANALYTICS_ENABLED</key>
	<false></false>
	<key>IS_APPINVITE_ENABLED</key>
	<true></true>
	<key>IS_GCM_ENABLED</key>
	<true></true>
	<key>IS_SIGNIN_ENABLED</key>
	<true></true>
	<key>GOOGLE_APP_ID</key>
	<string>1:53336710716:ios:5995bcbacb0c1d788c2d39</string>
</dict>
</plist>
</file>

<file path="tsconfig.json">
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}
</file>

<file path=".cursor/rules/generally.mdc">
---
alwaysApply: true
---

**rule** never use shadow
**rule** everytime use Stylesheet
**rule** use must use shared component firstly
**rule** every constant value should be in constant folder
**rule** if neccassery create component but if already have same component use it.
</file>

<file path="api/moods.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import React from 'react';
import type {
  CreateMood,
  CreateUserGroupMood,
  Mood,
  UpdateMood,
  UserGroupMood,
  UserGroupMoodWithMood
} from '../types/database';
import { supabase } from './supabase';

// Query Keys
export const moodKeys = {
  all: ['moods'] as const,
  lists: () => [...moodKeys.all, 'list'] as const,
  list: (filters: string) => [...moodKeys.lists(), { filters }] as const,
  details: () => [...moodKeys.all, 'detail'] as const,
  detail: (id: number) => [...moodKeys.details(), id] as const,
};

export const userGroupMoodKeys = {
  all: ['user-group-moods'] as const,
  user: (userId: string, groupId?: string) => [...userGroupMoodKeys.all, 'user', userId, groupId || 'global'] as const,
  group: (groupId: string) => [...userGroupMoodKeys.all, 'group', groupId] as const,
};

// Queries
export const useMoods = () => {
  return useQuery({
    queryKey: moodKeys.lists(),
    queryFn: async (): Promise<Mood[]> => {
      const { data, error } = await supabase
        .from('moods')
        .select('*')
        .order('text');
      
      if (error) throw error;
      return data || [];
    },
  });
};

export const useMood = (id: number) => {
  return useQuery({
    queryKey: moodKeys.detail(id),
    queryFn: async (): Promise<Mood | null> => {
      const { data, error } = await supabase
        .from('moods')
        .select('*')
        .eq('id', id)
        .single();
      
      if (error) throw error;
      return data;
    },
    enabled: !!id,
  });
};

export const useMoodByText = (text: string) => {
  return useQuery({
    queryKey: [...moodKeys.lists(), { text }],
    queryFn: async (): Promise<Mood | null> => {
      const { data, error } = await supabase
        .from('moods')
        .select('*')
        .eq('text', text)
        .single();
      
      if (error) throw error;
      return data;
    },
    enabled: !!text,
  });
};

// Mutations
export const useCreateMood = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (moodData: CreateMood): Promise<Mood> => {
      const { data, error } = await supabase
        .from('moods')
        .insert(moodData)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: moodKeys.all });
    },
  });
};

export const useUpdateMood = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ id, updates }: { id: number; updates: UpdateMood }): Promise<Mood> => {
      const { data, error } = await supabase
        .from('moods')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: moodKeys.all });
      queryClient.invalidateQueries({ queryKey: moodKeys.detail(data.id) });
    },
  });
};

export const useDeleteMood = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (id: number): Promise<void> => {
      const { error } = await supabase
        .from('moods')
        .delete()
        .eq('id', id);
      
      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: moodKeys.all });
    },
  });
};

// User Group Mood Queries
export const useUserGroupMood = (userId: string, groupId?: string) => {
  return useQuery({
    queryKey: userGroupMoodKeys.user(userId, groupId),
    queryFn: async (): Promise<UserGroupMoodWithMood | null> => {
      let query = supabase
        .from('user_group_moods')
        .select(`
          *,
          mood:moods(*)
        `)
        .eq('user_id', userId);
      
      // group_id filtresi: NULL ise global, deƒüilse spesifik grup
      if (groupId) {
        query = query.eq('group_id', groupId);
      } else {
        query = query.is('group_id', null);
      }
      
      const { data, error } = await query.single();
      
      if (error && error.code !== 'PGRST116') throw error;
      return data || null;
    },
    enabled: !!userId,
  });
};

// Se√ßili grup i√ßin t√ºm kullanƒ±cƒ±larƒ±n mood'larƒ±
export const useGroupUserMoods = (groupId: string) => {
  return useQuery({
    queryKey: userGroupMoodKeys.group(groupId),
    queryFn: async (): Promise<UserGroupMoodWithMood[]> => {
      console.log('üì• Fetching group user moods for group:', groupId);
      // Se√ßili grup i√ßin mood'lar + global mood'lar (group_id IS NULL)
      const { data, error } = await supabase
        .from('user_group_moods')
        .select(`
          *,
          mood:moods(*),
          user:users(*)
        `)
        .or(`group_id.eq.${groupId},group_id.is.null`)
        .order('updated_at', { ascending: false });
      
      if (error) throw error;
      console.log('‚úÖ Fetched group user moods:', data?.length || 0, 'moods');
      return data || [];
    },
    enabled: !!groupId,
    // Realtime updates i√ßin refetch ayarlarƒ±
    refetchOnMount: true,
    refetchOnWindowFocus: false, // Realtime ile g√ºncellendiƒüi i√ßin window focus'ta refetch gerekmez
    staleTime: 0, // Her zaman fresh data iste (realtime i√ßin √∂nemli)
  });
};

// User Group Mood Mutations
export const useSetUserGroupMood = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (userGroupMoodData: CreateUserGroupMood): Promise<UserGroupMood> => {
      // Composite key i√ßin upsert: user_id ve group_id
      const conflictColumns = userGroupMoodData.group_id 
        ? 'user_id,group_id' 
        : 'user_id';
      
      const { data, error } = await supabase
        .from('user_group_moods')
        .upsert(userGroupMoodData, {
          onConflict: conflictColumns
        })
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: userGroupMoodKeys.all });
      queryClient.invalidateQueries({ queryKey: userGroupMoodKeys.user(data.user_id, data.group_id) });
      if (data.group_id) {
        queryClient.invalidateQueries({ queryKey: userGroupMoodKeys.group(data.group_id) });
      }
    },
  });
};

export const useRemoveUserGroupMood = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ userId, groupId }: { userId: string; groupId?: string }): Promise<void> => {
      let query = supabase
        .from('user_group_moods')
        .delete()
        .eq('user_id', userId);
      
      if (groupId) {
        query = query.eq('group_id', groupId);
      } else {
        query = query.is('group_id', null);
      }
      
      const { error } = await query;
      
      if (error) throw error;
    },
    onSuccess: (_, { userId, groupId }) => {
      queryClient.invalidateQueries({ queryKey: userGroupMoodKeys.all });
      queryClient.invalidateQueries({ queryKey: userGroupMoodKeys.user(userId, groupId) });
      if (groupId) {
        queryClient.invalidateQueries({ queryKey: userGroupMoodKeys.group(groupId) });
      }
    },
  });
};

// Realtime Subscription Hooks
export const useMoodsRealtime = () => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['moods-realtime'],
    queryFn: () => {
      const channel = supabase
        .channel('moods-changes')
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'moods',
          },
          () => {
            queryClient.invalidateQueries({ queryKey: moodKeys.all });
          }
        )
        .subscribe();

      return channel;
    },
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};

// Se√ßili grup i√ßin realtime subscription
export const useGroupMoodsRealtime = (groupId: string) => {
  const queryClient = useQueryClient();

  React.useEffect(() => {
    if (!groupId) {
      console.log('‚ö†Ô∏è useGroupMoodsRealtime: groupId yok, subscription kurulmuyor');
      return;
    }

    console.log('üîå Setting up realtime subscription for moods, group:', groupId);
    const channelName = `group-moods-changes-${groupId}`;
    const channel = supabase
      .channel(channelName)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'user_group_moods',
          filter: `group_id=eq.${groupId}`,
        },
        (payload) => {
          console.log('üîÑ Realtime mood update (group):', payload);
          console.log('üîë Invalidating query key:', userGroupMoodKeys.group(groupId));
          // √ñnce invalidate et, sonra refetch et
          queryClient.invalidateQueries({ 
            queryKey: userGroupMoodKeys.group(groupId),
            refetchType: 'active' 
          });
          // Refetch'i zorla
          queryClient.refetchQueries({ 
            queryKey: userGroupMoodKeys.group(groupId),
          });
          queryClient.invalidateQueries({ 
            queryKey: userGroupMoodKeys.all,
            refetchType: 'active' 
          });
        }
      )
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'user_group_moods',
          filter: 'group_id=is.null', // Global mood'lar da dinlenmeli
        },
        (payload) => {
          console.log('üîÑ Realtime mood update (global):', payload);
          console.log('üîë Invalidating query key:', userGroupMoodKeys.group(groupId));
          // √ñnce invalidate et, sonra refetch et
          queryClient.invalidateQueries({ 
            queryKey: userGroupMoodKeys.group(groupId),
            refetchType: 'active' 
          });
          // Refetch'i zorla
          queryClient.refetchQueries({ 
            queryKey: userGroupMoodKeys.group(groupId),
          });
          queryClient.invalidateQueries({ 
            queryKey: userGroupMoodKeys.all,
            refetchType: 'active' 
          });
        }
      )
      .subscribe((status, err) => {
        console.log('üì° Realtime subscription status (moods):', status, err);
        if (status === 'SUBSCRIBED') {
          console.log('‚úÖ Realtime subscription ba≈üarƒ±yla kuruldu:', channelName);
        } else if (status === 'CHANNEL_ERROR') {
          console.error('‚ùå Realtime subscription hatasƒ±:', err);
        } else if (status === 'TIMED_OUT') {
          console.error('‚è±Ô∏è Realtime subscription timeout:', channelName);
        } else if (status === 'CLOSED') {
          console.warn('‚ö†Ô∏è Realtime subscription kapandƒ±:', channelName);
        }
      });

    return () => {
      console.log('üîå Unsubscribing from mood changes for group:', groupId);
      supabase.removeChannel(channel);
    };
  }, [groupId, queryClient]);
};
</file>

<file path="api/provider-auth.ts">
import type { User } from '@supabase/supabase-js';
import * as AppleAuthentication from 'expo-apple-authentication';
import * as AuthSession from 'expo-auth-session';
import Constants from 'expo-constants';
import * as WebBrowser from 'expo-web-browser';
import { Platform } from 'react-native';
import type {
  AuthError,
  AuthProvider,
  NormalizedUserData,
  SupabaseUserMetadata
} from '../types/auth';
import type { UpdateUser } from '../types/database';
import { supabase } from './supabase';

// WebBrowser'ƒ± kapatmak i√ßin
WebBrowser.maybeCompleteAuthSession();

/**
 * OAuth Redirect URL
 * app.json'daki scheme kullanƒ±lƒ±r: geliom://
 */
const REDIRECT_URL = AuthSession.makeRedirectUri({
  scheme: 'geliom',
  path: 'auth/callback',
});

/**
 * Google ile giri≈ü yap
 * Supabase OAuth kullanarak Google authentication
 */
export async function signInWithGoogle(): Promise<{ error: AuthError | null }> {
  try {
    console.log('üîµ signInWithGoogle ba≈ülatƒ±lƒ±yor...');
    console.log('üîµ Redirect URL:', REDIRECT_URL);

    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: 'google',
      options: {
        redirectTo: REDIRECT_URL,
        queryParams: {
          access_type: 'offline',
          prompt: 'consent',
        },
      },
    });

    console.log('üîµ OAuth response - data:', data);
    console.log('üîµ OAuth response - error:', error);

    if (error) {
      console.error('‚ùå OAuth error:', error);
      return {
        error: {
          code: 'PROVIDER_ERROR',
          message: error.message,
          originalError: error,
        },
      };
    }

    if (!data?.url) {
      console.error('‚ùå OAuth URL alƒ±namadƒ±');
      return {
        error: {
          code: 'PROVIDER_ERROR',
          message: 'OAuth URL alƒ±namadƒ±',
        },
      };
    }

    console.log('‚úÖ OAuth URL alƒ±ndƒ±, web browser a√ßƒ±lƒ±yor:', data.url);

    // Web browser'da OAuth URL'ini a√ß
    const result = await WebBrowser.openAuthSessionAsync(
      data.url,
      REDIRECT_URL
    );

    console.log('üîµ WebBrowser result:', result);

    if (result.type === 'cancel') {
      console.log('‚ÑπÔ∏è Kullanƒ±cƒ± OAuth i≈ülemini iptal etti');
      return {
        error: {
          code: 'CANCELLED',
          message: 'Giri≈ü iptal edildi',
        },
      };
    }

    if (result.type === 'success' && result.url) {
      console.log('‚úÖ OAuth callback URL alƒ±ndƒ±:', result.url);

      // URL'den hash fragment'i √ßƒ±kar (React Native'de query params yerine hash kullanƒ±lƒ±r)
      const hashParams = new URLSearchParams(result.url.split('#')[1] || '');
      const accessToken = hashParams.get('access_token');
      const refreshToken = hashParams.get('refresh_token');

      console.log('üîµ Access token var mƒ±:', !!accessToken);
      console.log('üîµ Refresh token var mƒ±:', !!refreshToken);

      if (accessToken && refreshToken) {
        console.log('‚úÖ Tokens alƒ±ndƒ±, session olu≈üturuluyor...');
        console.log('üîµ Access token (ilk 20 karakter):', accessToken.substring(0, 20));
        console.log('üîµ Refresh token (ilk 20 karakter):', refreshToken.substring(0, 20));

        try {
          // Session'ƒ± set et
          const { data: sessionData, error: sessionError } = await supabase.auth.setSession({
            access_token: accessToken,
            refresh_token: refreshToken,
          });

          if (sessionError) {
            console.error('‚ùå Session olu≈üturma hatasƒ±:', sessionError);
            console.error('‚ùå Session error code:', sessionError.code);
            console.error('‚ùå Session error message:', sessionError.message);
            return {
              error: {
                code: 'PROVIDER_ERROR',
                message: sessionError.message,
                originalError: sessionError,
              },
            };
          }

          if (!sessionData?.session) {
            console.error('‚ùå Session data yok!');
            return {
              error: {
                code: 'PROVIDER_ERROR',
                message: 'Session olu≈üturulamadƒ± - session data yok',
              },
            };
          }

          console.log('‚úÖ Session ba≈üarƒ±yla olu≈üturuldu');
          console.log('‚úÖ Session user:', sessionData.session.user?.email);
          console.log('‚úÖ Session expires at:', sessionData.session.expires_at);

          // Session'ƒ±n ger√ßekten set edildiƒüini doƒürula (polling, max 3 saniye)
          const maxWaitTime = 3000; // 3 saniye
          const pollInterval = 100; // 100ms
          const startTime = Date.now();
          let verified = false;

          while (Date.now() - startTime < maxWaitTime && !verified) {
            const { data: { session: verifySession }, error: verifyError } = await supabase.auth.getSession();

            if (verifySession && verifySession.user?.id === sessionData.session.user?.id) {
              console.log('‚úÖ Session doƒürulandƒ±, user:', verifySession.user?.email);
              verified = true;
              break;
            }

            if (verifyError) {
              console.error('‚ùå Session doƒürulama hatasƒ±:', verifyError);
            }

            // Bir sonraki kontrol i√ßin bekle
            await new Promise(resolve => setTimeout(resolve, pollInterval));
          }

          if (!verified) {
            console.error('‚ùå Session doƒürulanamadƒ± - timeout');
            return {
              error: {
                code: 'PROVIDER_ERROR',
                message: 'Session doƒürulanamadƒ±. L√ºtfen tekrar deneyin.',
              },
            };
          }

          // Auth state change listener otomatik tetiklenecek
          return { error: null };
        } catch (error) {
          console.error('‚ùå setSession exception:', error);
          return {
            error: {
              code: 'PROVIDER_ERROR',
              message: 'Session olu≈üturulurken hata olu≈ütu',
              originalError: error,
            },
          };
        }
      } else {
        // Eƒüer hash'te yoksa, query params'ta olabilir
        const queryParams = new URLSearchParams(result.url.split('?')[1]?.split('#')[0] || '');
        const queryAccessToken = queryParams.get('access_token');
        const queryRefreshToken = queryParams.get('refresh_token');

        if (queryAccessToken && queryRefreshToken) {
          console.log('‚úÖ Tokens query params\'tan alƒ±ndƒ±, session olu≈üturuluyor...');

          const { data: sessionData, error: sessionError } = await supabase.auth.setSession({
            access_token: queryAccessToken,
            refresh_token: queryRefreshToken,
          });

          if (sessionError) {
            console.error('‚ùå Session olu≈üturma hatasƒ±:', sessionError);
            return {
              error: {
                code: 'PROVIDER_ERROR',
                message: sessionError.message,
                originalError: sessionError,
              },
            };
          }

          if (!sessionData?.session) {
            console.error('‚ùå Session data yok!');
            return {
              error: {
                code: 'PROVIDER_ERROR',
                message: 'Session olu≈üturulamadƒ± - session data yok',
              },
            };
          }

          console.log('‚úÖ Session ba≈üarƒ±yla olu≈üturuldu');
          console.log('‚úÖ Session user:', sessionData.session.user?.email);

          // Session'ƒ±n ger√ßekten set edildiƒüini doƒürula (polling, max 3 saniye)
          const maxWaitTime = 3000; // 3 saniye
          const pollInterval = 100; // 100ms
          const startTime = Date.now();
          let verified = false;

          while (Date.now() - startTime < maxWaitTime && !verified) {
            const { data: { session: verifySession }, error: verifyError } = await supabase.auth.getSession();

            if (verifySession && verifySession.user?.id === sessionData.session.user?.id) {
              console.log('‚úÖ Session doƒürulandƒ±, user:', verifySession.user?.email);
              verified = true;
              break;
            }

            if (verifyError) {
              console.error('‚ùå Session doƒürulama hatasƒ±:', verifyError);
            }

            // Bir sonraki kontrol i√ßin bekle
            await new Promise(resolve => setTimeout(resolve, pollInterval));
          }

          if (!verified) {
            console.error('‚ùå Session doƒürulanamadƒ± - timeout');
            return {
              error: {
                code: 'PROVIDER_ERROR',
                message: 'Session doƒürulanamadƒ±. L√ºtfen tekrar deneyin.',
              },
            };
          }

          return { error: null };
        }

        console.error('‚ùå Tokens bulunamadƒ±. URL:', result.url);
        return {
          error: {
            code: 'PROVIDER_ERROR',
            message: 'OAuth token\'larƒ± alƒ±namadƒ±',
          },
        };
      }
    }

    console.error('‚ùå Beklenmeyen OAuth sonucu:', result);
    return {
      error: {
        code: 'UNKNOWN_ERROR',
        message: 'OAuth i≈ülemi tamamlanamadƒ±',
      },
    };
  } catch (error) {
    console.error('‚ùå signInWithGoogle exception:', error);
    return {
      error: {
        code: 'UNKNOWN_ERROR',
        message: 'Google ile giri≈ü yapƒ±lamadƒ±',
        originalError: error,
      },
    };
  }
}

/**
 * Apple ile giri≈ü yap
 * Native Apple Sign In kullanarak (sadece iOS)
 */
export async function signInWithApple(): Promise<{ error: AuthError | null }> {
  // Sadece iOS'ta √ßalƒ±≈üƒ±r
  if (Platform.OS !== 'ios') {
    return {
      error: {
        code: 'PROVIDER_ERROR',
        message: 'Apple Sign In sadece iOS cihazlarda kullanƒ±labilir',
      },
    };
  }

  try {
    // Apple native authentication
    const credential = await AppleAuthentication.signInAsync({
      requestedScopes: [
        AppleAuthentication.AppleAuthenticationScope.FULL_NAME,
        AppleAuthentication.AppleAuthenticationScope.EMAIL,
      ],
    });

    if (!credential.identityToken) {
      return {
        error: {
          code: 'INVALID_TOKEN',
          message: 'Apple identity token alƒ±namadƒ±',
        },
      };
    }

    // Bundle identifier'ƒ± al (Supabase Apple provider client_id olarak kullanƒ±lƒ±r)
    const bundleIdentifier = Constants.expoConfig?.ios?.bundleIdentifier || 'com.eoist.geliom';

    console.log('üçé Apple login - Bundle identifier:', bundleIdentifier);
    console.log('üçé Apple login - Identity token alƒ±ndƒ±');

    // Supabase'e identity token ile giri≈ü yap
    // client_id parametresi, Supabase'deki Apple provider'ƒ±n Service ID'si ile e≈üle≈ümeli
    const { data, error } = await supabase.auth.signInWithIdToken({
      provider: 'apple',
      token: credential.identityToken,
      // client_id: bundleIdentifier, // Supabase'in signInWithIdToken'ƒ± client_id'yi desteklemiyor
      // Bunun yerine Supabase dashboard'da Apple provider'ƒ±n Service ID'si bundle identifier ile e≈üle≈ümeli
    });

    if (error) {
      // "Unacceptable audience" hatasƒ± genellikle Expo Go kullanƒ±mƒ±ndan veya Supabase yapƒ±landƒ±rmasƒ±ndan kaynaklanƒ±r
      let errorMessage = error.message;

      if (error.message?.includes('Unacceptable audience') || error.message?.includes('audience')) {
        errorMessage = `Apple login hatasƒ±: Token audience uyumsuzluƒüu. 
        
Bu hata genellikle ≈üu durumlardan kaynaklanƒ±r:
1. Expo Go kullanƒ±yorsanƒ±z, development build kullanmanƒ±z gerekiyor
2. Supabase dashboard'da Apple provider'ƒ±n Service ID'si "${bundleIdentifier}" ile e≈üle≈ümeli
3. Apple Developer Console'da Service ID'nin bundle identifier'ƒ± "${bundleIdentifier}" olmalƒ±

L√ºtfen Supabase dashboard'da Apple provider ayarlarƒ±nƒ± kontrol edin.`;
      }

      console.error('‚ùå Apple sign in error:', error);
      console.error('‚ùå Bundle identifier:', bundleIdentifier);

      return {
        error: {
          code: 'PROVIDER_ERROR',
          message: errorMessage,
          originalError: error,
        },
      };
    }

    if (!data?.session) {
      console.error('‚ùå Apple sign in: Session data yok!');
      return {
        error: {
          code: 'PROVIDER_ERROR',
          message: 'Session olu≈üturulamadƒ± - session data yok',
        },
      };
    }

    console.log('‚úÖ Apple sign in: Session ba≈üarƒ±yla olu≈üturuldu');
    console.log('‚úÖ Session user:', data.session.user?.email);

    // Session'ƒ±n ger√ßekten set edildiƒüini doƒürula (polling, max 3 saniye)
    const maxWaitTime = 3000; // 3 saniye
    const pollInterval = 100; // 100ms
    const startTime = Date.now();
    let verified = false;

    while (Date.now() - startTime < maxWaitTime && !verified) {
      const { data: { session: verifySession }, error: verifyError } = await supabase.auth.getSession();

      if (verifySession && verifySession.user?.id === data.session.user?.id) {
        console.log('‚úÖ Apple sign in: Session doƒürulandƒ±, user:', verifySession.user?.email);
        verified = true;
        break;
      }

      if (verifyError) {
        console.error('‚ùå Apple sign in: Session doƒürulama hatasƒ±:', verifyError);
      }

      // Bir sonraki kontrol i√ßin bekle
      await new Promise(resolve => setTimeout(resolve, pollInterval));
    }

    if (!verified) {
      console.error('‚ùå Apple sign in: Session doƒürulanamadƒ± - timeout');
      return {
        error: {
          code: 'PROVIDER_ERROR',
          message: 'Session doƒürulanamadƒ±. L√ºtfen tekrar deneyin.',
        },
      };
    }

    return { error: null };
  } catch (error: any) {
    // Kullanƒ±cƒ± iptal etti
    if (error.code === 'ERR_REQUEST_CANCELED') {
      return {
        error: {
          code: 'CANCELLED',
          message: 'Giri≈ü iptal edildi',
          originalError: error,
        },
      };
    }

    return {
      error: {
        code: 'UNKNOWN_ERROR',
        message: 'Apple ile giri≈ü yapƒ±lamadƒ±',
        originalError: error,
      },
    };
  }
}

/**
 * Supabase User objesinden normalized data √ßƒ±kar
 * Apple ve Google metadata farklarƒ±nƒ± handle eder
 */
export function normalizeUserData(
  supabaseUser: User,
  provider: AuthProvider
): NormalizedUserData {
  const metadata = supabaseUser.user_metadata as SupabaseUserMetadata;
  const appMetadata = supabaseUser.app_metadata || {};

  // Display name: full_name, name veya email'den extract
  let displayName: string | null = null;
  if (metadata?.full_name) {
    displayName = metadata.full_name;
  } else if (metadata?.name) {
    displayName = metadata.name;
  } else if (supabaseUser.email) {
    // Email'den kullanƒ±cƒ± adƒ± √ßƒ±kar (√∂rn: hakan@gmail.com -> hakan)
    displayName = supabaseUser.email.split('@')[0];
  }

  // Photo URL: avatar_url veya picture
  const photoUrl: string | null =
    metadata?.avatar_url || metadata?.picture || null;

  return {
    id: supabaseUser.id, // UUID - Supabase auth.users'dan
    email: supabaseUser.email || null,
    displayName: displayName || null,
    photoUrl: photoUrl || null,
    provider,
  };
}

/**
 * Kullanƒ±cƒ± profilini olu≈ütur veya g√ºncelle
 * NOT: custom_user_id database trigger/function tarafƒ±ndan otomatik olu≈üturulur
 * Bu fonksiyon sadece email ve diƒüer profil bilgilerini g√ºnceller
 */
export async function createOrUpdateUserProfile(
  normalizedData: NormalizedUserData
): Promise<{ data: any | null; error: AuthError | null }> {
  try {
    console.log('üîµ createOrUpdateUserProfile ba≈ülatƒ±ldƒ±, user ID:', normalizedData.id);

    // Database trigger anƒ±nda √ßalƒ±≈ütƒ±ƒüƒ± i√ßin kullanƒ±cƒ± zaten olu≈üturulmu≈ü olmalƒ±
    // Sadece profil bilgilerini g√ºncelle
    const updateData: UpdateUser = {
      email: normalizedData.email ?? undefined,
      display_name: normalizedData.displayName ?? undefined,
      photo_url: normalizedData.photoUrl ?? undefined,
      // custom_user_id g√ºncellenmez - database trigger tarafƒ±ndan olu≈üturulur
    };

    // Sadece undefined olmayan alanlarƒ± g√ºncelle
    const filteredUpdateData: UpdateUser = Object.fromEntries(
      Object.entries(updateData).filter(([_, value]) => value !== undefined)
    ) as UpdateUser;

    if (Object.keys(filteredUpdateData).length === 0) {
      console.log('‚ÑπÔ∏è G√ºncellenecek alan yok, mevcut profili getir...');
      // G√ºncellenecek alan yoksa mevcut profili getir
      const { data: existingUser, error: fetchError } = await supabase
        .from('users')
        .select('*')
        .eq('id', normalizedData.id)
        .single();

      if (fetchError) {
        console.error('‚ùå User fetch error:', fetchError);
        return {
          data: null,
          error: {
            code: 'PROVIDER_ERROR',
            message: `Kullanƒ±cƒ± profili bulunamadƒ±: ${fetchError.message}`,
            originalError: fetchError,
          },
        };
      }

      return { data: existingUser, error: null };
    }

    console.log('üîµ Update data:', filteredUpdateData);

    const { data, error } = await supabase
      .from('users')
      .update(filteredUpdateData)
      .eq('id', normalizedData.id)
      .select()
      .single();

    if (error) {
      // Eƒüer kullanƒ±cƒ± bulunamadƒ±ysa (PGRST116), database trigger hen√ºz √ßalƒ±≈ümamƒ±≈ü olabilir
      // Bu durumda kƒ±sa bir bekleme yap ve tekrar dene (sadece 1 kez)
      if (error.code === 'PGRST116') {
        console.log('‚è≥ User profile hen√ºz olu≈üturulmamƒ±≈ü, kƒ±sa bir bekleme...');
        await new Promise(resolve => setTimeout(resolve, 500));

        const { data: retryData, error: retryError } = await supabase
          .from('users')
          .update(filteredUpdateData)
          .eq('id', normalizedData.id)
          .select()
          .single();

        if (retryError) {
          // Retry sonrasƒ± hala bulunamadƒ±ysa, kullanƒ±cƒ± DB'den silinmi≈ü olabilir
          // Bu durumda √∂zel error code d√∂nd√ºr, AuthContext logout yapacak
          if (retryError.code === 'PGRST116') {
            console.warn('‚ö†Ô∏è Kullanƒ±cƒ± DB\'de bulunamadƒ± (retry sonrasƒ±), logout gerekli');
            return {
              data: null,
              error: {
                code: 'USER_NOT_FOUND',
                message: 'Kullanƒ±cƒ± veritabanƒ±nda bulunamadƒ±',
                originalError: retryError,
              },
            };
          }
          
          console.error('‚ùå User update retry error:', retryError);
          return {
            data: null,
            error: {
              code: 'PROVIDER_ERROR',
              message: `Kullanƒ±cƒ± profili g√ºncellenemedi: ${retryError.message}`,
              originalError: retryError,
            },
          };
        }

        console.log('‚úÖ User profile g√ºncellendi (retry):', retryData?.id);
        return { data: retryData, error: null };
      }

      console.error('‚ùå User update error:', error);
      return {
        data: null,
        error: {
          code: 'PROVIDER_ERROR',
          message: `Kullanƒ±cƒ± profili g√ºncellenemedi: ${error.message}`,
          originalError: error,
        },
      };
    }

    console.log('‚úÖ User profile g√ºncellendi:', data?.id);
    return { data, error: null };
  } catch (error) {
    console.error('‚ùå createOrUpdateUserProfile exception:', error);
    return {
      data: null,
      error: {
        code: 'UNKNOWN_ERROR',
        message: 'Kullanƒ±cƒ± profili i≈ülemi ba≈üarƒ±sƒ±z',
        originalError: error,
      },
    };
  }
}

/**
 * Provider'dan provider tipini belirle
 */
export function getProviderFromUser(user: User): AuthProvider {
  const providers = user.app_metadata?.providers || [];

  if (providers.includes('apple')) {
    return 'apple';
  }

  if (providers.includes('google')) {
    return 'google';
  }

  // Default olarak google d√∂nd√ºr
  return 'google';
}
</file>

<file path="api/statuses.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import React from 'react';
import type {
  CreateStatus,
  CreateUserStatus,
  Status,
  UpdateStatus,
  UserStatus,
  UserStatusWithStatus
} from '../types/database';
import { supabase } from './supabase';

// Query Keys
export const statusKeys = {
  all: ['statuses'] as const,
  lists: () => [...statusKeys.all, 'list'] as const,
  list: (filters: string) => [...statusKeys.lists(), { filters }] as const,
  details: () => [...statusKeys.all, 'detail'] as const,
  detail: (id: number) => [...statusKeys.details(), id] as const,
  custom: (ownerId: string) => [...statusKeys.all, 'custom', ownerId] as const,
  default: () => [...statusKeys.all, 'default'] as const,
};

export const userStatusKeys = {
  all: ['user-statuses'] as const,
  user: (userId: string, groupId?: string) => [...userStatusKeys.all, 'user', userId, groupId || 'global'] as const,
  group: (groupId: string) => [...userStatusKeys.all, 'group', groupId] as const,
};

// Status Queries
export const useStatuses = () => {
  return useQuery({
    queryKey: statusKeys.lists(),
    queryFn: async (): Promise<Status[]> => {
      const { data, error } = await supabase
        .from('statuses')
        .select('*')
        .order('text');
      
      if (error) throw error;
      return data || [];
    },
  });
};

export const useDefaultStatuses = () => {
  return useQuery({
    queryKey: statusKeys.default(),
    queryFn: async (): Promise<Status[]> => {
      const { data, error } = await supabase
        .from('statuses')
        .select('*')
        .eq('is_custom', false)
        .order('text');
      
      if (error) throw error;
      return data || [];
    },
  });
};

export const useCustomStatuses = (ownerId: string) => {
  return useQuery({
    queryKey: statusKeys.custom(ownerId),
    queryFn: async (): Promise<Status[]> => {
      const { data, error } = await supabase
        .from('statuses')
        .select('*')
        .eq('is_custom', true)
        .eq('owner_id', ownerId)
        .order('text');
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!ownerId,
  });
};

export const useStatus = (id: number) => {
  return useQuery({
    queryKey: statusKeys.detail(id),
    queryFn: async (): Promise<Status | null> => {
      const { data, error } = await supabase
        .from('statuses')
        .select('*')
        .eq('id', id)
        .single();
      
      if (error) throw error;
      return data;
    },
    enabled: !!id,
  });
};

// User Status Queries
export const useUserStatus = (userId: string, groupId?: string) => {
  return useQuery({
    queryKey: userStatusKeys.user(userId, groupId),
    queryFn: async (): Promise<UserStatusWithStatus | null> => {
      let query = supabase
        .from('user_statuses')
        .select(`
          *,
          status:statuses(*)
        `)
        .eq('user_id', userId);
      
      // group_id filtresi: NULL ise global, deƒüilse spesifik grup
      if (groupId) {
        query = query.eq('group_id', groupId);
      } else {
        query = query.is('group_id', null);
      }
      
      const { data, error } = await query.single();
      
      if (error && error.code !== 'PGRST116') throw error;
      return data || null;
    },
    enabled: !!userId,
  });
};

// Se√ßili grup i√ßin t√ºm kullanƒ±cƒ±larƒ±n status'larƒ±
export const useGroupUserStatuses = (groupId: string) => {
  return useQuery({
    queryKey: userStatusKeys.group(groupId),
    queryFn: async (): Promise<UserStatusWithStatus[]> => {
      console.log('üì• Fetching group user statuses for group:', groupId);
      // Se√ßili grup i√ßin status'lar + global status'lar (group_id IS NULL)
      const { data, error } = await supabase
        .from('user_statuses')
        .select(`
          *,
          status:statuses(*),
          user:users(*)
        `)
        .or(`group_id.eq.${groupId},group_id.is.null`)
        .order('updated_at', { ascending: false });
      
      if (error) throw error;
      console.log('‚úÖ Fetched group user statuses:', data?.length || 0, 'statuses');
      return data || [];
    },
    enabled: !!groupId,
    // Realtime updates i√ßin refetch ayarlarƒ±
    refetchOnMount: true,
    refetchOnWindowFocus: false, // Realtime ile g√ºncellendiƒüi i√ßin window focus'ta refetch gerekmez
    staleTime: 0, // Her zaman fresh data iste (realtime i√ßin √∂nemli)
  });
};

export const useUsersWithStatuses = () => {
  return useQuery({
    queryKey: [...userStatusKeys.all, 'with-users'],
    queryFn: async (): Promise<UserStatusWithStatus[]> => {
      const { data, error } = await supabase
        .from('user_statuses')
        .select(`
          *,
          status:statuses(*),
          user:users(*)
        `)
        .order('updated_at', { ascending: false });
      
      if (error) throw error;
      return data || [];
    },
  });
};

// Status Mutations
export const useCreateStatus = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (statusData: CreateStatus): Promise<Status> => {
      const { data, error } = await supabase
        .from('statuses')
        .insert(statusData)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: statusKeys.all });
    },
  });
};

export const useUpdateStatus = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ id, updates }: { id: number; updates: UpdateStatus }): Promise<Status> => {
      const { data, error } = await supabase
        .from('statuses')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: statusKeys.all });
      queryClient.invalidateQueries({ queryKey: statusKeys.detail(data.id) });
    },
  });
};

export const useDeleteStatus = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (id: number): Promise<void> => {
      const { error } = await supabase
        .from('statuses')
        .delete()
        .eq('id', id);
      
      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: statusKeys.all });
      queryClient.invalidateQueries({ queryKey: userStatusKeys.all });
    },
  });
};

// User Status Mutations
export const useSetUserStatus = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (userStatusData: CreateUserStatus): Promise<UserStatus> => {
      // Composite key i√ßin upsert: user_id ve group_id
      const conflictColumns = userStatusData.group_id 
        ? 'user_id,group_id' 
        : 'user_id';
      
      const { data, error } = await supabase
        .from('user_statuses')
        .upsert(userStatusData, {
          onConflict: conflictColumns
        })
        .select()
        .single();
      
      if (error) throw error;

      // Eƒüer grup i√ßin status deƒüi≈ütirildiyse ve notifies: true ise, pending notification olu≈ütur/g√ºncelle
      // Custom status'ler i√ßin de aynƒ± mantƒ±k ge√ßerlidir (statuses tablosunda notifies ve messages kontrol edilir)
      if (data.group_id) {
        try {
          // Status bilgisini al (notifies ve messages kontrol√º i√ßin)
          // Custom status'ler i√ßin de messages array'i kullanƒ±labilir
          const { data: statusData } = await supabase
            .from('statuses')
            .select('notifies, messages, is_custom')
            .eq('id', data.status_id)
            .single();

          // notifies: true ise bildirim g√∂nder (custom veya default status fark etmez)
          if (statusData?.notifies) {
            // Grup √ºyelerini al (kendisi hari√ß)
            const { data: members } = await supabase
              .from('group_members')
              .select('user_id')
              .eq('group_id', data.group_id)
              .neq('user_id', data.user_id);

            if (members && members.length > 0) {
              const receiverIds = members.map(m => m.user_id);
              const scheduledAt = new Date(Date.now() + 60 * 1000).toISOString(); // 1 dakika sonra

              // Pending notification olu≈ütur veya g√ºncelle (sender_id, group_id unique)
              // Bu sayede kullanƒ±cƒ± s√ºrekli status deƒüi≈ütirirse, sadece son status i√ßin bildirim g√∂nderilir (debounce)
              const { error: pendingError } = await supabase
                .from('pending_notifications')
                .upsert({
                  sender_id: data.user_id,
                  receiver_ids: receiverIds,
                  group_id: data.group_id,
                  status_id: data.status_id,
                  scheduled_at: scheduledAt,
                }, {
                  onConflict: 'sender_id,group_id'
                });

              if (pendingError) {
                console.error('Pending notification olu≈üturma/g√ºncelleme hatasƒ±:', pendingError);
                // Hata olsa bile status g√ºncellemesi ba≈üarƒ±lƒ± sayƒ±lƒ±r (non-blocking)
              } else {
                console.log('‚úÖ Pending notification olu≈üturuldu/g√ºncellendi:', {
                  sender_id: data.user_id,
                  group_id: data.group_id,
                  status_id: data.status_id,
                  receiver_count: receiverIds.length,
                  is_custom: statusData.is_custom,
                  has_messages: !!(statusData.messages && statusData.messages.length > 0),
                });
              }
            }
          } else {
            console.log('‚ÑπÔ∏è Status notifies false, bildirim g√∂nderilmeyecek:', {
              status_id: data.status_id,
              is_custom: statusData?.is_custom,
            });
          }
        } catch (error) {
          console.error('Pending notification i≈ülemi hatasƒ± (non-blocking):', error);
        }
      }

      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: userStatusKeys.all });
      queryClient.invalidateQueries({ queryKey: userStatusKeys.user(data.user_id, data.group_id) });
      if (data.group_id) {
        queryClient.invalidateQueries({ queryKey: userStatusKeys.group(data.group_id) });
      }
    },
  });
};

export const useRemoveUserStatus = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ userId, groupId }: { userId: string; groupId?: string }): Promise<void> => {
      let query = supabase
        .from('user_statuses')
        .delete()
        .eq('user_id', userId);
      
      if (groupId) {
        query = query.eq('group_id', groupId);
      } else {
        query = query.is('group_id', null);
      }
      
      const { error } = await query;
      
      if (error) throw error;
    },
    onSuccess: (_, { userId, groupId }) => {
      queryClient.invalidateQueries({ queryKey: userStatusKeys.all });
      queryClient.invalidateQueries({ queryKey: userStatusKeys.user(userId, groupId) });
      if (groupId) {
        queryClient.invalidateQueries({ queryKey: userStatusKeys.group(groupId) });
      }
    },
  });
};

// Realtime Subscription Hooks
export const useStatusesRealtime = () => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['statuses-realtime'],
    queryFn: () => {
      const channel = supabase
        .channel('statuses-changes')
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'statuses',
          },
          () => {
            queryClient.invalidateQueries({ queryKey: statusKeys.all });
          }
        )
        .subscribe();

      return channel;
    },
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};

export const useUserStatusesRealtime = () => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['user-statuses-realtime'],
    queryFn: () => {
      const channel = supabase
        .channel('user-statuses-changes')
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'user_statuses',
          },
          () => {
            queryClient.invalidateQueries({ queryKey: userStatusKeys.all });
          }
        )
        .subscribe();

      return channel;
    },
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};

// Se√ßili grup i√ßin realtime subscription
export const useGroupStatusesRealtime = (groupId: string) => {
  const queryClient = useQueryClient();

  React.useEffect(() => {
    if (!groupId) {
      console.log('‚ö†Ô∏è useGroupStatusesRealtime: groupId yok, subscription kurulmuyor');
      return;
    }

    console.log('üîå Setting up realtime subscription for group:', groupId);
    const channelName = `group-statuses-changes-${groupId}`;
    const channel = supabase
      .channel(channelName)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'user_statuses',
          // filter: `group_id=eq.${groupId}`,
        },
        (payload) => {
          console.log('üîÑ Realtime status update (group):', payload);
          console.log('üîë Invalidating query key:', userStatusKeys.group(groupId));
          // √ñnce invalidate et, sonra refetch et
          queryClient.invalidateQueries({ 
            queryKey: userStatusKeys.group(groupId),
            refetchType: 'active' 
          });
          // Refetch'i zorla
          queryClient.refetchQueries({ 
            queryKey: userStatusKeys.group(groupId),
          });
          queryClient.invalidateQueries({ 
            queryKey: userStatusKeys.all,
            refetchType: 'active' 
          });
        }
      )
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'user_statuses',
          filter: 'group_id=is.null', // Global status'lar da dinlenmeli
        },
        (payload) => {
          console.log('üîÑ Realtime status update (global):', payload);
          console.log('üîë Invalidating query key:', userStatusKeys.group(groupId));
          // √ñnce invalidate et, sonra refetch et
          queryClient.invalidateQueries({ 
            queryKey: userStatusKeys.group(groupId),
            refetchType: 'active' 
          });
          // Refetch'i zorla
          queryClient.refetchQueries({ 
            queryKey: userStatusKeys.group(groupId),
          });
          queryClient.invalidateQueries({ 
            queryKey: userStatusKeys.all,
            refetchType: 'active' 
          });
        }
      )
      .subscribe((status, err) => {
        console.log('üì° Realtime subscription status (statuses):', status, err);
        if (status === 'SUBSCRIBED') {
          console.log('‚úÖ Realtime subscription ba≈üarƒ±yla kuruldu:', channelName);
        } else if (status === 'CHANNEL_ERROR') {
          console.error('‚ùå Realtime subscription hatasƒ±:', err);
        } else if (status === 'TIMED_OUT') {
          console.error('‚è±Ô∏è Realtime subscription timeout:', channelName);
        } else if (status === 'CLOSED') {
          console.warn('‚ö†Ô∏è Realtime subscription kapandƒ±:', channelName);
        }
      });

    return () => {
      console.log('üîå Unsubscribing from status changes for group:', groupId);
      supabase.removeChannel(channel);
    };
  }, [groupId, queryClient]);
};
</file>

<file path="api/users.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import type {
  CreateUser,
  UpdateUser,
  User
} from '../types/database';
import { supabase } from './supabase';

// Query Keys
export const userKeys = {
  all: ['users'] as const,
  lists: () => [...userKeys.all, 'list'] as const,
  list: (filters: string) => [...userKeys.lists(), { filters }] as const,
  details: () => [...userKeys.all, 'detail'] as const,
  detail: (id: string) => [...userKeys.details(), id] as const,
  current: () => [...userKeys.all, 'current'] as const,
};

// Queries
export const useUsers = () => {
  return useQuery({
    queryKey: userKeys.lists(),
    queryFn: async (): Promise<User[]> => {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .order('display_name');
      
      if (error) throw error;
      return data || [];
    },
  });
};

export const useUser = (id: string) => {
  return useQuery({
    queryKey: userKeys.detail(id),
    queryFn: async (): Promise<User | null> => {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('id', id)
        .single();
      
      if (error) throw error;
      return data;
    },
    enabled: !!id,
  });
};

export const useCurrentUser = () => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: userKeys.current(),
    queryFn: async (): Promise<User | null> => {
      // Session kontrol√º
      const { data: { session } } = await supabase.auth.getSession();
      if (!session?.user) {
        console.log('üîµ useCurrentUser: Session yok');
        return null;
      }

      const userId = session.user.id;
      console.log('üîµ useCurrentUser: User profile fetch ediliyor, user ID:', userId);
      
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('id', userId)
        .single();
      
      if (error) {
        // Eƒüer kullanƒ±cƒ± bulunamadƒ±ysa (PGRST116), database trigger hen√ºz √ßalƒ±≈ümamƒ±≈ü olabilir
        if (error.code === 'PGRST116') {
          console.log('‚è≥ useCurrentUser: User profile hen√ºz olu≈üturulmamƒ±≈ü, database trigger bekleniyor...');
          return null;
        }
        console.error('‚ùå useCurrentUser: Error:', error);
        throw error;
      }
      
      console.log('‚úÖ useCurrentUser: User profile bulundu:', data?.id);
      return data;
    },
    // Session kontrol√º queryFn i√ßinde yapƒ±lƒ±yor, enabled her zaman true
    enabled: true,
    retry: (failureCount, error: any) => {
      // PGRST116 hatasƒ± i√ßin retry yap (database trigger hen√ºz √ßalƒ±≈ümamƒ±≈ü olabilir)
      // Ama retry sonrasƒ± hala bulunamazsa, kullanƒ±cƒ± DB'den silinmi≈ü olabilir
      if (error?.code === 'PGRST116' && failureCount < 3) {
        return true;
      }
      // Retry sonrasƒ± hala PGRST116 gelirse, kullanƒ±cƒ± DB'den silinmi≈ü olabilir
      // √ñzel error code ile throw et, AuthContext logout yapacak
      if (error?.code === 'PGRST116' && failureCount >= 3) {
        const userNotFoundError = new Error('User not found in database after retries');
        (userNotFoundError as any).code = 'USER_NOT_FOUND';
        (userNotFoundError as any).originalError = error;
        throw userNotFoundError;
      }
      // Diƒüer hatalar i√ßin retry yapma
      return false;
    },
    retryDelay: (attemptIndex) => Math.min(500 * 2 ** attemptIndex, 2000), // Exponential backoff (max 2 saniye)
    refetchOnWindowFocus: false, // Window focus'ta refetch yapma
    refetchOnMount: true, // Mount'ta refetch yap
    staleTime: 0, // Her zaman fresh data iste
  });
};

export const useUserByCustomId = (customUserId: string) => {
  return useQuery({
    queryKey: [...userKeys.details(), 'custom', customUserId],
    queryFn: async (): Promise<User | null> => {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('custom_user_id', customUserId)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      return data || null;
    },
    enabled: !!customUserId,
  });
};

// Mutations
export const useCreateUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (userData: CreateUser): Promise<User> => {
      const { data, error } = await supabase
        .from('users')
        .insert(userData)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.all });
    },
  });
};

export const useUpdateUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ id, updates }: { id: string; updates: UpdateUser }): Promise<User> => {
      const { data, error } = await supabase
        .from('users')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) {
        // Kullanƒ±cƒ± bulunamadƒ±ysa (DB'den silinmi≈üse), √∂zel error code ile throw et
        // AuthContext bu hatayƒ± yakalayƒ±p logout yapacak
        if (error.code === 'PGRST116') {
          const userNotFoundError = new Error('User not found in database');
          (userNotFoundError as any).code = 'USER_NOT_FOUND';
          (userNotFoundError as any).originalError = error;
          throw userNotFoundError;
        }
        throw error;
      }
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: userKeys.all });
      queryClient.invalidateQueries({ queryKey: userKeys.detail(data.id) });
    },
  });
};

export const useDeleteUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (id: string): Promise<void> => {
      const { error } = await supabase
        .from('users')
        .delete()
        .eq('id', id);
      
      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.all });
    },
  });
};

// Realtime Subscription Hook
export const useUsersRealtime = () => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['users-realtime'],
    queryFn: () => {
      const channel = supabase
        .channel('users-changes')
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'users',
          },
          () => {
            queryClient.invalidateQueries({ queryKey: userKeys.all });
          }
        )
        .subscribe();

      return channel;
    },
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};
</file>

<file path="app/(drawer)/home.tsx">
import { useGroupMoodsRealtime } from "@/api/moods";
import { useGroupStatusesRealtime } from "@/api/statuses";
import { DashboardView, EmptyStateView } from "@/components/dashboard";
import { BaseLayout } from "@/components/shared";
import { useGroupContext } from "@/contexts/GroupContext";
import { useTheme } from "@/contexts/ThemeContext";
import React from "react";
import { ActivityIndicator, View } from "react-native";

export default function HomeScreen() {
    const { selectedGroup, isLoading } = useGroupContext();
    const { colors } = useTheme();

    // Se√ßili grup i√ßin realtime subscription'larƒ± ba≈ülat
    // Bu hooklar arka planda Supabase listener'larƒ±nƒ± y√∂netir
    // selectedGroup deƒüi≈ütiƒüinde otomatik olarak yeni grubu dinlemeye ba≈ülar
    useGroupStatusesRealtime(selectedGroup?.id || '');
    useGroupMoodsRealtime(selectedGroup?.id || '');

    // Loading durumu
    if (isLoading) {
        return (
            <BaseLayout headerShow={false}>
                <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: colors.background }}>
                    <ActivityIndicator size="large" color={colors.primary} />
                </View>
            </BaseLayout>
        );
    }

    return (
        <BaseLayout
            headerShow={false} // Drawer navigation kendi header'ƒ±nƒ± kullanƒ±yor (GroupHeader sayesinde)
            backgroundColor={colors.background}
        >
            {selectedGroup ? (
                // Bir grup se√ßiliyse Dashboard'u g√∂ster
                <DashboardView group={selectedGroup} />
            ) : (
                // Grup yoksa veya se√ßilmediyse Empty State g√∂ster
                <EmptyStateView />
            )}
        </BaseLayout>
    );
}
</file>

<file path="app/Provider.tsx">
import { NotificationHandler } from '@/components/NotificationHandler';
import { AuthProvider } from '@/contexts/AuthContext';
import { BottomSheetProvider } from '@/contexts/BottomSheetContext';
import { GroupProvider } from '@/contexts/GroupContext';
import { ThemeProvider } from '@/contexts/ThemeContext';
import { initializeOneSignal } from '@/services/onesignal';
import NetInfo from '@react-native-community/netinfo';
import { onlineManager, QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useFonts } from "expo-font";
import * as SplashScreen from 'expo-splash-screen';
import React, { useEffect } from 'react';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { SafeAreaProvider } from 'react-native-safe-area-context';

// Network durumunu TanStack Query ile senkronize et
onlineManager.setEventListener((setOnline: (online: boolean) => void) => {
  return NetInfo.addEventListener((state) => {
    setOnline(!!state.isConnected)
  })
})

// Splash screen'i manuel olarak gizlememiz gerekiyor
SplashScreen.preventAutoHideAsync();

// TanStack Query client'ƒ± olu≈ütur.
// Bu component dƒ±≈üƒ±nda olu≈üturulur ki her render'da yeniden olu≈ümasƒ±n.
const queryClient = new QueryClient();

// Merkezi Provider Component'i - Sadece provider'larƒ± wrap eder
export default function Provider({ children }: { children: React.ReactNode }) {

  const [fontsLoaded, error] = useFonts({
    'Comfortaa-Light': require('@/assets/fonts/Comfortaa-Light.ttf'),
    'Comfortaa-Regular': require('@/assets/fonts/Comfortaa-Regular.ttf'),
    'Comfortaa-Medium': require('@/assets/fonts/Comfortaa-Medium.ttf'),
    'Comfortaa-SemiBold': require('@/assets/fonts/Comfortaa-SemiBold.ttf'),
    'Comfortaa-Bold': require('@/assets/fonts/Comfortaa-Bold.ttf'),
  });

  // OneSignal'i initialize et (uygulama ba≈üladƒ±ƒüƒ±nda bir kez)
  useEffect(() => {
    initializeOneSignal().catch((error) => {
      console.error('‚ùå OneSignal initialization hatasƒ±:', error);
    });
  }, []);

  if (!fontsLoaded && !error) {
    return null;
  }

  return (
    <SafeAreaProvider>
      <GestureHandlerRootView style={{ flex: 1 }}>
        <QueryClientProvider client={queryClient}>
          <ThemeProvider>
            <AuthProvider>
              <GroupProvider>
                <BottomSheetProvider>
                  <NotificationHandler />
                  {children}
                </BottomSheetProvider>
              </GroupProvider>
            </AuthProvider>
          </ThemeProvider>
        </QueryClientProvider>
      </GestureHandlerRootView>
    </SafeAreaProvider>
  );
}
</file>

<file path="components/shared/Button.tsx">
// Button.tsx - Gradient Kenarlƒ±k D√ºzeltmesiyle

import CustomText from "@/components/shared/Text";
import { useTheme } from "@/contexts/ThemeContext";
import { Fonts, TypographyKeys } from "@/theme/typography";
import { LinearGradient } from "expo-linear-gradient";
import React from "react";
import { ActivityIndicator, StyleSheet, TouchableOpacity, TouchableOpacityProps, View } from "react-native";

interface ButtonProps extends TouchableOpacityProps {
    title: string;
    onPress: () => void;
    variant?: 'gradient' | 'primary' | 'outline';
    size?: 'large' | 'small';
    disabled?: boolean;
    loading?: boolean;
    icon?: React.ReactNode;
    textVariant?: keyof TypographyKeys;
    fontWeight?: keyof Fonts;
    passive?: boolean;
}

export default function Button({
    title,
    onPress,
    variant = 'gradient',
    size = 'large',
    disabled = false,
    loading = false,
    icon,
    textVariant,
    fontWeight,
    style,
    passive = false,
    ...props
}: ButtonProps) {   
    const { colors } = useTheme();

    // Tƒ±klanabilirliƒüi `isEffectivelyDisabled`'a baƒülƒ±yoruz
    const isEffectivelyDisabled = (disabled || loading) && !passive;

    const defaultTextVariant = size === 'large' ? 'h6' : 'body2';

    const getGradientStartAndEnd = () => {
        if (size === 'large') return { start: { x: 0, y: 0 }, end: { x: 1, y: 0 } };
        return { start: { x: 1, y: 0 }, end: { x: 0, y: 0 } };
    }

    // T√ºm stil (renk, opaklƒ±k) ko≈üullarƒ±nƒ± `shouldApplyDisabledStyle`'a baƒülƒ±yoruz
    const getTextColor = () => {
        if (isEffectivelyDisabled) return colors.secondaryText;
        if (variant === 'outline') return colors.primary;
        return colors.text;
    };

    const content = (
        <View style={[
            styles.contentWrapper,
            size === 'small' && styles.contentPadding,
        ]}>
            {icon && !loading && <View style={styles.iconWrapper}>{icon}</View>}
            <CustomText
                variant={textVariant || defaultTextVariant}
                fontWeight={fontWeight}
                style={[styles.text, { color: getTextColor() }]}
            >
                {title}
            </CustomText>
            {loading && <ActivityIndicator color={getTextColor()} style={styles.loader} />}
        </View>
    );

    const containerStyle = [
        styles.baseContainer,
        size === 'large' ? styles.largeContainer : styles.smallContainer,
        isEffectivelyDisabled && { opacity: 0.6 },
        style,
    ];

    if (variant === 'outline') {
        return (
            <TouchableOpacity 
            activeOpacity={0.8}
            onPress={onPress} disabled={isEffectivelyDisabled} style={containerStyle} {...props}>
                <LinearGradient
                    colors={isEffectivelyDisabled ? [colors.disabled, colors.disabled] : colors.linearGradient as [string, string]}
                    start={getGradientStartAndEnd().start}
                    end={getGradientStartAndEnd().end}
                    style={[
                        styles.fullWidthHeight,
                        styles.borderFrame,
                        size === 'small' ? styles.smallBorderRadius : styles.largeBorderRadius,
                    ]}
                >
                    <View style={[
                        styles.outlineInnerView,
                        { backgroundColor: colors.background },
                        size === 'small' ? styles.smallInnerRadius : styles.largeInnerRadius,
                    ]}>
                        {content}
                    </View>
                </LinearGradient>
            </TouchableOpacity>
        );
    }
    
    if (variant === 'gradient') {
        return (
            <TouchableOpacity activeOpacity={0.8} onPress={onPress} disabled={isEffectivelyDisabled} style={containerStyle} {...props}>
                <LinearGradient
                    colors={isEffectivelyDisabled ? [colors.disabled, colors.disabled] : colors.linearGradient as [string, string]}
                    start={getGradientStartAndEnd().start}
                    end={getGradientStartAndEnd().end}
                    style={[
                        styles.fullWidthHeight,
                        { borderRadius: size === 'large' ? styles.largeContainer.borderRadius : styles.smallContainer.borderRadius }
                    ]}
                >
                    {content}
                </LinearGradient>
            </TouchableOpacity>
        );
    }

    return (
        <TouchableOpacity
            activeOpacity={0.8}
            onPress={onPress}
            disabled={isEffectivelyDisabled}
            style={[
                { backgroundColor: isEffectivelyDisabled ? colors.disabled : colors.primary },
                containerStyle,
            ]}
            {...props}
        >
            {content}
        </TouchableOpacity>
    );
};

const styles = StyleSheet.create({
    baseContainer: {
        justifyContent: 'center',
        alignItems: 'center',
        overflow: 'hidden',
    },
    largeContainer: {
        width: '100%',
        height: 56,
        borderRadius: 28,
    },
    smallContainer: {
        alignSelf: 'flex-start',
        height: 36,
        borderRadius: 20,
    },
    fullWidthHeight: {
        width: '100%',
        height: '100%',
        justifyContent: 'center',
        alignItems: 'center'
    },
    contentWrapper: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
    },
    contentPadding: {
        paddingHorizontal: 16,
    },
    borderFrame: {
        padding: 1,
    },
    iconWrapper: {
        marginRight: 8,
    },
    text: {
        textAlign: 'center',
    },
    loader: {
        marginLeft: 10,
    },
    outlineInnerView: {
        width: '100%',
        height: '100%',
        justifyContent: 'center',
        alignItems: 'center',
    },
    largeBorderRadius: { borderRadius: 28 },
    largeInnerRadius: { borderRadius: 27 },
    smallBorderRadius: { borderRadius: 20 },
    smallInnerRadius: { borderRadius: 19 },
});
</file>

<file path="components/shared/GeliomButton.tsx">
import { Ionicons } from '@expo/vector-icons';
import React, { ReactNode } from 'react';
import {
  ActivityIndicator,
  StyleSheet,
  Text,
  View,
  ViewStyle,
} from 'react-native';
import { useTheme } from '../../contexts/ThemeContext';
// Yeni animasyon bile≈üenini import ediyoruz
import { BouncyButton } from '../anim/AnimatedComponents';

export type GeliomButtonState = 'active' | 'passive' | 'loading';
export type GeliomButtonSize = 'small' | 'medium' | 'large' | 'xl';
export type GeliomButtonLayout = 'default' | 'icon-left' | 'icon-right' | 'icon-only' | 'full-width';

export interface GeliomButtonProps {
  children?: ReactNode;
  state?: GeliomButtonState;
  size?: GeliomButtonSize;
  layout?: GeliomButtonLayout;
  icon?: keyof typeof Ionicons.glyphMap;
  onPress?: () => void;
  disabled?: boolean;
  style?: ViewStyle;
}

const GeliomButton: React.FC<GeliomButtonProps> = ({
  children,
  state = 'active',
  size = 'medium',
  layout = 'default',
  icon,
  onPress,
  disabled = false,
  style,
}) => {
  const { colors } = useTheme();

  // Ada√ßayƒ± tarzƒ± organik boyutlandƒ±rma
  const sageStyleConfig = {
    small: {
      paddingHorizontal: 14,
      paddingVertical: 8,
      borderRadius: 14,
      fontSize: 14,
      iconSize: 16,
      minHeight: 32,
      gap: 6,
    },
    medium: {
      paddingHorizontal: 18,
      paddingVertical: 12,
      borderRadius: 18,
      fontSize: 16,
      iconSize: 18,
      minHeight: 42,
      gap: 8,
    },
    large: {
      paddingHorizontal: 24,
      paddingVertical: 16,
      borderRadius: 22,
      fontSize: 18,
      iconSize: 20,
      minHeight: 52,
      gap: 10,
    },
    xl: {
      paddingHorizontal: 32,
      paddingVertical: 20,
      borderRadius: 26,
      fontSize: 20,
      iconSize: 24,
      minHeight: 62,
      gap: 12,
    },
  };

  const currentConfig = sageStyleConfig[size];

  const getStateColors = () => {
    // Tema renklerinden g√ºvenli eri≈üim
    const forest = colors.primary;
    const sage = colors.tertiary; 
    const pine = colors.secondary;

    switch (state) {
      case 'active':
        return {
          backgroundColor: forest,
          textColor: '#FFFFFF',
          shadowColor: forest,
          borderColor: 'transparent',
        };
      case 'passive':
        return {
          backgroundColor: sage + '40', // %40 opaklƒ±k
          textColor: colors.primary,
          shadowColor: 'transparent',
          borderColor: 'transparent',
        };
      case 'loading':
        return {
          backgroundColor: pine,
          textColor: '#FFFFFF',
          shadowColor: pine,
          borderColor: 'transparent',
        };
      default:
        return {
          backgroundColor: forest,
          textColor: '#FFFFFF',
          shadowColor: forest,
          borderColor: 'transparent',
        };
    }
  };

  const stateColors = getStateColors();

  const getLayoutStyle = (): ViewStyle => {
    const baseStyle: ViewStyle = {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      paddingHorizontal: currentConfig.paddingHorizontal,
      paddingVertical: currentConfig.paddingVertical,
      borderRadius: currentConfig.borderRadius,
      minHeight: currentConfig.minHeight,
      gap: currentConfig.gap,
      backgroundColor: stateColors.backgroundColor,
      borderColor: stateColors.borderColor,
      opacity: disabled ? 0.6 : 1,
    };

    switch (layout) {
      case 'icon-left':
        return { ...baseStyle, flexDirection: 'row' };
      case 'icon-right':
        return { ...baseStyle, flexDirection: 'row-reverse' };
      case 'icon-only':
        return { 
          ...baseStyle, 
          paddingHorizontal: 0,
          width: currentConfig.minHeight, // Kare form
          justifyContent: 'center',
        };
      case 'full-width':
        return { ...baseStyle, width: '100%' };
      default:
        return baseStyle;
    }
  };

  const buttonStyle = getLayoutStyle();

  const renderIcon = () => {
    if (!icon) return null;
    return (
      <Ionicons 
        name={icon} 
        size={currentConfig.iconSize} 
        color={stateColors.textColor} 
      />
    );
  };

  const renderText = () => {
    if (layout === 'icon-only') return null;
    if (state === 'loading') return null;
    
    return (
      <Text style={[styles.text, { 
        color: stateColors.textColor,
        fontSize: currentConfig.fontSize,
      }]}>
        {children}
      </Text>
    );
  };

  const renderLoading = () => {
    if (state !== 'loading') return null;
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="small" color={stateColors.textColor} />
      </View>
    );
  };

  // TouchableOpacity yerine BouncyButton kullanƒ±yoruz
  return (
    <BouncyButton
      onPress={onPress}
      disabled={disabled || state === 'loading'}
      style={[
        buttonStyle,
        state === 'active' && styles.shadow, // Sadece active iken g√∂lge
        { shadowColor: stateColors.shadowColor },
        style,
      ]}
    >
      {state === 'loading' ? (
        renderLoading()
      ) : (
        <>
          {(layout === 'icon-left' || layout === 'icon-only') && renderIcon()}
          {renderText()}
          {layout === 'icon-right' && renderIcon()}
        </>
      )}
    </BouncyButton>
  );
};

const styles = StyleSheet.create({
  text: {
    fontFamily: 'Comfortaa-SemiBold',
    textAlign: 'center',
    fontWeight: '600',
  },
  shadow: {
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.25,
    shadowRadius: 8,
    elevation: 4,
  },
  loadingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
});

export default GeliomButton;
</file>

<file path="components/shared/GroupHeader.tsx">
import { Ionicons } from '@expo/vector-icons';
import React from 'react';
import { StyleSheet, View } from 'react-native';
import { useTheme } from '../../contexts/ThemeContext';
import type { GroupWithOwner } from '../../types/database';
import { BouncyButton } from '../anim/AnimatedComponents';
import Typography from './Typography';

interface GroupHeaderProps {
  group: GroupWithOwner | null;
  onPress: () => void;
}

export default function GroupHeader({ group, onPress }: GroupHeaderProps) {
  const { colors } = useTheme();

  return (
    <BouncyButton
      onPress={onPress}
      style={[styles.container, { backgroundColor: colors.cardBackground + '80', borderColor: colors.stroke }]}
    >
      <View style={styles.content}>
        <View style={[styles.iconBox, { backgroundColor: colors.primary }]}>
             <Ionicons name="people" size={14} color="white" />
        </View>
        
        <Typography
          variant="h6"
          color={colors.text}
          style={styles.groupName}
          numberOfLines={1}
        >
          {group?.name || 'Birlik Olu≈ütur'}
        </Typography>
        
        <Ionicons
          name="chevron-down"
          size={16}
          color={colors.secondaryText}
          style={styles.icon}
        />
      </View>
    </BouncyButton>
  );
};

const styles = StyleSheet.create({
  container: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
    borderWidth: 1,
    maxWidth: 220, // √áok uzun isimler i√ßin sƒ±nƒ±r
  },
  content: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  iconBox: {
      width: 24,
      height: 24,
      borderRadius: 12,
      justifyContent: 'center',
      alignItems: 'center',
  },
  groupName: {
    fontSize: 14,
    flexShrink: 1, // ƒ∞smin ta≈ümasƒ±nƒ± engelle
  },
  icon: {
    marginLeft: 2,
  },
});
</file>

<file path="components/shared/GroupListBottomSheet.tsx">
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useCallback } from 'react';
import { ActivityIndicator, ScrollView, StyleSheet, View } from 'react-native';
import { useBottomSheet } from '../../contexts/BottomSheetContext';
import { useGroupContext } from '../../contexts/GroupContext';
import { useTheme } from '../../contexts/ThemeContext';
import { BouncyButton } from '../anim/AnimatedComponents';
import Typography from './Typography';

function GroupListBottomSheetComponent() {
  // Context'ten ger√ßek verileri al
  const { selectedGroup, setSelectedGroup, groups, isLoading } = useGroupContext();
  const { closeBottomSheet } = useBottomSheet();
  const { colors } = useTheme();
  const router = useRouter();

  const handleGroupSelect = useCallback(async (group: typeof groups[0]) => {
    await setSelectedGroup(group);
    closeBottomSheet();
  }, [setSelectedGroup, closeBottomSheet]);

  const handleCreateGroup = useCallback(() => {
    closeBottomSheet();
    router.push('/(drawer)/(group)/create-group');
  }, [closeBottomSheet, router]);

  // Gruplar y√ºklenirken g√∂sterilecek i√ßerik
  if (isLoading) {
    return (
      <View style={[styles.container, { backgroundColor: colors.background, justifyContent: 'center', alignItems: 'center' }]}>
        <ActivityIndicator size="large" color={colors.primary} />
        <Typography variant="caption" color={colors.secondaryText} style={{ marginTop: 12 }}>
          Birlikler y√ºkleniyor...
        </Typography>
      </View>
    );
  }

  return (
    <View style={[styles.container, { backgroundColor: colors.background }]}>
      <View style={styles.header}>
        <Typography variant="h3" color={colors.text} style={styles.headerTitle}>
          Birliklerim
        </Typography>
      </View>

      <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
        {groups.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Ionicons name="people-outline" size={48} color={colors.secondaryText} />
            <Typography variant="body" color={colors.secondaryText} style={styles.emptyText}>
              Hen√ºz bir birliƒüe √ºye deƒüilsin.
            </Typography>
          </View>
        ) : (
          <View style={styles.groupsList}>
            {groups.map((group) => {
              const isSelected = selectedGroup?.id === group.id;
              return (
                <BouncyButton
                  key={group.id}
                  onPress={() => handleGroupSelect(group)}
                  style={[
                    styles.groupItem,
                    {
                      backgroundColor: isSelected ? colors.tertiary + '30' : colors.cardBackground,
                      borderColor: isSelected ? colors.primary : colors.stroke,
                    },
                  ]}
                >
                  <View style={styles.groupItemContent}>
                    <View style={[
                        styles.iconBadge, 
                        { 
                          backgroundColor: isSelected ? colors.primary : colors.cardBackground, 
                          borderColor: colors.stroke, 
                          borderWidth: isSelected ? 0 : 1 
                        }
                    ]}>
                         <Ionicons 
                            name={group.type === 'family' ? 'home' : group.type === 'work' ? 'briefcase' : 'people'} 
                            size={20} 
                            color={isSelected ? 'white' : colors.secondaryText} 
                        />
                    </View>
                    <View style={styles.groupInfo}>
                      <Typography variant="h5" color={colors.text} style={styles.groupName} numberOfLines={1}>
                        {group.name}
                      </Typography>
                      <Typography variant="caption" color={colors.secondaryText} style={styles.groupType}>
                         {(group as any).member_count ? `${(group as any).member_count} √úye` : 'Grup'} ‚Ä¢ {
                           group.type === 'family' ? 'Aile' : 
                           group.type === 'friends' ? 'Arkada≈ülar' : 
                           group.type === 'work' ? 'ƒ∞≈ü' : 
                           'Diƒüer'
                         }
                      </Typography>
                    </View>
                    {isSelected && <Ionicons name="checkmark-circle" size={24} color={colors.primary} />}
                  </View>
                </BouncyButton>
              );
            })}
          </View>
        )}

        <BouncyButton 
          style={[styles.createButton, { backgroundColor: colors.primary }]} 
          onPress={handleCreateGroup}
        >
          <Ionicons name="add" size={24} color={colors.white} />
          <Typography variant="button" color={colors.white} style={styles.createButtonText}>
            Yeni Birlik Kur
          </Typography>
        </BouncyButton>
        
        <View style={{ height: 40 }} />
      </ScrollView>
    </View>
  );
}

// React.memo kaldƒ±rƒ±ldƒ± - her a√ßƒ±lƒ±≈üta yeni key ile render ediliyor
// Bu sayede context g√ºncellemeleri her zaman yansƒ±r
export default GroupListBottomSheetComponent;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingTop: 10,
  },
  header: {
    paddingHorizontal: 24,
    paddingBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0,0,0,0.05)',
  },
  headerTitle: {
    fontWeight: 'bold',
  },
  scrollView: {
    flex: 1,
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 40,
    paddingHorizontal: 24,
  },
  emptyText: {
    marginTop: 16,
    textAlign: 'center',
  },
  groupsList: {
    padding: 16,
    gap: 12,
  },
  groupItem: {
    borderRadius: 20,
    borderWidth: 1.5,
    padding: 16,
  },
  groupItemContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconBadge: {
      width: 44,
      height: 44,
      borderRadius: 22,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: 16,
  },
  groupInfo: {
    flex: 1,
    marginRight: 12,
  },
  groupName: {
    marginBottom: 2,
    fontWeight: '600',
  },
  groupType: {
    textTransform: 'capitalize',
    opacity: 0.8,
  },
  createButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 18,
    paddingHorizontal: 24,
    marginHorizontal: 16,
    marginTop: 8,
    borderRadius: 24,
    gap: 8,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  createButtonText: {
    fontWeight: 'bold',
    fontSize: 16,
  },
});
</file>

<file path="components/KeyboardAwareView.tsx">
import React from 'react';
import {
  GestureResponderEvent,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  StyleProp,
  StyleSheet,
  ViewStyle,
} from 'react-native';

interface KeyboardAwareViewProps {
  /** ƒ∞√ßeriƒüi g√∂sterir */
  children: React.ReactNode;
  
  /** KeyboardAvoidingView i√ßin stil */
  style?: StyleProp<ViewStyle>;
  
  /** ScrollView'in i√ßindeki contentContainer i√ßin stil */
  contentContainerStyle?: StyleProp<ViewStyle>;
  
  /**
   * Ekranƒ±n √ºst kƒ±smƒ±ndaki (√∂rneƒüin header) bo≈üluk miktarƒ±.
   * Bu bile≈üen bir header'ƒ±n altƒ±ndaysa, header'ƒ±n y√ºksekliƒüini buraya girin.
   */
  keyboardVerticalOffset?: number;
  
  /**
   * Dokunma olayƒ±nƒ± iletmek i√ßin opsiyonel bir prop.
   * Bazen 'ScrollView' yerine dƒ±≈üarƒ±daki bir view'a dokunulduƒüunu bilmek istersiniz.
   */
  onTouchStart?: (event: GestureResponderEvent) => void;
}

/**
 * Klavye a√ßƒ±ldƒ±ƒüƒ±nda i√ßeriƒüin klavyenin altƒ±nda kalmasƒ±nƒ± engelleyen,
 * hem iOS hem de Android i√ßin tutarlƒ± √ßalƒ±≈üan sarmalayƒ±cƒ± bile≈üen.
 * * Temelde 'KeyboardAvoidingView' ve 'ScrollView'i doƒüru ayarlarla birle≈ütirir.
 * * En √∂nemli √∂zelliƒüi: ScrollView'in 'contentContainerStyle'ƒ±na otomatik olarak
 * 'flexGrow: 1' ekler. Bu sayede i√ßerik kƒ±sayken bile ekranƒ± doldurur
 * (√∂rn: 'justifyContent: 'space-between'' ile butonu en alta itmek i√ßin).
 */
export default function KeyboardAwareView({ children, style, contentContainerStyle, keyboardVerticalOffset = 0, onTouchStart }: KeyboardAwareViewProps) {
  return (
    <KeyboardAvoidingView
      style={[styles.container, style]}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? keyboardVerticalOffset : 0}
      enabled={Platform.OS === 'ios'}
    >
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={[
          styles.contentContainer,
          contentContainerStyle,
        ]}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
        onTouchStart={onTouchStart}
        bounces={false}
      >
        {children}
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    width: '100%',
  },
  scrollView: {
    flex: 1,
  },
  contentContainer: {
    /**
     * BU √áOK √ñNEMLƒ∞!
     * 'flexGrow: 1', i√ßeriƒüin ScrollView'dan kƒ±sa olmasƒ± durumunda bile
     * t√ºm alanƒ± kaplamasƒ±nƒ± saƒülar. Bu, 'justifyContent' gibi stillerin
     * (√∂rn: butonu en alta yapƒ±≈ütƒ±rmak) √ßalƒ±≈ümasƒ±na olanak tanƒ±r.
     */
    flexGrow: 1,
  },
});
</file>

<file path="contexts/AuthContext.tsx">
import { createOrUpdateUserProfile, getProviderFromUser, normalizeUserData } from '@/api/provider-auth';
import { supabase } from '@/api/supabase';
import { useCurrentUser, useUpdateUser, userKeys } from '@/api/users';
import { getOneSignalPlayerId, loginOneSignal, logoutOneSignal } from '@/services/onesignal';
import type { User as DatabaseUser } from '@/types/database';
import { Session } from '@supabase/supabase-js';
import { useQueryClient } from '@tanstack/react-query';
import React, { createContext, useCallback, useContext, useEffect, useState } from 'react';

// Auth Context'i olu≈ütur.
// Bu context, sadece oturum bilgilerini ve kullanƒ±cƒ± profilini tutacak.
// Geri kalan t√ºm verileri (gruplar, durumlar vb.) TanStack Query y√∂netecek.
const AuthContext = createContext({
  session: null as Session | null,
  user: null as DatabaseUser | null,
  isLoading: true,
  initializeAuth: async () => {},
  signOut: async () => {},
});

// Auth Provider Component'i
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [session, setSession] = useState<Session | null>(null);
  const [user, setUser] = useState<DatabaseUser | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Mevcut kullanƒ±cƒ± profilini fetch et
  const { 
    data: currentUserProfile, 
    refetch: refetchUserProfile, 
    error: currentUserError,
    isLoading: currentUserLoading,
    isError: currentUserIsError
  } = useCurrentUser();
  const queryClient = useQueryClient();
  const updateUser = useUpdateUser();

  // √áƒ±kƒ±≈ü yapma fonksiyonu
  const signOut = useCallback(async () => {
    try {
      console.log('üîµ SignOut ba≈ülatƒ±lƒ±yor...');
      setIsLoading(true);
      
      const { error } = await supabase.auth.signOut();
      
      if (error) {
        console.error('‚ùå Sign out error:', error);
        throw error;
      }
      
      console.log('‚úÖ SignOut ba≈üarƒ±lƒ±, state temizleniyor...');
      // onAuthStateChange listener otomatik olarak SIGNED_OUT event'ini tetikleyecek
      // Orada state temizlenecek, burada sadece log'layalƒ±m
    } catch (error) {
      console.error('‚ùå Unexpected sign out error:', error);
      // Hata olsa bile state'i temizle
      setSession(null);
      setUser(null);
      setIsLoading(false);
      throw error;
    }
  }, []);

  // Auth initialization fonksiyonu
  const initializeAuth = useCallback(async () => {
    try {
      setIsLoading(true);
      
      // Mevcut session'ƒ± kontrol et
      const { data: { session: currentSession } } = await supabase.auth.getSession();
      
      if (currentSession) {
        setSession(currentSession);
        // User profile'ƒ± fetch et
        await refetchUserProfile();
        
        // Session varsa OneSignal login yap (app a√ßƒ±ldƒ±ƒüƒ±nda kullanƒ±cƒ± zaten login ise)
        const supabaseUser = currentSession.user;
        if (supabaseUser?.id) {
          console.log('üîµ App a√ßƒ±ldƒ±ƒüƒ±nda session var, OneSignal login yapƒ±lƒ±yor...');
          loginOneSignal(supabaseUser.id)
            .then(async () => {
              console.log('‚úÖ OneSignal login ba≈üarƒ±lƒ± (initializeAuth), Player ID kaydediliyor...');
              
              // Login ba≈üarƒ±lƒ± olduktan sonra Player ID'yi al ve kaydet
              // Biraz bekle, SDK'nƒ±n internal state'ini g√ºncellemesi i√ßin
              await new Promise(resolve => setTimeout(resolve, 500));
              
              const playerId = await getOneSignalPlayerId();
              if (playerId && supabaseUser.id) {
                try {
                  await updateUser.mutateAsync({
                    id: supabaseUser.id,
                    updates: { onesignal_player_id: playerId },
                  });
                  console.log('‚úÖ OneSignal Player ID kaydedildi (initializeAuth):', playerId);
                } catch (error: any) {
                  // Kullanƒ±cƒ± bulunamadƒ±ysa (DB'den silinmi≈üse), logout yap
                  if (error?.code === 'USER_NOT_FOUND' || error?.code === 'PGRST116') {
                    console.warn('‚ö†Ô∏è Kullanƒ±cƒ± DB\'de bulunamadƒ±, logout yapƒ±lƒ±yor...');
                    await signOut();
                  } else {
                    console.error('‚ùå OneSignal Player ID kaydetme hatasƒ± (initializeAuth):', error);
                    // Player ID kaydetme hatasƒ± kritik deƒüil, devam et
                  }
                }
              } else {
                console.warn('‚ö†Ô∏è OneSignal Player ID alƒ±namadƒ±, kaydedilemedi (initializeAuth). Subscription hen√ºz olu≈ümamƒ±≈ü olabilir.');
                // Player ID yoksa, subscription olu≈üunca otomatik olarak kaydedilecek
              }
            })
            .catch((error) => {
              console.error('‚ùå OneSignal login hatasƒ± (initializeAuth, non-blocking):', error);
              // OneSignal login hatasƒ± kritik deƒüil, uygulama √ßalƒ±≈ümaya devam eder
              console.warn('‚ö†Ô∏è OneSignal login ba≈üarƒ±sƒ±z oldu (initializeAuth). Kullanƒ±cƒ± bildirimleri alamayabilir. Hata:', error.message || error);
            });
        }
      } else {
        setSession(null);
        setUser(null);
      }
    } catch (error) {
      console.error('Auth initialization error:', error);
      setSession(null);
      setUser(null);
    } finally {
      setIsLoading(false);
    }
  }, [refetchUserProfile, updateUser, signOut]);

  // Auth state change listener - sadece session state'ini y√∂netir
  useEffect(() => {
    // ƒ∞lk session kontrol√º
    initializeAuth();

    // Auth state deƒüi≈üikliklerini dinle
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange(async (event, currentSession) => {
      console.log('üîµ Auth state changed:', event, currentSession?.user?.email);

      setSession(currentSession);

      if (currentSession?.user) {
        console.log('‚úÖ Auth state: User var, profil g√ºncelleniyor...');
        const supabaseUser = currentSession.user;
        const provider = getProviderFromUser(supabaseUser);
        const normalizedData = normalizeUserData(supabaseUser, provider);

        // Profil bilgilerini g√ºncelle (useCurrentUser hook'u profile'ƒ± fetch edecek)
        createOrUpdateUserProfile(normalizedData).then((result) => {
          // Kullanƒ±cƒ± bulunamadƒ±ysa (DB'den silinmi≈üse), logout yap
          const errorCode = (result.error as any)?.code;
          if (result.error && errorCode === 'USER_NOT_FOUND') {
            console.warn('‚ö†Ô∏è Kullanƒ±cƒ± DB\'de bulunamadƒ±, logout yapƒ±lƒ±yor...');
            signOut().catch((error) => {
              console.error('‚ùå Logout hatasƒ±:', error);
            });
          }
        }).catch((error) => {
          console.error('‚ùå Profile update error (non-blocking):', error);
        });

        // OneSignal'e kullanƒ±cƒ±yƒ± login et (external ID olarak Supabase auth ID)
        // Bu, OneSignal Dashboard'da kullanƒ±cƒ±yƒ± external ID ile bulmamƒ±zƒ± saƒülar
        // loginOneSignal i√ßinde zaten Player ID hazƒ±r olana kadar bekliyor ve retry mekanizmasƒ± var
        loginOneSignal(supabaseUser.id)
          .then(async () => {
            console.log('‚úÖ OneSignal login ba≈üarƒ±lƒ±, Player ID kaydediliyor...');
            
            // Login ba≈üarƒ±lƒ± olduktan sonra Player ID'yi al ve kaydet
            // Biraz bekle, SDK'nƒ±n internal state'ini g√ºncellemesi i√ßin
            await new Promise(resolve => setTimeout(resolve, 500));
            
            const playerId = await getOneSignalPlayerId();
            if (playerId && supabaseUser.id) {
              try {
                await updateUser.mutateAsync({
                  id: supabaseUser.id,
                  updates: { onesignal_player_id: playerId },
                });
                console.log('‚úÖ OneSignal Player ID kaydedildi:', playerId);
              } catch (error: any) {
                // Kullanƒ±cƒ± bulunamadƒ±ysa (DB'den silinmi≈üse), logout yap
                if (error?.code === 'USER_NOT_FOUND' || error?.code === 'PGRST116') {
                  console.warn('‚ö†Ô∏è Kullanƒ±cƒ± DB\'de bulunamadƒ±, logout yapƒ±lƒ±yor...');
                  await signOut();
                } else {
                  console.error('‚ùå OneSignal Player ID kaydetme hatasƒ±:', error);
                  // Player ID kaydetme hatasƒ± kritik deƒüil, devam et
                }
              }
            } else {
              console.warn('‚ö†Ô∏è OneSignal Player ID alƒ±namadƒ±, kaydedilemedi. Subscription hen√ºz olu≈ümamƒ±≈ü olabilir.');
              // Player ID yoksa, subscription olu≈üunca otomatik olarak kaydedilecek
            }
          })
          .catch((error) => {
            console.error('‚ùå OneSignal login hatasƒ± (non-blocking):', error);
            // OneSignal login hatasƒ± kritik deƒüil, uygulama √ßalƒ±≈ümaya devam eder
            // Ama kullanƒ±cƒ± bildirimleri alamayabilir
            console.warn('‚ö†Ô∏è OneSignal login ba≈üarƒ±sƒ±z oldu. Kullanƒ±cƒ± bildirimleri alamayabilir. Hata:', error.message || error);
          });

        // Session deƒüi≈ütiƒüinde query'yi invalidate et (useCurrentUser hook'u refetch yapacak)
        queryClient.invalidateQueries({ queryKey: userKeys.current() });
      } else {
        // SIGNED_OUT veya TOKEN_REFRESHED (session null) event'i
        console.log('üîµ Auth state: Session yok, cache temizleniyor...');
        setUser(null);
        
        // OneSignal'den logout et
        logoutOneSignal();
        
        // User ile ilgili t√ºm query'leri temizle
        queryClient.removeQueries({ queryKey: userKeys.all });
        console.log('‚úÖ User query cache temizlendi');
      }
    });

    return () => {
      subscription.unsubscribe();
    };
  }, [queryClient]);

  // Current user profile deƒüi≈ütiƒüinde state'i g√ºncelle
  useEffect(() => {
    if (currentUserProfile) {
      console.log('‚úÖ AuthContext: User profile set edildi:', currentUserProfile.id);
      setUser(currentUserProfile);
    } else {
      setUser(null);
    }
  }, [currentUserProfile]);

  // Kullanƒ±cƒ± bulunamadƒ±ƒüƒ±nda (DB'den silinmi≈üse) logout yap
  useEffect(() => {
    const errorCode = (currentUserError as any)?.code;
    if (currentUserError && errorCode === 'USER_NOT_FOUND' && session) {
      console.warn('‚ö†Ô∏è Kullanƒ±cƒ± DB\'de bulunamadƒ± (useCurrentUser), logout yapƒ±lƒ±yor...');
      signOut().catch((error) => {
        console.error('‚ùå Logout hatasƒ±:', error);
      });
    }
  }, [currentUserError, session, signOut]);

  // Loading state logic
  useEffect(() => {
    if (!session) {
      // Session yoksa loading false
      setIsLoading(false);
    } else if (session && currentUserProfile) {
      // Session var ve profile geldiyse loading false
      setIsLoading(false);
    } else if (session && !currentUserProfile) {
      // Session var ama profile hen√ºz yok
      // Eƒüer query hala loading ise ‚Üí loading true
      // Eƒüer query tamamlandƒ±ysa (isLoading false) ‚Üí loading false
      // Ama eƒüer error varsa ve USER_NOT_FOUND ise ‚Üí logout yapƒ±lacak (yukarƒ±daki useEffect'te)
      setIsLoading(currentUserLoading);
      
      // Eƒüer query tamamlandƒ± ama profile hala null ise ve error yoksa
      // Bu durumda database trigger hen√ºz √ßalƒ±≈ümamƒ±≈ü olabilir, biraz bekle
      if (!currentUserLoading && !currentUserError && !currentUserProfile) {
        console.log('‚è≥ Session var ama profile hen√ºz yok, database trigger bekleniyor...');
        // Bu durumda loading false yap (√ß√ºnk√º query tamamlandƒ±)
        // Ama kullanƒ±cƒ± g√∂sterilemez, bu normal (database trigger √ßalƒ±≈üana kadar)
      }
    }
  }, [session, currentUserProfile, currentUserLoading, currentUserError]);

  return (
    <AuthContext.Provider value={{ session, user, isLoading, initializeAuth, signOut }}>
      {children}
    </AuthContext.Provider>
  );
}

// Context'i kolayca kullanmak i√ßin custom hook.
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
</file>

<file path="localization/en.json">
{
  "appName": "Geliom"
}
</file>

<file path="localization/tr.json">
{
    "appName": "Geliom"
  }
</file>

<file path="theme/typography.ts">
export interface Fonts {
    light: string;
    regular: string;
    medium: string;
    semibold: string;
    bold: string;
}

interface TypographyVariant {
    fontSize: number;
    lineHeight: number;
    defaultFontWeight: keyof Fonts;
    letterSpacing?: number;
    fontVariant?: string[];
}

export type TypographyKeys = {
    // Ba≈ülƒ±k seviyeleri - Geliom i√ßin optimize edilmi≈ü
    h1: TypographyVariant;      // Ana ba≈ülƒ±k (Geliom logo, ana ekran)
    h2: TypographyVariant;      // Sayfa ba≈ülƒ±klarƒ±
    h3: TypographyVariant;      // B√∂l√ºm ba≈ülƒ±klarƒ±
    h4: TypographyVariant;      // Alt ba≈ülƒ±klar
    h5: TypographyVariant;      // K√º√ß√ºk ba≈ülƒ±klar
    h6: TypographyVariant;      // Mini ba≈ülƒ±klar
    
    // G√∂vde metinleri - Sosyal etkile≈üim i√ßin optimize
    body: TypographyVariant;    // Ana metin (mesajlar, a√ßƒ±klamalar)
    bodyLarge: TypographyVariant; // B√ºy√ºk g√∂vde metni
    bodySmall: TypographyVariant; // K√º√ß√ºk g√∂vde metni
    
    // √ñzel kullanƒ±mlar
    caption: TypographyVariant; // K√º√ß√ºk a√ßƒ±klamalar, zaman damgalarƒ±
    button: TypographyVariant;  // Buton metinleri
    label: TypographyVariant;   // Form etiketleri
    
    // Sosyal √∂zellikler i√ßin
    status: TypographyVariant;  // Durum metinleri ("M√ºsaitim", "Me≈ügul√ºm")
    nickname: TypographyVariant; // Takma isimler
    groupName: TypographyVariant; // Grup isimleri
};

// Comfortaa font ailesi - Geliom'un doƒüal ve samimi hissi i√ßin
export const fonts: Fonts = {
    light: 'Comfortaa-Light',
    regular: 'Comfortaa-Regular',
    medium: 'Comfortaa-Medium',
    semibold: 'Comfortaa-SemiBold',
    bold: 'Comfortaa-Bold',
};

export const typography: TypographyKeys = {
    // Ana ba≈ülƒ±k - Geliom logo ve ho≈ü geldin mesajlarƒ± i√ßin
    h1: {
        fontSize: 32,
        lineHeight: 40,
        defaultFontWeight: 'bold',
        letterSpacing: -0.5,
    },
    
    // Sayfa ba≈ülƒ±klarƒ± - "Gruplarƒ±m", "Profilim" gibi
    h2: {
        fontSize: 28,
        lineHeight: 36,
        defaultFontWeight: 'semibold',
        letterSpacing: -0.3,
    },
    
    // B√∂l√ºm ba≈ülƒ±klarƒ± - "Arkada≈ülar", "Aile" gibi grup kategorileri
    h3: {
        fontSize: 24,
        lineHeight: 32,
        defaultFontWeight: 'semibold',
        letterSpacing: -0.2,
    },
    
    // Alt ba≈ülƒ±klar - Grup isimleri, etkinlik ba≈ülƒ±klarƒ±
    h4: {
        fontSize: 20,
        lineHeight: 28,
        defaultFontWeight: 'medium',
        letterSpacing: 0,
    },
    
    // K√º√ß√ºk ba≈ülƒ±klar - Ayar kategorileri
    h5: {
        fontSize: 18,
        lineHeight: 24,
        defaultFontWeight: 'medium',
        letterSpacing: 0,
    },
    
    // Mini ba≈ülƒ±klar - Form ba≈ülƒ±klarƒ±
    h6: {
        fontSize: 16,
        lineHeight: 22,
        defaultFontWeight: 'medium',
        letterSpacing: 0,
    },
    
    // Ana g√∂vde metni - A√ßƒ±klamalar, mesajlar
    body: {
        fontSize: 16,
        lineHeight: 24,
        defaultFontWeight: 'regular',
        letterSpacing: 0,
    },
    
    // B√ºy√ºk g√∂vde metni - √ñnemli a√ßƒ±klamalar
    bodyLarge: {
        fontSize: 18,
        lineHeight: 26,
        defaultFontWeight: 'regular',
        letterSpacing: 0,
    },
    
    // K√º√ß√ºk g√∂vde metni - ƒ∞kincil bilgiler
    bodySmall: {
        fontSize: 14,
        lineHeight: 20,
        defaultFontWeight: 'regular',
        letterSpacing: 0,
    },
    
    // K√º√ß√ºk a√ßƒ±klamalar - Zaman damgalarƒ±, yardƒ±mcƒ± metinler
    caption: {
        fontSize: 12,
        lineHeight: 16,
        defaultFontWeight: 'regular',
        letterSpacing: 0.2,
    },
    
    // Buton metinleri - CTA butonlarƒ±
    button: {
        fontSize: 16,
        lineHeight: 20,
        defaultFontWeight: 'semibold',
        letterSpacing: 0.1,
    },
    
    // Form etiketleri
    label: {
        fontSize: 14,
        lineHeight: 18,
        defaultFontWeight: 'medium',
        letterSpacing: 0,
    },
    
    // Durum metinleri - "M√ºsaitim", "Me≈ügul√ºm" gibi
    status: {
        fontSize: 15,
        lineHeight: 20,
        defaultFontWeight: 'medium',
        letterSpacing: 0,
    },
    
    // Takma isimler - Ki≈üiselle≈ütirilmi≈ü isimler
    nickname: {
        fontSize: 16,
        lineHeight: 22,
        defaultFontWeight: 'medium',
        letterSpacing: 0,
    },
    
    // Grup isimleri - Grup kartlarƒ±nda
    groupName: {
        fontSize: 18,
        lineHeight: 24,
        defaultFontWeight: 'semibold',
        letterSpacing: -0.1,
    },
};
</file>

<file path="types/database.ts">
export interface User {
  id: string; // UUID - auth.users'dan referans
  custom_user_id: string; // TEXT UK - 8 karakterli unique kod (grup davetiyesi i√ßin)
  email?: string; // TEXT - Kullanƒ±cƒ± email adresi
  display_name?: string; // TEXT
  photo_url?: string; // TEXT
  /** @deprecated Use user_group_moods table instead. This field is kept for backward compatibility. */
  mood_id?: number; // INT FK - moods tablosuna referans (DEPRECATED - use user_group_moods)
  show_mood?: boolean; // BOOLEAN
  onesignal_player_id?: string; // TEXT
  updated_at?: string; // TIMESTAMPTZ
}

export interface Mood {
  id: number; // INT PK
  text: string; // TEXT UK
  emoji?: string; // TEXT
}

export interface Group {
  id: string; // UUID PK
  owner_id: string; // UUID FK
  type: string; // TEXT NOT NULL
  name: string; // TEXT
  invite_code: string; // TEXT UK
  member_limit?: number; // INT
  created_at?: string; // TIMESTAMPTZ
}

export interface GroupMember {
  group_id: string; // UUID PK, FK
  user_id: string; // UUID PK, FK
  joined_at?: string; // TIMESTAMPTZ
}

export interface Nickname {
  group_id: string; // UUID PK, FK
  setter_user_id: string; // UUID PK, FK
  target_user_id: string; // UUID PK, FK
  nickname: string; // TEXT
}

export interface Status {
  id: number; // INT PK
  text: string; // TEXT
  notifies: boolean; // BOOLEAN NOT NULL DEFAULT false
  is_custom: boolean; // BOOLEAN NOT NULL DEFAULT false
  owner_id?: string; // UUID FK - Eƒüer custom ise sahibi
  messages?: string[]; // TEXT[] - Bildirim mesajlarƒ± (rastgele se√ßilecek)
}

export interface UserStatus {
  user_id: string; // UUID PK, FK
  group_id?: string; // UUID FK - NULL ise global status (t√ºm gruplar i√ßin ge√ßerli)
  status_id: number; // INT FK
  updated_at?: string; // TIMESTAMPTZ
}

export interface UserGroupMood {
  user_id: string; // UUID PK, FK
  group_id?: string; // UUID FK - NULL ise global mood (t√ºm gruplar i√ßin ge√ßerli)
  mood_id: number; // INT FK
  updated_at?: string; // TIMESTAMPTZ
}

export interface MutedNotification {
  muter_user_id: string; // UUID PK, FK
  muted_user_id: string; // UUID PK, FK
}

export interface Subscription {
  user_id: string; // UUID PK, FK
  status: string; // TEXT
  expires_at?: string; // TIMESTAMPTZ
}

export interface ScheduledEvent {
  id: string; // UUID PK
  group_id: string; // UUID FK
  creator_id: string; // UUID FK
  title: string; // TEXT
  event_time: string; // TIMESTAMPTZ
  notification_time?: string; // TIMESTAMPTZ
  created_at?: string; // TIMESTAMPTZ
}

export interface GroupJoinRequest {
  id: string; // UUID PK
  group_id: string; // UUID FK
  requester_id: string; // UUID FK
  status: 'pending' | 'approved' | 'rejected'; // TEXT
  created_at?: string; // TIMESTAMPTZ
  updated_at?: string; // TIMESTAMPTZ
}

// Create/Update types (without auto-generated fields)
export type CreateUser = Omit<User, 'id' | 'updated_at'>;
export type UpdateUser = Partial<Omit<User, 'id'>>;

export type CreateMood = Omit<Mood, 'id'>;
export type UpdateMood = Partial<Omit<Mood, 'id'>>;

export type CreateGroup = Omit<Group, 'id' | 'created_at'>;
export type UpdateGroup = Partial<Omit<Group, 'id' | 'created_at'>>;

export type CreateGroupMember = Omit<GroupMember, 'joined_at'>;

export type CreateNickname = Nickname;
export type UpdateNickname = Partial<Omit<Nickname, 'group_id' | 'setter_user_id' | 'target_user_id'>>;

export type CreateStatus = Omit<Status, 'id'>;
export type UpdateStatus = Partial<Omit<Status, 'id'>>;

export type CreateUserStatus = Omit<UserStatus, 'updated_at'>;
export type UpdateUserStatus = Partial<Omit<UserStatus, 'user_id' | 'group_id' | 'updated_at'>>;

export type CreateUserGroupMood = Omit<UserGroupMood, 'updated_at'>;
export type UpdateUserGroupMood = Partial<Omit<UserGroupMood, 'user_id' | 'group_id' | 'updated_at'>>;

export type CreateMutedNotification = MutedNotification;

export type CreateSubscription = Subscription;
export type UpdateSubscription = Partial<Omit<Subscription, 'user_id'>>;

export type CreateScheduledEvent = Omit<ScheduledEvent, 'id' | 'created_at'>;
export type UpdateScheduledEvent = Partial<Omit<ScheduledEvent, 'id' | 'created_at'>>;

export type CreateGroupJoinRequest = Omit<GroupJoinRequest, 'id' | 'created_at' | 'updated_at' | 'status'>;
export type UpdateGroupJoinRequest = Partial<Omit<GroupJoinRequest, 'id' | 'group_id' | 'requester_id' | 'created_at'>>;

// Response types with relations
export interface UserWithMood extends User {
  mood?: Mood;
}

export interface GroupWithOwner extends Group {
  owner?: User;
  members?: GroupMember[];
}

export interface GroupMemberWithUser extends GroupMember {
  user?: User;
}

export interface UserStatusWithStatus extends UserStatus {
  status?: Status;
}

export interface UserGroupMoodWithMood extends UserGroupMood {
  mood?: Mood;
}

export interface ScheduledEventWithDetails extends ScheduledEvent {
  group?: Group;
  creator?: User;
}

export interface GroupJoinRequestWithDetails extends GroupJoinRequest {
  group?: GroupWithOwner;
  requester?: User;
}

export interface PendingNotification {
  id: string; // UUID PK
  sender_id: string; // UUID FK
  receiver_ids: string[]; // UUID[]
  group_id: string; // UUID FK
  status_id: number; // INT FK
  scheduled_at: string; // TIMESTAMPTZ
  created_at?: string; // TIMESTAMPTZ
  updated_at?: string; // TIMESTAMPTZ
}

export type CreatePendingNotification = Omit<PendingNotification, 'id' | 'created_at' | 'updated_at'>;
export type UpdatePendingNotification = Partial<Omit<PendingNotification, 'id' | 'sender_id' | 'group_id' | 'created_at'>>;
</file>

<file path="types/user.ts">
// Geliom User Types - Supabase schema'ya uygun
// NOT: custom_user_id kaldƒ±rƒ±ldƒ± - Supabase auth.users UUID direkt kullanƒ±lƒ±yor

import type { User } from './database';

// GeliomUser artƒ±k database.ts'deki User tipini kullanƒ±yor
// Eski kullanƒ±mlar i√ßin backward compatibility
export type GeliomUser = User & {
  email?: string; // Auth'dan gelen email (users tablosunda yok)
  current_mood_id?: string; // mood_id ile aynƒ± (string format)
};

export interface UserMood {
  id: string;
  name: string;
  emoji: string;
  color: string;
}

export interface UserStatus {
  id: string;
  user_id: string;
  status_id: string;
  created_at: string;
  status: {
    id: string;
    name: string;
    emoji: string;
    color: string;
    notifies: boolean;
    is_custom: boolean;
  };
}

// Mock Data
export const MOCK_MOODS: UserMood[] = [
  { id: '1', name: 'Mutlu', emoji: 'üòä', color: '#4CAF50' },
  { id: '2', name: 'Heyecanlƒ±', emoji: 'ü§©', color: '#FF9800' },
  { id: '3', name: 'Sakin', emoji: 'üòå', color: '#2196F3' },
  { id: '4', name: 'Yorgun', emoji: 'üò¥', color: '#9E9E9E' },
  { id: '5', name: 'Enerjik', emoji: '‚ö°', color: '#FFEB3B' },
];

export const MOCK_STATUSES = [
  { id: '1', name: 'M√ºsaitim', emoji: '‚úÖ', color: '#4CAF50', notifies: true, is_custom: false },
  { id: '2', name: 'Me≈ügul√ºm', emoji: 'üî¥', color: '#F44336', notifies: true, is_custom: false },
  { id: '3', name: 'Dƒ±≈üarƒ±dayƒ±m', emoji: 'üö∂', color: '#2196F3', notifies: false, is_custom: false },
  { id: '4', name: 'Evdeyim', emoji: 'üè†', color: '#795548', notifies: false, is_custom: false },
  { id: '5', name: '√áalƒ±≈üƒ±yorum', emoji: 'üíª', color: '#607D8B', notifies: true, is_custom: false },
];

export const MOCK_USER: GeliomUser = {
  id: 'mock-user-123',
  custom_user_id: 'MOCK1234',
  email: 'hakan@geliom.app',
  display_name: 'Hakan Dursun',
  show_mood: true,
  current_mood_id: '1', // Mutlu
  onesignal_player_id: undefined,
  updated_at: new Date().toISOString(),
};

export const MOCK_SESSION = {
  access_token: 'mock-access-token',
  refresh_token: 'mock-refresh-token',
  expires_in: 3600,
  token_type: 'bearer',
  user: {
    id: MOCK_USER.id,
    email: MOCK_USER.email,
    user_metadata: {
      full_name: MOCK_USER.display_name,
      avatar_url: null,
    },
    app_metadata: {},
    aud: 'authenticated',
    created_at: MOCK_USER.created_at,
    updated_at: MOCK_USER.updated_at,
  },
};
</file>

<file path="app/(auth)/login.tsx">
import { signInWithApple, signInWithGoogle } from "@/api/provider-auth";
import { Typography } from "@/components/shared";
import { useTheme } from "@/contexts/ThemeContext";
import { Ionicons } from '@expo/vector-icons';
import * as AppleAuthentication from 'expo-apple-authentication';
import React, { useState } from 'react';
import {
  ActivityIndicator,
  Alert,
  Image,
  Platform,
  StyleSheet,
  TouchableOpacity,
  View,
} from "react-native";
import { SafeAreaView } from 'react-native-safe-area-context';

export default function Login() {
  const { colors } = useTheme();
  const [isLoadingGoogle, setIsLoadingGoogle] = useState(false);
  const [isLoadingApple, setIsLoadingApple] = useState(false);

  // Helper to manage loading state for both
  const isLoading = isLoadingGoogle || isLoadingApple;

  // Google ile giri≈ü
  const handleGoogleLogin = async () => {
    try {
      console.log('üîµ Google login ba≈ülatƒ±lƒ±yor...');
      setIsLoadingGoogle(true);

      const result = await signInWithGoogle();
      console.log('üîµ Google login sonucu:', result);

      if (result.error) {
        console.error('‚ùå Google login hatasƒ±:', result.error);
        if (result.error.code === 'CANCELLED') {
          console.log('‚ÑπÔ∏è Kullanƒ±cƒ± giri≈üi iptal etti');
          setIsLoadingGoogle(false); // Stop loading on cancel
          return;
        }

        Alert.alert('Hata', result.error.message || 'Google ile giri≈ü yapƒ±lamadƒ±');
        setIsLoadingGoogle(false); // Stop loading on error
        return;
      }

      console.log('‚úÖ OAuth flow ba≈üarƒ±yla tamamlandƒ±');
      // Auth state change listener will handle navigation,
      // so we can set loading to false here or let the listener manage it.
      // For a better UX, we'll let the listener handle the global auth state.
      // If auth state doesn't change, loading might get stuck.
      // Let's stop loading if the process finishes, auth listener will redirect anyway.
      // Note: If auth is fast, this might be okay.
      // If we *don't* set loading to false, we rely on the auth listener.
      // Let's keep the user's original logic: don't set loading to false on success.
    } catch (error) {
      console.error('‚ùå Google login exception:', error);
      Alert.alert('Hata', 'Google ile giri≈ü yapƒ±lamadƒ±');
      setIsLoadingGoogle(false); // Stop loading on exception
    }
  };

  // Apple ile giri≈ü
  const handleAppleLogin = async () => {
    try {
      setIsLoadingApple(true);

      const { error } = await signInWithApple();

      if (error) {
        if (error.code === 'CANCELLED') {
          console.log('‚ÑπÔ∏è Kullanƒ±cƒ± Apple giri≈üi iptal etti');
          // Important: Set loading to false on cancel
          setIsLoadingApple(false);
          return;
        }

        Alert.alert('Hata', error.message || 'Apple ile giri≈ü yapƒ±lamadƒ±');
        setIsLoadingApple(false); // Stop loading on error
        return;
      }

      // Ba≈üarƒ±lƒ± - auth state change listener y√∂nlendirecek
      // We don't set loading to false, similar to Google login
    } catch (error) {
      Alert.alert('Hata', 'Apple ile giri≈ü yapƒ±lamadƒ±');
      console.error('Apple login error:', error);
      setIsLoadingApple(false); // Stop loading on exception
    }
  };

  return (
    // Use the theme background color
    <SafeAreaView
      style={[styles.container, { backgroundColor: colors.background }]}
      edges={['top', 'bottom']}
    >
      {/* Main content area, centered and balanced */}
      <View style={styles.contentContainer}>

        {/* Top section with app icon, name, and description */}
        <View style={styles.topSection}>
          {/* Nature-themed icon */}
          <Image source={require('@/assets/images/icon.png')} style={styles.logoIcon} />
          <Typography variant="h2" color={colors.text} style={styles.appName}>
            Geliom
          </Typography>
          <Typography variant="bodyLarge" color={colors.secondaryText} style={styles.description}>
            Arkada≈ülarƒ±nla ve ailenle anlƒ±k baƒülantƒ± kur
          </Typography>
        </View>

        {/* Bottom section with login buttons and terms */}
        <View style={styles.bottomSection}>
          <View style={styles.buttonContainer}>
            {/* Google Login Button */}
            <TouchableOpacity
              style={[
                styles.loginButton,
                {
                  // Use cardBackground for better dark mode compatibility
                  backgroundColor: colors.cardBackground,
                  borderColor: colors.stroke,
                  shadowColor: colors.shadow,
                },
              ]}
              onPress={handleGoogleLogin}
              disabled={isLoading}
              activeOpacity={0.8}
            >
              {isLoadingGoogle ? (
                <ActivityIndicator size="small" color={colors.primary} />
              ) : (
                <Ionicons name="logo-google" size={24} color="#4285F4" />
              )}
              <Typography
                variant="button"
                color={colors.text}
                style={styles.buttonText}
              >
                Google ile Giri≈ü Yap
              </Typography>
              {/* Spacer view to keep text centered */}
              <View style={styles.buttonIconSpacer} />
            </TouchableOpacity>

            {/* Apple Login - Only show on iOS */}
            {Platform.OS === 'ios' && (
              <AppleAuthentication.AppleAuthenticationButton
                buttonType={AppleAuthentication.AppleAuthenticationButtonType.SIGN_IN}
                // WHITE_OUTLINE looks much better on light/dark themed backgrounds
                buttonStyle={AppleAuthentication.AppleAuthenticationButtonStyle.WHITE_OUTLINE}
                cornerRadius={16}
                style={styles.appleButton}
                onPress={handleAppleLogin}
                // Note: The Apple button has its own loading state,
                // so we don't need to check isLoadingApple here.
              />
            )}
          </View>

          {/* Terms and privacy */}
          <Typography variant="caption" color={colors.secondaryText} style={styles.termsText}>
            Giri≈ü yaparak Kullanƒ±m ≈ûartlarƒ± ve Gizlilik Politikasƒ±'nƒ± kabul etmi≈ü olursunuz
          </Typography>
        </View>
      </View>
    </SafeAreaView>
  );
}

// A more compact, centered, and theme-aware stylesheet
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  contentContainer: {
    flex: 1,
    justifyContent: 'space-around', // Balances top and bottom sections
    paddingHorizontal: 24,
    paddingVertical: 32,
  },
  topSection: {
    alignItems: 'center',
  },
  logoIcon: {
    width: 80,
    height: 80,
    marginBottom: 16,
  },
  appName: {
    textAlign: 'center',
    marginBottom: 8,
  },
  description: {
    textAlign: 'center',
    paddingHorizontal: 20,
  },
  bottomSection: {
    width: '100%',
  },
  buttonContainer: {
    width: '100%',
    gap: 16, // Space between buttons
    marginBottom: 24,
  },
  loginButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 18,
    paddingHorizontal: 24,
    borderRadius: 16,
    minHeight: 56, // Match Apple button height
    borderWidth: 1,
    // Shadow for depth
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 5,
    elevation: 3, // for Android
  },
  buttonText: {
    flex: 1, // Allows text to be centered
    textAlign: 'center',
    marginLeft: 12,
  },
  // This spacer helps center the text when the icon is on the left
  buttonIconSpacer: {
    width: 24, // Same width as the icon
  },
  appleButton: {
    height: 56, // Standard height
    width: '100%',
  },
  termsText: {
    textAlign: 'center',
    lineHeight: 18,
    paddingHorizontal: 20,
  },
});
</file>

<file path="app/(drawer)/_layout.tsx">
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { Drawer } from 'expo-router/drawer';
import React, { useCallback } from 'react';
import { ActivityIndicator, View } from 'react-native';
import { CustomDrawerContent } from '../../components';
import { GroupHeader, GroupListBottomSheet } from '../../components/shared';
import { useAuth } from '../../contexts/AuthContext';
import { useBottomSheet } from '../../contexts/BottomSheetContext';
import { useGroupContext } from '../../contexts/GroupContext';
import { useTheme } from '../../contexts/ThemeContext';

export default function DrawerLayout() {
    const { isLoading, session } = useAuth();
    const { selectedGroup, groups } = useGroupContext();
    const { openBottomSheet } = useBottomSheet();
    const { colors } = useTheme();
    const router = useRouter();

    const createHandleGroupHeaderPress = useCallback((navigation: any) => {
        return () => {
            if (!selectedGroup || groups.length === 0) {
                router.push('/(drawer)/(group)/create-group');
                return;
            }
            
            // Her a√ßƒ±lƒ±≈üta yeni key ile render et - context g√ºncellemelerini almak i√ßin
            openBottomSheet(<GroupListBottomSheet key={Date.now()} />, {
                snapPoints: ['60%'],
                enablePanDownToClose: true,
            });
        };
    }, [openBottomSheet, selectedGroup, groups, router]);

    if (isLoading) {
        return (
            <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: colors.background }}>
                <ActivityIndicator size="large" color={colors.primary} />
            </View>
        );
    }

    if (!session) return null;

    return (
        <Drawer
            drawerContent={(props) => <CustomDrawerContent {...props} />}
            screenOptions={{
                headerShown: true,
                headerStyle: {
                    backgroundColor: colors.background,
                    shadowColor: 'transparent',
                    elevation: 0, // Android g√∂lgesini kaldƒ±r
                    borderBottomWidth: 0, // iOS √ßizgisini kaldƒ±r
                },
                headerTintColor: colors.text,
                headerTitleStyle: {
                    fontFamily: 'Comfortaa-SemiBold',
                },
                headerTitleAlign: 'center', // Ba≈ülƒ±ƒüƒ± ortala
                drawerStyle: {
                    backgroundColor: colors.background,
                    width: '80%',
                },
                drawerActiveTintColor: colors.primary,
                drawerInactiveTintColor: colors.secondaryText,
                drawerLabelStyle: {
                    fontFamily: 'Comfortaa-Medium',
                    fontSize: 16,
                },
            }}
        >
            <Drawer.Screen
                name="home"
                options={({ navigation }) => ({
                    headerTitle: () => <GroupHeader group={selectedGroup} onPress={createHandleGroupHeaderPress(navigation)} />,
                    drawerLabel: 'Ana Sayfa',
                    drawerIcon: ({ color, size }) => (
                        <Ionicons name="home-outline" size={size} color={color} />
                    ),
                })}
            />
            {/* Diƒüer ekranlarƒ± gizliyoruz, single page hissi i√ßin */}
            <Drawer.Screen
                name="showroom"
                options={{
                    drawerItemStyle: { display: 'none' }
                }}
            />
            <Drawer.Screen
                name="api-test"
                options={{
                    drawerItemStyle: { display: 'none' }
                }}
            />
            <Drawer.Screen
                name="(group)"
                options={{
                    headerShown: false,
                    drawerItemStyle: { display: 'none' },
                }}
            />
        </Drawer>
    );
}
</file>

<file path="app/index.tsx">
import { useAuth } from "@/contexts/AuthContext";
import { useTheme } from "@/contexts/ThemeContext";
import { useRouter } from "expo-router";
import * as SplashScreen from 'expo-splash-screen';
import { useEffect } from "react";
import { ActivityIndicator, View } from "react-native";

export default function Index() {
  const { initializeAuth, isLoading, session } = useAuth();
  const { colors } = useTheme();
  const router = useRouter();

  // Auth'u ba≈ülat
  useEffect(() => {
    console.log('üîµ Index: Auth ba≈ülatƒ±lƒ±yor...');
    initializeAuth();
  }, [initializeAuth]);

  // Font'lar y√ºklenene kadar splash screen'i g√∂ster
  useEffect(() => {
    if (!isLoading) {
      console.log('üîµ Index: Loading tamamlandƒ±, splash screen gizleniyor');
      SplashScreen.hideAsync();
    }
  }, [isLoading]);

  // Routing _layout.tsx'te yapƒ±lƒ±yor, burada sadece loading g√∂ster
  // Eƒüer session varsa ve loading bitmi≈üse, _layout routing yapacak
  useEffect(() => {
    console.log('üîµ Index: State kontrol√º - isLoading:', isLoading, 'session:', !!session);
  }, [isLoading, session]);

  // Loading state
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
        backgroundColor: colors.background,
      }}
    >
      <ActivityIndicator size="large" color={colors.primary} />
    </View>
  );
}
</file>

<file path="components/shared/index.ts">
export { default as BaseLayout } from './BaseLayout';
export { default as BlurButton } from './BlurButton';
export { default as Button } from './Button';
export { default as GeliomButton } from './GeliomButton';
export { default as GroupHeader } from './GroupHeader';
export { default as GroupListBottomSheet } from './GroupListBottomSheet';
export { default as Popover } from './Popover';
export { default as CustomText } from './Text';
export { default as Typography } from './Typography';
</file>

<file path="theme/colors.ts">
// Light theme colors - Doƒüa temalƒ± ye≈üil tonlar
export const lightColors = {
  // Ana renkler - Canlƒ± ye≈üil tonlarƒ±
  primary: '#2E7D32',        // Orman ye≈üili
  secondary: '#4CAF50',      // √áimen ye≈üili
  tertiary: '#81C784',       // A√ßƒ±k ye≈üil
  
  // GeliomButton renkleri - Sadece kullanƒ±lan renkler
  forest: '#1B5E20',         // 9. Active state - Koyu orman ye≈üili
  sage: 'rgba(1, 121, 111, 0.5)',           // 13. Passive state - Ada√ßayƒ± ye≈üili
  pine: '#01796F',           // 17. Loading state - √áam ye≈üili
  // Gradient tonlarƒ± - Doƒüal ge√ßi≈üler
  linearGradient: ['#2E7D32', '#4CAF50'],
  
  // Metin renkleri
  text: '#1B5E20',           // Koyu ye≈üil metin
  secondaryText: '#4E7C4F',  // Orta ton ye≈üil
  lightText: '#81C784',      // A√ßƒ±k ye≈üil metin
  
  // Arkaplan renkleri
  background: '#F1F8E9',     // √áok a√ßƒ±k ye≈üil arkaplan
  secondaryBackground: '#E8F5E8', // ƒ∞kincil arkaplan
  cardBackground: '#FFFFFF', // Kart arkaplanƒ±
  
  // Sistem renkleri
  success: '#4CAF50',        // Ba≈üarƒ± ye≈üili
  warning: '#FF9800',        // Turuncu uyarƒ±
  error: '#F44336',          // Kƒ±rmƒ±zƒ± hata
  info: '#2196F3',           // Mavi bilgi
  
  // N√∂tr renkler
  black: '#1B5E20',          // Koyu ye≈üil siyah
  white: '#FFFFFF',          // Beyaz
  gray: '#9E9E9E',           // Gri
  lightGray: '#E0E0E0',      // A√ßƒ±k gri
  
  // Etkile≈üim renkleri
  disabled: '#C8E6C9',       // Pasif ye≈üil
  stroke: '#A5D6A7',         // √áer√ßeve ye≈üili
  shadow: 'rgba(46, 125, 50, 0.1)', // Ye≈üil g√∂lge
  
  // Blur ve overlay renkleri
  overlay: 'rgba(46, 125, 50, 0.6)',     // Ye≈üil overlay
  blurBackground: 'rgba(241, 248, 233, 0.8)', // Blur arkaplan
};

// Dark theme colors - Gece doƒüasƒ± temasƒ±
export const darkColors = {
  // Ana renkler - Daha yumu≈üak ye≈üil tonlar
  primary: '#4CAF50',        // Parlak ye≈üil
  secondary: '#66BB6A',      // Orta ye≈üil
  tertiary: '#81C784',       // A√ßƒ±k ye≈üil
  
  // GeliomButton renkleri - Dark mode versiyonlarƒ±
  forest: '#2E7D32',         // 9. Active state - Orman ye≈üili (daha a√ßƒ±k)
  sage: 'rgba(1, 121, 111, 0.5)',           // 13. Passive state - Ada√ßayƒ± ye≈üili (daha a√ßƒ±k)
  pine: '#26A69A',           // 17. Loading state - √áam ye≈üili (daha a√ßƒ±k)
  
  // Gradient tonlarƒ±
  linearGradient: ['#4CAF50', '#66BB6A'],
  
  // Metin renkleri
  text: '#E8F5E8',           // A√ßƒ±k ye≈üil metin
  secondaryText: '#A5D6A7',  // Orta ton ye≈üil
  lightText: '#C8E6C9',      // √áok a√ßƒ±k ye≈üil
  
  // Arkaplan renkleri
  background: '#0D1B0F',     // √áok koyu ye≈üil arkaplan
  secondaryBackground: '#1B2E1F', // ƒ∞kincil koyu arkaplan
  cardBackground: '#263238', // Kart arkaplanƒ±
  
  // Sistem renkleri
  success: '#4CAF50',        // Ba≈üarƒ± ye≈üili
  warning: '#FF9800',        // Turuncu uyarƒ±
  error: '#F44336',          // Kƒ±rmƒ±zƒ± hata
  info: '#2196F3',           // Mavi bilgi
  
  // N√∂tr renkler
  black: '#000000',          // Siyah
  white: '#E8F5E8',          // Ye≈üilimsi beyaz
  gray: '#616161',           // Gri
  lightGray: '#424242',      // Koyu gri
  
  // Etkile≈üim renkleri
  disabled: '#2E4B32',       // Pasif koyu ye≈üil
  stroke: '#4E7C4F',         // √áer√ßeve ye≈üili
  shadow: 'rgba(76, 175, 80, 0.2)', // Ye≈üil g√∂lge
  
  // Blur ve overlay renkleri
  overlay: 'rgba(76, 175, 80, 0.4)',     // Ye≈üil overlay
  blurBackground: 'rgba(13, 27, 15, 0.9)', // Blur arkaplan
};

export type Colors = typeof lightColors;
</file>

<file path="README.md">
# Welcome to your Expo app üëã

This is an [Expo](https://expo.dev) project created with [`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
   npx expo start
   ```

In the output, you'll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## Learn more

To learn more about developing your project with Expo, look at the following resources:

- [Expo documentation](https://docs.expo.dev/): Learn fundamentals, or go into advanced topics with our [guides](https://docs.expo.dev/guides).
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/): Follow a step-by-step tutorial where you'll create a project that runs on Android, iOS, and the web.

## Join the community

Join our community of developers creating universal apps.

- [Expo on GitHub](https://github.com/expo/expo): View our open source platform and contribute.
- [Discord community](https://chat.expo.dev): Chat with Expo users and ask questions.
# geliom
# geliom
</file>

<file path="app/_layout.tsx">
import { useAuth } from '@/contexts/AuthContext';
import { Slot, useRouter, useSegments } from 'expo-router';
import React, { useEffect } from 'react';
import Provider from './Provider';

// Ana Layout Component'i - Sadece yapƒ±yƒ± g√∂sterir ve routing yapar
function RootLayoutContent() {
  const { session, isLoading } = useAuth();
  const segments = useSegments();
  const router = useRouter();

  useEffect(() => {
    // Y√ºkleme tamamlanmadƒ±ysa bir ≈üey yapma.
    if (isLoading) {
      console.log('üîµ Layout: Loading, routing bekleniyor...');
      return;
    }

    console.log('üîµ Layout: Routing kontrol√º - session:', !!session, 'segments:', segments);
    
    const inAuthGroup = segments[0] === '(auth)';

    if (!session && !inAuthGroup) {
      console.log('üîµ Layout: Session yok, login sayfasƒ±na y√∂nlendiriliyor...');
      router.replace('/(auth)/login');
    }
    else if (session && inAuthGroup) {
      console.log('üîµ Layout: Session var ve auth grubunda, ana sayfaya y√∂nlendiriliyor...');
      router.replace('/(drawer)/home');
    }
    else if (session && !inAuthGroup) {
      console.log('üîµ Layout: Session var, zaten doƒüru sayfada');
    }
  }, [session, isLoading, segments, router]);

  // Y√∂nlendirme mantƒ±ƒüƒ± tamamlandƒ±ƒüƒ±nda, ilgili ekranƒ± g√∂ster.
  return <Slot />;
}

// Provider ile sarmalanmƒ±≈ü ana layout
export default function RootLayout() {
  return (
    <Provider>
      <RootLayoutContent />
    </Provider>
  );
}
</file>

<file path="package.json">
{
  "name": "geliom",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "lint": "expo lint",
    "dios": "npx expo run:ios -d"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.2",
    "@gorhom/bottom-sheet": "^5.2.6",
    "@legendapp/list": "^2.0.13",
    "@react-native-async-storage/async-storage": "2.2.0",
    "@react-native-community/netinfo": "11.4.1",
    "@react-navigation/bottom-tabs": "^7.4.0",
    "@react-navigation/drawer": "^7.5.0",
    "@react-navigation/elements": "^2.6.3",
    "@react-navigation/native": "^7.1.8",
    "@supabase/supabase-js": "^2.75.1",
    "@tanstack/react-query": "^5.90.5",
    "@tanstack/react-query-devtools": "^5.90.2",
    "expo": "54.0.23",
    "expo-apple-authentication": "~8.0.7",
    "expo-application": "~7.0.7",
    "expo-auth-session": "~7.0.8",
    "expo-blur": "~15.0.7",
    "expo-build-properties": "~1.0.9",
    "expo-clipboard": "~8.0.7",
    "expo-constants": "~18.0.9",
    "expo-crypto": "~15.0.7",
    "expo-device": "~8.0.9",
    "expo-font": "~14.0.9",
    "expo-haptics": "~15.0.7",
    "expo-image": "~3.0.10",
    "expo-linear-gradient": "~15.0.7",
    "expo-linking": "~8.0.8",
    "expo-localization": "~17.0.7",
    "expo-notifications": "~0.32.13",
    "expo-router": "~6.0.14",
    "expo-sharing": "~14.0.7",
    "expo-splash-screen": "~31.0.10",
    "expo-status-bar": "~3.0.8",
    "expo-symbols": "~1.0.7",
    "expo-system-ui": "~6.0.8",
    "expo-web-browser": "~15.0.9",
    "i18next": "^25.6.0",
    "lottie-react-native": "^7.3.4",
    "onesignal-expo-plugin": "^2.0.3",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-i18next": "^16.0.1",
    "react-native": "0.81.5",
    "react-native-adapty": "^3.11.2",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-onesignal": "^5.2.14",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-url-polyfill": "^3.0.0",
    "react-native-web": "~0.21.0",
    "react-native-worklets": "0.5.1"
  },
  "devDependencies": {
    "@tanstack/eslint-plugin-query": "^5.91.2",
    "@types/react": "~19.1.0",
    "eslint": "^9.25.0",
    "eslint-config-expo": "~10.0.0",
    "typescript": "~5.9.2"
  },
  "private": true
}
</file>

<file path="app.json">
{
  "expo": {
    "name": "Geliom",
    "slug": "geliom",
    "version": "0.0.1",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "geliom",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.eoist.geliom",
      "googleServicesFile": "./GoogleService-Info.plist",
      "entitlements": {
        "aps-environment": "production",
        "com.apple.developer.networking.wifi-info": true,
        "com.apple.security.application-groups": [
          "group.com.eoist.geliom.onesignal"
        ]
      },
      "infoPlist": {
        "UIBackgroundModes": [
          "remote-notification"
        ]
      },
      "appleTeamId": "NHKQ38KYTV"
    },
    "android": {
      "adaptiveIcon": {
        "backgroundColor": "#E6F4FE",
        "foregroundImage": "./assets/images/android-icon-foreground.png",
        "backgroundImage": "./assets/images/android-icon-background.png",
        "monochromeImage": "./assets/images/android-icon-monochrome.png"
      },
      "googleServicesFile": "./google-services.json",
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false,
      "package": "com.eoist.geliom"
    },
    "web": {
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff",
          "dark": {
            "backgroundColor": "#000000"
          }
        }
      ],
      [
        "onesignal-expo-plugin",
        {
          "mode": "production"
        }
      ],
      [
        "expo-build-properties",
        {
          "ios": {
            "deploymentTarget": "15.1"
          },
          "android": {
            "compileSdkVersion": 35,
            "targetSdkVersion": 35,
            "buildToolsVersion": "35.0.0"
          }
        }
      ],
      "expo-localization",
      [
        "expo-font",
        {
          "fonts": [
            "./assets/fonts/Comfortaa-Light.ttf",
            "./assets/fonts/Comfortaa-Regular.ttf",
            "./assets/fonts/Comfortaa-Medium.ttf",
            "./assets/fonts/Comfortaa-SemiBold.ttf",
            "./assets/fonts/Comfortaa-Bold.ttf"
          ]
        }
      ],
      "expo-web-browser",
      [
        "expo-notifications",
        {
          "icon": "./assets/images/icon.png",
          "color": "#2E7D32"
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true,
      "reactCompiler": true
    },
    "extra": {
      "router": {},
      "oneSignalAppId": "c3a9e24a-d8ef-42cb-8278-f171d2056a4d",
      "eas": {
        "projectId": "f2d7bad9-aa20-473b-ba30-acbdf499245c"
      }
    },
    "owner": "eoist"
  }
}
</file>

</files>
