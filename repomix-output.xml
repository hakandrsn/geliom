This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursor/
  rules/
    definiions.mdc
    generally.mdc
api/
  events.ts
  groups.ts
  index.ts
  moods.ts
  muted.ts
  nicknames.ts
  notifications.ts
  provider-auth.ts
  README.md
  statuses.ts
  subscriptions.ts
  supabase.ts
  users.ts
app/
  (auth)/
    _layout.tsx
    callback.tsx
    login.tsx
  (drawer)/
    (group)/
      _layout.tsx
      create-group.tsx
      group-management.tsx
      join-group.tsx
      join-requests.tsx
      manage-members.tsx
      reorder-status-mood.tsx
      search-user.tsx
    _layout.tsx
    help-support.tsx
    home.tsx
    search-user.tsx
    settings.tsx
    showroom.tsx
  _layout.tsx
  index.tsx
  Provider.tsx
assets/
  avatars/
    bear.png
    man-1.png
    man-2.png
    man-3.png
    man-4.png
    man-5.png
    woman-1.png
    woman-2.png
    woman-3.png
    woman-4.png
    woman-5.png
  fonts/
    Comfortaa-Bold.ttf
    Comfortaa-Light.ttf
    Comfortaa-Medium.ttf
    Comfortaa-Regular.ttf
    Comfortaa-SemiBold.ttf
  images/
    android-icon-background.png
    android-icon-foreground.png
    android-icon-monochrome.png
    favicon.png
    icon.png
    partial-react-logo.png
    react-logo.png
    react-logo@2x.png
    react-logo@3x.png
    splash-icon.png
    t-icon.png
components/
  anim/
    AnimatedComponents.tsx
  dashboard/
    AddStatusMoodModal.tsx
    CurrentUserHeader.tsx
    DashboardView.tsx
    EmptyStateView.tsx
    index.ts
    MemberCard.tsx
    MoodSelector.tsx
    StatusSelector.tsx
  shared/
    AvatarSelector.tsx
    BaseLayout.tsx
    BlurButton.tsx
    Button.tsx
    GeliomButton.tsx
    GroupHeader.tsx
    GroupListBottomSheet.tsx
    index.ts
    Popover.tsx
    SplashScreen.tsx
    Text.tsx
    Typography.tsx
  ui/
    index.ts
    NetworkToast.tsx
  CustomDrawerContent.tsx
  index.ts
  KeyboardAwareView.tsx
  NotificationHandler.tsx
constants/
  adapty.ts
contexts/
  AuthContext.tsx
  BottomSheetContext.tsx
  GroupContext.tsx
  NetworkToastContext.tsx
  PayContext.tsx
  ThemeContext.tsx
docs/
  BaseLayout-usage.md
  bildirim-sistemi.md
  Component-Showroom.md
  cron-job-setup.md
  database-function-update.sql
  database-migration-create-join-request-rpc.sql
  database-migration-custom-status-mood-group-based.sql
  database-migration-group-based-status-mood.sql
  database-migration-status-emoji.sql
  database-migration-status-notifications.sql
  database-rate-limiting-migration.sql
  database-realtime-fix.sql
  edge-function-secrets-setup.md
  expo-notifications-kullanim.md
  faz2-todo.md
  future-packages.md
  GeliomButton-Documentation.md
  KULLANICI_YAPILACAKLAR.md
  Login-System-usage.md
  Mock-Development-Setup.md
  onesignal-api-key-setup.md
  onesignal-fix-checklist.md
  onesignal-ios-fix-checklist.md
  onesignal-player-id-test.md
  onesignal-test-notification.md
  onesignal-troubleshooting.md
  prebuild-checklist.md
  Professional-Auth-System.md
  project-flow.md
  project-mermaid.md
  rate-limiting-implementation.md
  rate-limiting-plan.md
  realtime-implementation-summary.md
  realtime-join-requests.md
  realtime-tables-list.md
  realtime-troubleshooting.md
  status-notification-system.md
  supabase-oauth-setup.md
  Theme-Typography-usage.md
hooks/
  useAppInitialization.ts
  useManageStatusMood.ts
  useNetworkStatus.ts
localization/
  en.json
  tr.json
services/
  notification-handler.ts
  onesignal.ts
supabase/
  functions/
    process-pending-notifications/
      index.ts
    send-notification/
      index.ts
theme/
  colors.ts
  typography.ts
types/
  auth.ts
  database.ts
  user.ts
utils/
  avatar.ts
  group-type-selector.ts
  linking.ts
  storage.ts
.gitignore
app.json
build-1764090188411.ipa
eas.json
eslint.config.js
google-services.json
GoogleService-Info.plist
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/(auth)/_layout.tsx">
import { Stack } from "expo-router";

export default function AuthLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      <Stack.Screen name="login" />
      <Stack.Screen name="callback" />
    </Stack>
  );
}
</file>

<file path="app/(auth)/callback.tsx">
import { SplashScreen as CustomSplashScreen } from "@/components/shared";
import { useRouter } from 'expo-router';
import React, { useEffect } from 'react';

/**
 * OAuth Callback Handler
 * 
 * Google/Apple OAuth'dan dÃ¶ndÃ¼kten sonra bu sayfaya yÃ¶nlendiriliyor.
 * URL'den tokens alÄ±nÄ±p session oluÅŸturulana kadar splash screen gÃ¶steriliyor.
 * 
 * NOT: Token parsing ve session oluÅŸturma iÅŸlemi provider-auth.ts'te yapÄ±lÄ±yor.
 * Bu sayfa sadece OAuth callback URL'ini handle etmek iÃ§in var.
 * 
 * Auth state change listener otomatik olarak home'a yÃ¶nlendirecek.
 */
export default function AuthCallback() {
  const router = useRouter();

  useEffect(() => {
    // OAuth callback URL'i handle ediliyor (provider-auth.ts'te)
    // Auth state change listener otomatik routing yapacak
    // Bu sayfa sadece geÃ§ici bir placeholder
    console.log('ğŸ”µ OAuth callback sayfasÄ± yÃ¼klendi, auth state deÄŸiÅŸikliÄŸi bekleniyor...');
  }, []);

  // Auth state change listener routing yapana kadar splash screen gÃ¶ster
  return <CustomSplashScreen />;
}
</file>

<file path=".cursor/rules/definiions.mdc">
---
alwaysApply: true
description: supabase table definitions
---

**users** 
create table public.users (
  id uuid not null,
  custom_user_id text not null,
  email text null,
  display_name text null,
  photo_url text null,
  show_mood boolean not null default false,
  onesignal_player_id text null,
  updated_at timestamp with time zone null default now(),
  mood_id integer null,
  constraint users_pkey primary key (id),
  constraint users_custom_user_id_key unique (custom_user_id),
  constraint users_id_fkey foreign KEY (id) references auth.users (id) on delete CASCADE,
  constraint users_mood_id_fkey foreign KEY (mood_id) references moods (id)
) TABLESPACE pg_default;

**user_statuses**
create table public.user_statuses (
  user_id uuid not null,
  status_id integer not null,
  updated_at timestamp with time zone null default now(),
  constraint user_statuses_pkey primary key (user_id),
  constraint user_statuses_status_id_fkey foreign KEY (status_id) references statuses (id),
  constraint user_statuses_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE
) TABLESPACE pg_default;

**subcriptions**
create table public.subscriptions (
  user_id uuid not null,
  status text not null default 'free'::text,
  expires_at timestamp with time zone null,
  constraint subscriptions_pkey primary key (user_id),
  constraint subscriptions_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE
) TABLESPACE pg_default;

**statuses**
create table public.statuses (
  id serial not null,
  text text not null,
  notifies boolean not null default false,
  is_custom boolean not null default false,
  owner_id uuid null,
  constraint statuses_pkey primary key (id),
  constraint statuses_owner_id_fkey foreign KEY (owner_id) references users (id) on delete set null
) TABLESPACE pg_default;

**scheduled_events**
create table public.scheduled_events (
  id uuid not null default gen_random_uuid (),
  group_id uuid not null,
  creator_id uuid not null,
  title text not null,
  event_time timestamp with time zone not null,
  notification_time timestamp with time zone null,
  created_at timestamp with time zone null default now(),
  constraint scheduled_events_pkey primary key (id),
  constraint scheduled_events_creator_id_fkey foreign KEY (creator_id) references users (id) on delete CASCADE,
  constraint scheduled_events_group_id_fkey foreign KEY (group_id) references groups (id) on delete CASCADE
) TABLESPACE pg_default;

**nicknames**
create table public.nicknames (
  group_id uuid not null,
  setter_user_id uuid not null,
  target_user_id uuid not null,
  nickname text not null,
  constraint nicknames_pkey primary key (group_id, setter_user_id, target_user_id),
  constraint nicknames_group_id_fkey foreign KEY (group_id) references groups (id) on delete CASCADE,
  constraint nicknames_setter_user_id_fkey foreign KEY (setter_user_id) references users (id) on delete CASCADE,
  constraint nicknames_target_user_id_fkey foreign KEY (target_user_id) references users (id) on delete CASCADE
) TABLESPACE pg_default;

**muted_notifications**
create table public.muted_notifications (
  muter_user_id uuid not null,
  muted_user_id uuid not null,
  constraint muted_notifications_pkey primary key (muter_user_id, muted_user_id),
  constraint muted_notifications_muted_user_id_fkey foreign KEY (muted_user_id) references users (id) on delete CASCADE,
  constraint muted_notifications_muter_user_id_fkey foreign KEY (muter_user_id) references users (id) on delete CASCADE
) TABLESPACE pg_default;

**moods**
create table public.moods (
  id serial not null,
  text text not null,
  emoji text null,
  constraint moods_pkey primary key (id),
  constraint moods_text_key unique (text)
) TABLESPACE pg_default;

**groups**
create table public.groups (
  id uuid not null default gen_random_uuid (),
  owner_id uuid not null,
  type text not null,
  name text not null,
  invite_code text not null,
  member_limit integer not null default 5,
  created_at timestamp with time zone null default now(),
  constraint groups_pkey primary key (id),
  constraint groups_invite_code_key unique (invite_code),
  constraint groups_owner_id_fkey foreign KEY (owner_id) references users (id) on delete CASCADE
) TABLESPACE pg_default;

**group_members**
create table public.group_members (
  group_id uuid not null,
  user_id uuid not null,
  joined_at timestamp with time zone null default now(),
  constraint group_members_pkey primary key (group_id, user_id),
  constraint group_members_group_id_fkey foreign KEY (group_id) references groups (id) on delete CASCADE,
  constraint group_members_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE
) TABLESPACE pg_default;
</file>

<file path="api/events.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import type {
    CreateScheduledEvent,
    ScheduledEvent,
    ScheduledEventWithDetails,
    UpdateScheduledEvent
} from '../types/database';
import { supabase } from './supabase';

// Query Keys
export const eventKeys = {
  all: ['events'] as const,
  lists: () => [...eventKeys.all, 'list'] as const,
  list: (filters: string) => [...eventKeys.lists(), { filters }] as const,
  details: () => [...eventKeys.all, 'detail'] as const,
  detail: (id: string) => [...eventKeys.details(), id] as const,
  group: (groupId: string) => [...eventKeys.all, 'group', groupId] as const,
  user: (userId: string) => [...eventKeys.all, 'user', userId] as const,
  upcoming: (groupId: string) => [...eventKeys.group(groupId), 'upcoming'] as const,
};

// Queries
export const useGroupEvents = (groupId: string) => {
  return useQuery({
    queryKey: eventKeys.group(groupId),
    queryFn: async (): Promise<ScheduledEventWithDetails[]> => {
      const { data, error } = await supabase
        .from('scheduled_events')
        .select(`
          *,
          group:groups(*),
          creator:users(*)
        `)
        .eq('group_id', groupId)
        .order('event_time');
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!groupId,
  });
};

export const useUpcomingGroupEvents = (groupId: string) => {
  return useQuery({
    queryKey: eventKeys.upcoming(groupId),
    queryFn: async (): Promise<ScheduledEventWithDetails[]> => {
      const now = new Date().toISOString();
      
      const { data, error } = await supabase
        .from('scheduled_events')
        .select(`
          *,
          group:groups(*),
          creator:users(*)
        `)
        .eq('group_id', groupId)
        .gte('event_time', now)
        .order('event_time');
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!groupId,
  });
};

export const useUserCreatedEvents = (userId: string) => {
  return useQuery({
    queryKey: eventKeys.user(userId),
    queryFn: async (): Promise<ScheduledEventWithDetails[]> => {
      const { data, error } = await supabase
        .from('scheduled_events')
        .select(`
          *,
          group:groups(*),
          creator:users(*)
        `)
        .eq('creator_id', userId)
        .order('event_time');
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!userId,
  });
};

export const useEvent = (id: string) => {
  return useQuery({
    queryKey: eventKeys.detail(id),
    queryFn: async (): Promise<ScheduledEventWithDetails | null> => {
      const { data, error } = await supabase
        .from('scheduled_events')
        .select(`
          *,
          group:groups(*),
          creator:users(*)
        `)
        .eq('id', id)
        .single();
      
      if (error) throw error;
      return data;
    },
    enabled: !!id,
  });
};

// KullanÄ±cÄ±nÄ±n dahil olduÄŸu tÃ¼m gruplardaki eventleri getir
export const useUserGroupsEvents = (userId: string) => {
  return useQuery({
    queryKey: [...eventKeys.all, 'user-groups', userId],
    queryFn: async (): Promise<ScheduledEventWithDetails[]> => {
      // Ã–nce kullanÄ±cÄ±nÄ±n dahil olduÄŸu gruplarÄ± al
      const { data: userGroups, error: groupsError } = await supabase
        .from('group_members')
        .select('group_id')
        .eq('user_id', userId);
      
      if (groupsError) throw groupsError;
      
      if (!userGroups || userGroups.length === 0) return [];
      
      const groupIds = userGroups.map(g => g.group_id);
      
      // Bu gruplardaki eventleri al
      const { data, error } = await supabase
        .from('scheduled_events')
        .select(`
          *,
          group:groups(*),
          creator:users(*)
        `)
        .in('group_id', groupIds)
        .order('event_time');
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!userId,
  });
};

// Mutations
export const useCreateEvent = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (eventData: CreateScheduledEvent): Promise<ScheduledEvent> => {
      const { data, error } = await supabase
        .from('scheduled_events')
        .insert(eventData)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: eventKeys.all });
      queryClient.invalidateQueries({ queryKey: eventKeys.group(data.group_id) });
      queryClient.invalidateQueries({ queryKey: eventKeys.user(data.creator_id) });
    },
  });
};

export const useUpdateEvent = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ 
      id, 
      updates 
    }: { 
      id: string; 
      updates: UpdateScheduledEvent;
    }): Promise<ScheduledEvent> => {
      const { data, error } = await supabase
        .from('scheduled_events')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: eventKeys.all });
      queryClient.invalidateQueries({ queryKey: eventKeys.detail(data.id) });
      queryClient.invalidateQueries({ queryKey: eventKeys.group(data.group_id) });
      queryClient.invalidateQueries({ queryKey: eventKeys.user(data.creator_id) });
    },
  });
};

export const useDeleteEvent = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (id: string): Promise<void> => {
      const { error } = await supabase
        .from('scheduled_events')
        .delete()
        .eq('id', id);
      
      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: eventKeys.all });
    },
  });
};

// Realtime Subscription Hooks
export const useGroupEventsRealtime = (groupId: string) => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['group-events-realtime', groupId],
    queryFn: () => {
      const channel = supabase
        .channel(`group-events-changes-${groupId}`)
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'scheduled_events',
            filter: `group_id=eq.${groupId}`,
          },
          () => {
            queryClient.invalidateQueries({ queryKey: eventKeys.group(groupId) });
            queryClient.invalidateQueries({ queryKey: eventKeys.upcoming(groupId) });
          }
        )
        .subscribe();

      return channel;
    },
    enabled: !!groupId,
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};

export const useEventsRealtime = () => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['events-realtime'],
    queryFn: () => {
      const channel = supabase
        .channel('events-changes')
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'scheduled_events',
          },
          () => {
            queryClient.invalidateQueries({ queryKey: eventKeys.all });
          }
        )
        .subscribe();

      return channel;
    },
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};
</file>

<file path="api/muted.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import type { MutedNotification } from '../types/database';
import { supabase } from './supabase';

// Query Keys
export const mutedKeys = {
  all: ['muted-notifications'] as const,
  user: (userId: string) => [...mutedKeys.all, 'user', userId] as const,
  check: (muterUserId: string, mutedUserId: string) => 
    [...mutedKeys.all, 'check', muterUserId, mutedUserId] as const,
};

// Queries
export const useMutedNotifications = (userId: string) => {
  return useQuery({
    queryKey: mutedKeys.user(userId),
    queryFn: async (): Promise<MutedNotification[]> => {
      const { data, error } = await supabase
        .from('muted_notifications')
        .select('*')
        .eq('muter_user_id', userId);
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!userId,
  });
};

export const useIsMuted = (muterUserId: string, mutedUserId: string) => {
  return useQuery({
    queryKey: mutedKeys.check(muterUserId, mutedUserId),
    queryFn: async (): Promise<boolean> => {
      const { data, error } = await supabase
        .from('muted_notifications')
        .select('muted_user_id')
        .eq('muter_user_id', muterUserId)
        .eq('muted_user_id', mutedUserId)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      return !!data;
    },
    enabled: !!(muterUserId && mutedUserId),
  });
};

// Mutations
export const useMuteUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ muterUserId, mutedUserId }: { muterUserId: string; mutedUserId: string }): Promise<MutedNotification> => {
      const { data, error } = await supabase
        .from('muted_notifications')
        .insert({ muter_user_id: muterUserId, muted_user_id: mutedUserId })
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: mutedKeys.all });
      queryClient.invalidateQueries({ queryKey: mutedKeys.user(data.muter_user_id) });
      queryClient.invalidateQueries({ queryKey: mutedKeys.check(data.muter_user_id, data.muted_user_id) });
    },
  });
};

export const useUnmuteUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ muterUserId, mutedUserId }: { muterUserId: string; mutedUserId: string }): Promise<void> => {
      const { error } = await supabase
        .from('muted_notifications')
        .delete()
        .eq('muter_user_id', muterUserId)
        .eq('muted_user_id', mutedUserId);
      
      if (error) throw error;
    },
    onSuccess: (_, { muterUserId, mutedUserId }) => {
      queryClient.invalidateQueries({ queryKey: mutedKeys.all });
      queryClient.invalidateQueries({ queryKey: mutedKeys.user(muterUserId) });
      queryClient.invalidateQueries({ queryKey: mutedKeys.check(muterUserId, mutedUserId) });
    },
  });
};

export const useToggleMuteUser = () => {
  const queryClient = useQueryClient();
  const muteUser = useMuteUser();
  const unmuteUser = useUnmuteUser();
  
  return useMutation({
    mutationFn: async ({ muterUserId, mutedUserId, isCurrentlyMuted }: { 
      muterUserId: string; 
      mutedUserId: string; 
      isCurrentlyMuted: boolean;
    }): Promise<void> => {
      if (isCurrentlyMuted) {
        await unmuteUser.mutateAsync({ muterUserId, mutedUserId });
      } else {
        await muteUser.mutateAsync({ muterUserId, mutedUserId });
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: mutedKeys.all });
    },
  });
};
</file>

<file path="api/nicknames.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import type {
    CreateNickname,
    Nickname,
    UpdateNickname
} from '../types/database';
import { supabase } from './supabase';

// Query Keys
export const nicknameKeys = {
  all: ['nicknames'] as const,
  lists: () => [...nicknameKeys.all, 'list'] as const,
  list: (filters: string) => [...nicknameKeys.lists(), { filters }] as const,
  group: (groupId: string) => [...nicknameKeys.all, 'group', groupId] as const,
  user: (userId: string) => [...nicknameKeys.all, 'user', userId] as const,
  specific: (groupId: string, setterUserId: string, targetUserId: string) => 
    [...nicknameKeys.all, 'specific', groupId, setterUserId, targetUserId] as const,
};

// Queries
export const useGroupNicknames = (groupId: string) => {
  return useQuery({
    queryKey: nicknameKeys.group(groupId),
    queryFn: async (): Promise<Nickname[]> => {
      const { data, error } = await supabase
        .from('nicknames')
        .select('*')
        .eq('group_id', groupId);
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!groupId,
  });
};

export const useUserNicknames = (userId: string) => {
  return useQuery({
    queryKey: nicknameKeys.user(userId),
    queryFn: async (): Promise<Nickname[]> => {
      const { data, error } = await supabase
        .from('nicknames')
        .select('*')
        .eq('target_user_id', userId);
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!userId,
  });
};

export const useUserSetNicknames = (userId: string) => {
  return useQuery({
    queryKey: [...nicknameKeys.user(userId), 'set'],
    queryFn: async (): Promise<Nickname[]> => {
      const { data, error } = await supabase
        .from('nicknames')
        .select('*')
        .eq('setter_user_id', userId);
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!userId,
  });
};

export const useNickname = (groupId: string, setterUserId: string, targetUserId: string) => {
  return useQuery({
    queryKey: nicknameKeys.specific(groupId, setterUserId, targetUserId),
    queryFn: async (): Promise<Nickname | null> => {
      const { data, error } = await supabase
        .from('nicknames')
        .select('*')
        .eq('group_id', groupId)
        .eq('setter_user_id', setterUserId)
        .eq('target_user_id', targetUserId)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      return data || null;
    },
    enabled: !!(groupId && setterUserId && targetUserId),
  });
};

// Mutations
export const useCreateNickname = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (nicknameData: CreateNickname): Promise<Nickname> => {
      const { data, error } = await supabase
        .from('nicknames')
        .insert(nicknameData)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: nicknameKeys.all });
      queryClient.invalidateQueries({ queryKey: nicknameKeys.group(data.group_id) });
      queryClient.invalidateQueries({ queryKey: nicknameKeys.user(data.target_user_id) });
    },
  });
};

export const useUpdateNickname = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ 
      groupId, 
      setterUserId, 
      targetUserId, 
      updates 
    }: { 
      groupId: string; 
      setterUserId: string; 
      targetUserId: string; 
      updates: UpdateNickname;
    }): Promise<Nickname> => {
      const { data, error } = await supabase
        .from('nicknames')
        .update(updates)
        .eq('group_id', groupId)
        .eq('setter_user_id', setterUserId)
        .eq('target_user_id', targetUserId)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: nicknameKeys.all });
      queryClient.invalidateQueries({ queryKey: nicknameKeys.group(data.group_id) });
      queryClient.invalidateQueries({ queryKey: nicknameKeys.user(data.target_user_id) });
      queryClient.invalidateQueries({ 
        queryKey: nicknameKeys.specific(data.group_id, data.setter_user_id, data.target_user_id) 
      });
    },
  });
};

export const useDeleteNickname = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ 
      groupId, 
      setterUserId, 
      targetUserId 
    }: { 
      groupId: string; 
      setterUserId: string; 
      targetUserId: string;
    }): Promise<void> => {
      const { error } = await supabase
        .from('nicknames')
        .delete()
        .eq('group_id', groupId)
        .eq('setter_user_id', setterUserId)
        .eq('target_user_id', targetUserId);
      
      if (error) throw error;
    },
    onSuccess: (_, { groupId, targetUserId }) => {
      queryClient.invalidateQueries({ queryKey: nicknameKeys.all });
      queryClient.invalidateQueries({ queryKey: nicknameKeys.group(groupId) });
      queryClient.invalidateQueries({ queryKey: nicknameKeys.user(targetUserId) });
    },
  });
};

// Upsert Nickname (Create or Update)
export const useUpsertNickname = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (nicknameData: CreateNickname): Promise<Nickname> => {
      const { data, error } = await supabase
        .from('nicknames')
        .upsert(nicknameData, {
          onConflict: 'group_id,setter_user_id,target_user_id'
        })
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: nicknameKeys.all });
      queryClient.invalidateQueries({ queryKey: nicknameKeys.group(data.group_id) });
      queryClient.invalidateQueries({ queryKey: nicknameKeys.user(data.target_user_id) });
      queryClient.invalidateQueries({ 
        queryKey: nicknameKeys.specific(data.group_id, data.setter_user_id, data.target_user_id) 
      });
    },
  });
};

// Realtime Subscription Hook
export const useNicknamesRealtime = (groupId?: string) => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['nicknames-realtime', groupId],
    queryFn: () => {
      const channel = supabase
        .channel(`nicknames-changes${groupId ? `-${groupId}` : ''}`)
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'nicknames',
            ...(groupId && { filter: `group_id=eq.${groupId}` }),
          },
          () => {
            queryClient.invalidateQueries({ queryKey: nicknameKeys.all });
            if (groupId) {
              queryClient.invalidateQueries({ queryKey: nicknameKeys.group(groupId) });
            }
          }
        )
        .subscribe();

      return channel;
    },
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};
</file>

<file path="api/README.md">
# Geliom API Documentation

Bu klasÃ¶r, Supabase tabanlÄ± React Query API'lerini iÃ§erir. TÃ¼m CRUD iÅŸlemleri ve realtime Ã¶zellikler burada tanÄ±mlanmÄ±ÅŸtÄ±r.

## ğŸ“ Dosya YapÄ±sÄ±

```
api/
â”œâ”€â”€ index.ts           # Ana export dosyasÄ± - tÃ¼m API'leri buradan import edin
â”œâ”€â”€ supabase.ts        # Supabase client konfigÃ¼rasyonu
â”œâ”€â”€ users.ts           # KullanÄ±cÄ± iÅŸlemleri
â”œâ”€â”€ moods.ts           # Mood iÅŸlemleri
â”œâ”€â”€ groups.ts          # Grup ve grup Ã¼yelik iÅŸlemleri
â”œâ”€â”€ nicknames.ts       # Takma ad iÅŸlemleri
â”œâ”€â”€ statuses.ts        # Durum ve kullanÄ±cÄ± durumu iÅŸlemleri
â”œâ”€â”€ notifications.ts   # Bildirim susturma iÅŸlemleri
â”œâ”€â”€ subscriptions.ts   # Abonelik iÅŸlemleri
â””â”€â”€ events.ts          # ZamanlanmÄ±ÅŸ etkinlik iÅŸlemleri
```

## ğŸš€ KullanÄ±m

### Temel Import

```typescript
import { 
  useUsers, 
  useCreateUser, 
  useUsersRealtime,
  apiUtils 
} from '../api';
```

### Ã–rnek KullanÄ±mlar

#### 1. KullanÄ±cÄ±larÄ± Listele
```typescript
function UsersList() {
  const { data: users, isLoading, error } = useUsers();
  
  if (isLoading) return <div>YÃ¼kleniyor...</div>;
  if (error) return <div>Hata: {error.message}</div>;
  
  return (
    <div>
      {users?.map(user => (
        <div key={user.id}>
          {user.display_name} - {user.mood?.emoji}
        </div>
      ))}
    </div>
  );
}
```

#### 2. Grup OluÅŸtur
```typescript
function CreateGroup() {
  const createGroup = useCreateGroup();
  const { mutate, isPending } = createGroup;
  
  const handleSubmit = async (formData: CreateGroup) => {
    mutate({
      ...formData,
      invite_code: apiUtils.generateInviteCode(),
    });
  };
  
  return (
    <form onSubmit={handleSubmit}>
      {/* Form alanlarÄ± */}
    </form>
  );
}
```

#### 3. Realtime Dinleme
```typescript
function GroupChat({ groupId }: { groupId: string }) {
  // Grup Ã¼yelerini realtime dinle
  useGroupMembersRealtime(groupId);
  
  const { data: members } = useGroupMembers(groupId);
  
  return (
    <div>
      {members?.map(member => (
        <div key={member.user_id}>
          {member.user?.display_name}
        </div>
      ))}
    </div>
  );
}
```

## ğŸ” GÃ¼venlik KurallarÄ±

### KullanÄ±cÄ± Yetkilendirme
- KullanÄ±cÄ±lar sadece kendi verilerine eriÅŸebilir
- Grup iÅŸlemleri iÃ§in grup Ã¼yeliÄŸi kontrol edilir
- Supabase RLS (Row Level Security) politikalarÄ± ile korunur

### Ã–rnek GÃ¼venlik Kontrolleri
```typescript
// Grup Ã¼yeliÄŸi kontrol et
const isMember = await apiUtils.checkGroupMembership(groupId, userId);
if (!isMember) {
  throw new Error('Bu gruba eriÅŸim yetkiniz yok');
}

// Grup sahipliÄŸi kontrol et
const isOwner = await apiUtils.checkGroupOwnership(groupId, userId);
if (!isOwner) {
  throw new Error('Bu iÅŸlem iÃ§in grup sahibi olmalÄ±sÄ±nÄ±z');
}
```

## ğŸ“Š Tablo Ä°liÅŸkileri

### Users (KullanÄ±cÄ±lar)
- `mood_id` â†’ `moods.id`
- Grup Ã¼yelikleri: `group_members` tablosu Ã¼zerinden

### Groups (Gruplar)
- `owner_id` â†’ `users.id`
- Ãœyeler: `group_members` tablosu Ã¼zerinden

### Nicknames (Takma Adlar)
- `group_id` â†’ `groups.id`
- `setter_user_id` â†’ `users.id`
- `target_user_id` â†’ `users.id`

### User Statuses (KullanÄ±cÄ± DurumlarÄ±)
- `user_id` â†’ `users.id`
- `status_id` â†’ `statuses.id`

### Scheduled Events (Etkinlikler)
- `group_id` â†’ `groups.id`
- `creator_id` â†’ `users.id`

## ğŸ”„ Realtime Ã–zellikler

Her tablo iÃ§in realtime subscription hook'larÄ± mevcuttur:

- `useUsersRealtime()` - TÃ¼m kullanÄ±cÄ± deÄŸiÅŸiklikleri
- `useGroupsRealtime()` - TÃ¼m grup deÄŸiÅŸiklikleri
- `useGroupMembersRealtime(groupId)` - Belirli grup Ã¼yelik deÄŸiÅŸiklikleri
- `useNicknamesRealtime(groupId?)` - Takma ad deÄŸiÅŸiklikleri
- `useStatusesRealtime()` - Durum deÄŸiÅŸiklikleri
- `useUserStatusesRealtime()` - KullanÄ±cÄ± durumu deÄŸiÅŸiklikleri
- `useMutedNotificationsRealtime(userId?)` - Bildirim susturma deÄŸiÅŸiklikleri
- `useSubscriptionRealtime(userId)` - Abonelik deÄŸiÅŸiklikleri
- `useGroupEventsRealtime(groupId)` - Grup etkinlik deÄŸiÅŸiklikleri

## ğŸ›  Utility Fonksiyonlar

`apiUtils` objesi yararlÄ± yardÄ±mcÄ± fonksiyonlar iÃ§erir:

```typescript
// Mevcut kullanÄ±cÄ± ID'sini al
const userId = await apiUtils.getCurrentUserId();

// Grup Ã¼yeliÄŸi kontrol et
const isMember = await apiUtils.checkGroupMembership(groupId, userId);

// Grup sahipliÄŸi kontrol et
const isOwner = await apiUtils.checkGroupOwnership(groupId, userId);

// Davet kodu oluÅŸtur
const inviteCode = apiUtils.generateInviteCode();

// Tarih formatla
const formattedDate = apiUtils.formatEventDate(event.event_time);

// Abonelik durumu kontrol et
const isActive = apiUtils.isSubscriptionActive(subscription);
```

## ğŸ“ TypeScript Tipleri

TÃ¼m tipler `types/database.ts` dosyasÄ±nda tanÄ±mlanmÄ±ÅŸtÄ±r:

- `User`, `CreateUser`, `UpdateUser`
- `Group`, `CreateGroup`, `UpdateGroup`
- `Mood`, `CreateMood`, `UpdateMood`
- `Status`, `CreateStatus`, `UpdateStatus`
- `ScheduledEvent`, `CreateScheduledEvent`, `UpdateScheduledEvent`
- Ve daha fazlasÄ±...

## ğŸ”§ Hata YÃ¶netimi

React Query otomatik hata yÃ¶netimi saÄŸlar:

```typescript
const { data, error, isLoading, isError } = useUsers();

if (isError) {
  console.error('KullanÄ±cÄ±lar yÃ¼klenirken hata:', error);
}
```

## ğŸš¨ Ã–nemli Notlar

1. **RLS PolitikalarÄ±**: Supabase'de Row Level Security politikalarÄ±nÄ± mutlaka ayarlayÄ±n
2. **Auth Kontrolleri**: Her iÅŸlem Ã¶ncesi kullanÄ±cÄ± kimlik doÄŸrulamasÄ± yapÄ±n
3. **Realtime Subscriptions**: Gereksiz subscription'larÄ± kapatmayÄ± unutmayÄ±n
4. **Error Boundaries**: React Error Boundary kullanarak hata yakalama yapÄ±n
5. **Loading States**: KullanÄ±cÄ± deneyimi iÃ§in loading durumlarÄ±nÄ± gÃ¶sterin
</file>

<file path="api/subscriptions.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import type {
    CreateSubscription,
    Subscription,
    UpdateSubscription
} from '../types/database';
import { supabase } from './supabase';

// Query Keys
export const subscriptionKeys = {
  all: ['subscriptions'] as const,
  user: (userId: string) => [...subscriptionKeys.all, 'user', userId] as const,
  active: (userId: string) => [...subscriptionKeys.user(userId), 'active'] as const,
};

// Queries
export const useUserSubscription = (userId: string) => {
  return useQuery({
    queryKey: subscriptionKeys.user(userId),
    queryFn: async (): Promise<Subscription | null> => {
      const { data, error } = await supabase
        .from('subscriptions')
        .select('*')
        .eq('user_id', userId)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      return data || null;
    },
    enabled: !!userId,
  });
};

export const useCurrentUserSubscription = () => {
  return useQuery({
    queryKey: ['current-user-subscription'],
    queryFn: async (): Promise<Subscription | null> => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return null;

      const { data, error } = await supabase
        .from('subscriptions')
        .select('*')
        .eq('user_id', user.id)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      return data || null;
    },
  });
};

export const useIsSubscriptionActive = (userId: string) => {
  return useQuery({
    queryKey: subscriptionKeys.active(userId),
    queryFn: async (): Promise<boolean> => {
      const { data, error } = await supabase
        .from('subscriptions')
        .select('expires_at')
        .eq('user_id', userId)
        .eq('status', 'active')
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      
      if (!data) return false;
      
      // Abonelik sÃ¼resi kontrol et
      if (data.expires_at) {
        const expiresAt = new Date(data.expires_at);
        const now = new Date();
        return expiresAt > now;
      }
      
      return true; // expires_at null ise sÄ±nÄ±rsÄ±z abonelik
    },
    enabled: !!userId,
  });
};

// Mutations
export const useCreateSubscription = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (subscriptionData: CreateSubscription): Promise<Subscription> => {
      const { data, error } = await supabase
        .from('subscriptions')
        .upsert(subscriptionData, {
          onConflict: 'user_id'
        })
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: subscriptionKeys.all });
      queryClient.invalidateQueries({ queryKey: subscriptionKeys.user(data.user_id) });
    },
  });
};

export const useUpdateSubscription = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ 
      userId, 
      updates 
    }: { 
      userId: string; 
      updates: UpdateSubscription;
    }): Promise<Subscription> => {
      const { data, error } = await supabase
        .from('subscriptions')
        .update(updates)
        .eq('user_id', userId)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: subscriptionKeys.all });
      queryClient.invalidateQueries({ queryKey: subscriptionKeys.user(data.user_id) });
    },
  });
};

export const useCancelSubscription = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (userId: string): Promise<Subscription> => {
      const { data, error } = await supabase
        .from('subscriptions')
        .update({ status: 'cancelled' })
        .eq('user_id', userId)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: subscriptionKeys.all });
      queryClient.invalidateQueries({ queryKey: subscriptionKeys.user(data.user_id) });
    },
  });
};

export const useDeleteSubscription = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (userId: string): Promise<void> => {
      const { error } = await supabase
        .from('subscriptions')
        .delete()
        .eq('user_id', userId);
      
      if (error) throw error;
    },
    onSuccess: (_, userId) => {
      queryClient.invalidateQueries({ queryKey: subscriptionKeys.all });
      queryClient.invalidateQueries({ queryKey: subscriptionKeys.user(userId) });
    },
  });
};

// Realtime Subscription Hook - Sadece kendi aboneliÄŸini dinler
export const useSubscriptionRealtime = (userId: string) => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['subscription-realtime', userId],
    queryFn: () => {
      const channel = supabase
        .channel(`subscription-changes-${userId}`)
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'subscriptions',
            filter: `user_id=eq.${userId}`,
          },
          () => {
            queryClient.invalidateQueries({ queryKey: subscriptionKeys.user(userId) });
          }
        )
        .subscribe();

      return channel;
    },
    enabled: !!userId,
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};
</file>

<file path="app/(drawer)/(group)/join-requests.tsx">
import { useApproveJoinRequest, useGroupJoinRequests, useGroupJoinRequestsRealtime, useRejectJoinRequest } from '@/api/groups';
import { BaseLayout, Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useGroupContext } from '@/contexts/GroupContext';
import { useTheme } from '@/contexts/ThemeContext';
import type { GroupJoinRequestWithDetails } from '@/types/database';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useState } from 'react';
import { Alert, RefreshControl, ScrollView, StyleSheet, TouchableOpacity, View } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function JoinRequestsScreen() {
  const { user } = useAuth();
  const { selectedGroup } = useGroupContext();
  const { colors } = useTheme();
  const router = useRouter();
  const insets = useSafeAreaInsets();
  const headerHeight = 56 + insets.top;

  const [refreshing, setRefreshing] = useState(false);

  // Sadece owner ise istekleri gÃ¶ster
  const isOwner = selectedGroup?.owner_id === user?.id;
  const groupId = selectedGroup?.id || '';

  const {
    data: requests = [],
    isLoading,
    refetch,
  } = useGroupJoinRequests(groupId, 'pending');

  // Realtime subscription - Grup iÃ§in isteklerin anlÄ±k gÃ¼ncellenmesi
  useGroupJoinRequestsRealtime(groupId);

  const approveRequest = useApproveJoinRequest();
  const rejectRequest = useRejectJoinRequest();

  const handleRefresh = async () => {
    setRefreshing(true);
    await refetch();
    setRefreshing(false);
  };

  const handleApprove = async (request: GroupJoinRequestWithDetails) => {
    Alert.alert(
      'Ä°steÄŸi Onayla',
      `${request.requester?.display_name || request.requester?.custom_user_id || 'KullanÄ±cÄ±'} gruba katÄ±lacak. OnaylÄ±yor musunuz?`,
      [
        { text: 'Ä°ptal', style: 'cancel' },
        {
          text: 'Onayla',
          onPress: async () => {
            try {
              await approveRequest.mutateAsync({
                requestId: request.id,
                groupId: request.group_id,
              });
              Alert.alert('BaÅŸarÄ±lÄ±', 'KullanÄ±cÄ± gruba eklendi');
            } catch (error: any) {
              Alert.alert('Hata', error.message || 'Ä°stek onaylanamadÄ±');
            }
          },
        },
      ]
    );
  };

  const handleReject = async (request: GroupJoinRequestWithDetails) => {
    Alert.alert(
      'Ä°steÄŸi Reddet',
      `${request.requester?.display_name || request.requester?.custom_user_id || 'KullanÄ±cÄ±'}nÄ±n isteÄŸini reddetmek istediÄŸinize emin misiniz?`,
      [
        { text: 'Ä°ptal', style: 'cancel' },
        {
          text: 'Reddet',
          style: 'destructive',
          onPress: async () => {
            try {
              await rejectRequest.mutateAsync({
                requestId: request.id,
                groupId: request.group_id,
              });
            } catch (error: any) {
              Alert.alert('Hata', error.message || 'Ä°stek reddedilemedi');
            }
          },
        },
      ]
    );
  };

  if (!selectedGroup) {
    return (
      <BaseLayout
        headerShow={true}
        header={{
          leftIcon: {
            icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
            onPress: () => router.back(),
          },
          title: <Typography variant="h5" color={colors.text}>KatÄ±lma Ä°stekleri</Typography>,
          backgroundColor: colors.background,
        }}
      >
        <View style={[styles.emptyContainer, { backgroundColor: colors.background }]}>
          <Ionicons name="people-outline" size={64} color={colors.secondaryText} />
          <Typography variant="h4" color={colors.text} style={{ marginTop: 16, marginBottom: 8 }}>
            Grup SeÃ§ilmedi
          </Typography>
          <Typography variant="body" color={colors.secondaryText} style={{ textAlign: 'center' }}>
            KatÄ±lma isteklerini gÃ¶rmek iÃ§in bir grup seÃ§melisiniz.
          </Typography>
        </View>
      </BaseLayout>
    );
  }

  if (!isOwner) {
    return (
      <BaseLayout
        headerShow={true}
        header={{
          leftIcon: {
            icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
            onPress: () => router.back(),
          },
          title: <Typography variant="h5" color={colors.text}>KatÄ±lma Ä°stekleri</Typography>,
          backgroundColor: colors.background,
        }}
      >
        <View style={[styles.emptyContainer, { backgroundColor: colors.background }]}>
          <Ionicons name="lock-closed-outline" size={64} color={colors.secondaryText} />
          <Typography variant="h4" color={colors.text} style={{ marginTop: 16, marginBottom: 8 }}>
            Yetki Gerekli
          </Typography>
          <Typography variant="body" color={colors.secondaryText} style={{ textAlign: 'center' }}>
            Sadece grup kurucusu katÄ±lma isteklerini gÃ¶rebilir.
          </Typography>
        </View>
      </BaseLayout>
    );
  }

  return (
    <BaseLayout
      headerShow={true}
      header={{
        leftIcon: {
          icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
          onPress: () => router.back(),
        },
        title: <Typography variant="h5" color={colors.text}>KatÄ±lma Ä°stekleri</Typography>,
        backgroundColor: colors.background,
      }}
    >
      <ScrollView
        style={styles.container}
        contentContainerStyle={styles.contentContainer}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} tintColor={colors.primary} />
        }
      >
        {isLoading ? (
          <View style={styles.loadingContainer}>
            <Typography variant="body" color={colors.secondaryText}>
              YÃ¼kleniyor...
            </Typography>
          </View>
        ) : requests.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Ionicons name="checkmark-circle-outline" size={64} color={colors.secondaryText} />
            <Typography variant="h4" color={colors.text} style={{ marginTop: 16, marginBottom: 8 }}>
              Bekleyen Ä°stek Yok
            </Typography>
            <Typography variant="body" color={colors.secondaryText} style={{ textAlign: 'center' }}>
              Åu anda {selectedGroup.name} grubuna katÄ±lmak isteyen kimse yok.
            </Typography>
          </View>
        ) : (
          <View style={styles.requestsList}>
            <Typography variant="label" color={colors.secondaryText} style={{ marginBottom: 12 }}>
              {requests.length} Bekleyen Ä°stek
            </Typography>
            {requests.map((request) => (
              <View
                key={request.id}
                style={[styles.requestCard, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}
              >
                <View style={styles.requestHeader}>
                  <View style={[styles.avatar, { backgroundColor: colors.primary + '20' }]}>
                    {request.requester?.photo_url ? (
                      <Ionicons name="person" size={24} color={colors.primary} />
                    ) : (
                      <Ionicons name="person-outline" size={24} color={colors.primary} />
                    )}
                  </View>
                  <View style={styles.requestInfo}>
                    <Typography variant="h5" color={colors.text} numberOfLines={1}>
                      {request.requester?.display_name || 'Ä°simsiz KullanÄ±cÄ±'}
                    </Typography>
                    <Typography variant="caption" color={colors.secondaryText}>
                      @{request.requester?.custom_user_id || 'N/A'}
                    </Typography>
                    <Typography variant="caption" color={colors.secondaryText} style={{ marginTop: 4 }}>
                      {request.created_at
                        ? new Date(request.created_at).toLocaleDateString('tr-TR', {
                            day: 'numeric',
                            month: 'long',
                            hour: '2-digit',
                            minute: '2-digit',
                          })
                        : 'Tarih bilinmiyor'}
                    </Typography>
                  </View>
                </View>

                <View style={styles.requestActions}>
                  <TouchableOpacity
                    style={[styles.actionButton, styles.rejectButton, { borderColor: colors.error }]}
                    onPress={() => handleReject(request)}
                    disabled={rejectRequest.isPending}
                  >
                    <Ionicons name="close-circle" size={20} color={colors.error} />
                    <Typography variant="button" color={colors.error} style={{ marginLeft: 4 }}>
                      Reddet
                    </Typography>
                  </TouchableOpacity>

                  <TouchableOpacity
                    style={[styles.actionButton, styles.approveButton, { backgroundColor: colors.primary }]}
                    onPress={() => handleApprove(request)}
                    disabled={approveRequest.isPending}
                  >
                    <Ionicons name="checkmark-circle" size={20} color={colors.white} />
                    <Typography variant="button" color={colors.white} style={{ marginLeft: 4 }}>
                      Onayla
                    </Typography>
                  </TouchableOpacity>
                </View>
              </View>
            ))}
          </View>
        )}
      </ScrollView>
    </BaseLayout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  contentContainer: {
    padding: 24,
    paddingBottom: 100,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 40,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 60,
    paddingHorizontal: 24,
  },
  requestsList: {
    gap: 16,
  },
  requestCard: {
    borderRadius: 16,
    borderWidth: 1.5,
    padding: 16,
    gap: 12,
  },
  requestHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  avatar: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  requestInfo: {
    flex: 1,
  },
  requestActions: {
    flexDirection: 'row',
    gap: 12,
    marginTop: 4,
  },
  actionButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 12,
  },
  rejectButton: {
    borderWidth: 1.5,
    backgroundColor: 'transparent',
  },
  approveButton: {
    // backgroundColor will be set inline
  },
});
</file>

<file path="app/(drawer)/help-support.tsx">
import { BaseLayout, Typography } from '@/components/shared';
import { useTheme } from '@/contexts/ThemeContext';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React from 'react';
import { Alert, Linking, ScrollView, StyleSheet, TouchableOpacity, View } from 'react-native';

export default function HelpSupportScreen() {
  const { colors } = useTheme();
  const router = useRouter();

  const handleEmailSupport = () => {
    Linking.openURL('mailto:support@geliom.app?subject=Destek Talebi');
  };

  const handleWhatsAppSupport = () => {
    // WhatsApp destek numarasÄ± (Ã¶rnek)
    Linking.openURL('https://wa.me/1234567890');
  };

  const handleFAQ = () => {
    Alert.alert('SSS', 'SÄ±k Sorulan Sorular sayfasÄ± yakÄ±nda eklenecek');
  };

  return (
    <BaseLayout
      headerShow={true}
      backgroundColor={colors.background}
    >
      <ScrollView style={styles.container} showsVerticalScrollIndicator={false}>
        <View style={styles.content}>
          <Typography variant="h3" color={colors.text} style={styles.title}>
            Size NasÄ±l YardÄ±mcÄ± Olabiliriz?
          </Typography>

          <Typography variant="body" color={colors.secondaryText} style={styles.description}>
            SorularÄ±nÄ±z veya sorunlarÄ±nÄ±z iÃ§in bizimle iletiÅŸime geÃ§ebilirsiniz.
          </Typography>

          {/* Ä°letiÅŸim KartlarÄ± */}
          <View style={styles.cardContainer}>
            <TouchableOpacity
              style={[styles.card, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}
              onPress={handleEmailSupport}
            >
              <View style={[styles.iconContainer, { backgroundColor: colors.primary + '20' }]}>
                <Ionicons name="mail" size={24} color={colors.primary} />
              </View>
              <Typography variant="h5" color={colors.text} style={styles.cardTitle}>
                E-posta
              </Typography>
              <Typography variant="caption" color={colors.secondaryText} style={styles.cardDescription}>
                support@geliom.app
              </Typography>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.card, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}
              onPress={handleWhatsAppSupport}
            >
              <View style={[styles.iconContainer, { backgroundColor: '#25D366' + '20' }]}>
                <Ionicons name="logo-whatsapp" size={24} color="#25D366" />
              </View>
              <Typography variant="h5" color={colors.text} style={styles.cardTitle}>
                WhatsApp
              </Typography>
              <Typography variant="caption" color={colors.secondaryText} style={styles.cardDescription}>
                HÄ±zlÄ± destek
              </Typography>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.card, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}
              onPress={handleFAQ}
            >
              <View style={[styles.iconContainer, { backgroundColor: colors.tertiary + '20' }]}>
                <Ionicons name="help-circle" size={24} color={colors.tertiary} />
              </View>
              <Typography variant="h5" color={colors.text} style={styles.cardTitle}>
                SSS
              </Typography>
              <Typography variant="caption" color={colors.secondaryText} style={styles.cardDescription}>
                SÄ±k sorulan sorular
              </Typography>
            </TouchableOpacity>
          </View>

          {/* Uygulama Bilgileri */}
          <View style={[styles.infoBox, { backgroundColor: colors.secondaryBackground, borderColor: colors.stroke }]}>
            <Typography variant="h6" color={colors.text} style={styles.infoTitle}>
              Uygulama Bilgileri
            </Typography>
            <View style={styles.infoRow}>
              <Typography variant="body" color={colors.secondaryText}>SÃ¼rÃ¼m:</Typography>
              <Typography variant="body" color={colors.text}>1.0.0</Typography>
            </View>
            <View style={styles.infoRow}>
              <Typography variant="body" color={colors.secondaryText}>Platform:</Typography>
              <Typography variant="body" color={colors.text}>iOS / Android</Typography>
            </View>
          </View>
        </View>
      </ScrollView>
    </BaseLayout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    padding: 20,
  },
  title: {
    marginBottom: 12,
  },
  description: {
    marginBottom: 32,
    lineHeight: 22,
  },
  cardContainer: {
    gap: 16,
    marginBottom: 32,
  },
  card: {
    padding: 20,
    borderRadius: 16,
    borderWidth: 1,
    alignItems: 'center',
  },
  iconContainer: {
    width: 56,
    height: 56,
    borderRadius: 28,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 12,
  },
  cardTitle: {
    marginBottom: 4,
  },
  cardDescription: {
    textAlign: 'center',
  },
  infoBox: {
    padding: 20,
    borderRadius: 16,
    borderWidth: 1,
  },
  infoTitle: {
    marginBottom: 16,
  },
  infoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
});
</file>

<file path="app/(drawer)/search-user.tsx">
import { useCreateJoinRequest } from '@/api/groups';
import { useUserByCustomId } from '@/api/users';
import KeyboardAwareView from '@/components/KeyboardAwareView';
import { GeliomButton, Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useGroupContext } from '@/contexts/GroupContext';
import { useTheme } from '@/contexts/ThemeContext';
import { Ionicons } from '@expo/vector-icons';
import { Stack, useRouter } from 'expo-router';
import React, { useState } from 'react';
import { ActivityIndicator, Alert, ScrollView, StyleSheet, TextInput, TouchableOpacity, View } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function SearchUserScreen() {
  const { user } = useAuth();
  const { selectedGroup } = useGroupContext();
  const { colors } = useTheme();
  const router = useRouter();
  const insets = useSafeAreaInsets();
  const headerHeight = 56 + insets.top;

  const [customUserId, setCustomUserId] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [searchError, setSearchError] = useState<string | null>(null);
  const [selectedGroupId, setSelectedGroupId] = useState<string | null>(null);

  // Custom user ID ile kullanÄ±cÄ± ara
  const {
    data: foundUser,
    isLoading: isLoadingUser,
    refetch: refetchUser,
  } = useUserByCustomId(customUserId.trim().toUpperCase());

  const createJoinRequest = useCreateJoinRequest();

  const handleSearch = () => {
    if (!customUserId.trim()) {
      setSearchError('KullanÄ±cÄ± ID gerekli');
      return;
    }

    setSearchError(null);
    refetchUser();
  };

  const handleSendInvite = async () => {
    if (!foundUser) {
      setSearchError('KullanÄ±cÄ± bulunamadÄ±');
      return;
    }

    if (!user?.id) {
      Alert.alert('Hata', 'KullanÄ±cÄ± bilgisi bulunamadÄ±');
      return;
    }

    // Grup seÃ§imi yoksa veya seÃ§ili grup yoksa uyarÄ± ver
    const targetGroupId = selectedGroupId || selectedGroup?.id;
    if (!targetGroupId) {
      Alert.alert('Hata', 'LÃ¼tfen Ã¶nce bir grup seÃ§in veya grup ID girin');
      return;
    }

    if (foundUser.id === user.id) {
      Alert.alert('Hata', 'Kendinize davet gÃ¶nderemezsiniz');
      return;
    }

    try {
      setIsSubmitting(true);
      setSearchError(null);

      await createJoinRequest.mutateAsync({
        group_id: targetGroupId,
        requester_id: foundUser.id,
      });

      Alert.alert(
        'Davet GÃ¶nderildi',
        `${foundUser.display_name || foundUser.custom_user_id} kullanÄ±cÄ±sÄ±na davet gÃ¶nderildi.`,
        [
          {
            text: 'Tamam',
            onPress: () => {
              setCustomUserId('');
              setSelectedGroupId(null);
            },
          },
        ]
      );
    } catch (error: any) {
      setSearchError(error.message || 'Davet gÃ¶nderilemedi');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleUserIdChange = (text: string) => {
    // Sadece bÃ¼yÃ¼k harf ve rakam kabul et
    const cleaned = text.toUpperCase().replace(/[^A-Z0-9]/g, '');
    setCustomUserId(cleaned);
    setSearchError(null);
  };

  return (
    <>
      <Stack.Screen
        options={{
          title: 'KullanÄ±cÄ± Ara',
          headerStyle: {
            backgroundColor: colors.background,
          },
          headerTintColor: colors.text,
          headerTitleStyle: {
            fontFamily: 'Comfortaa-SemiBold',
          },
        }}
      />
      <KeyboardAwareView 
        style={{ flex: 1, backgroundColor: colors.background }}
        contentContainerStyle={styles.contentContainer}
        keyboardVerticalOffset={headerHeight}
      >
        <ScrollView 
          style={{ flex: 1 }}
          contentContainerStyle={styles.scrollContent}
          keyboardShouldPersistTaps="handled"
        >
          <View style={styles.form}>
            <View style={styles.inputGroup}>
              <Typography variant="label" color={colors.text} style={{ marginBottom: 8 }}>
                KullanÄ±cÄ± ID
              </Typography>
              <View style={styles.searchContainer}>
                <TextInput
                  style={[
                    styles.input,
                    {
                      backgroundColor: colors.cardBackground,
                      color: colors.text,
                      borderColor: searchError ? colors.error : foundUser ? colors.success : colors.stroke,
                    },
                  ]}
                  placeholder="ABC12345"
                  placeholderTextColor={colors.secondaryText + '80'}
                  value={customUserId}
                  onChangeText={handleUserIdChange}
                  autoCapitalize="characters"
                  autoCorrect={false}
                  returnKeyType="search"
                  onSubmitEditing={handleSearch}
                />
                <TouchableOpacity
                  onPress={handleSearch}
                  disabled={!customUserId.trim() || isLoadingUser}
                  style={[
                    styles.searchButton,
                    {
                      backgroundColor: customUserId.trim() && !isLoadingUser ? colors.primary : colors.secondaryText + '40',
                    },
                  ]}
                >
                  {isLoadingUser ? (
                    <ActivityIndicator size="small" color={colors.white} />
                  ) : (
                    <Ionicons name="search" size={20} color={colors.white} />
                  )}
                </TouchableOpacity>
              </View>
              {searchError && (
              <Typography variant="caption" color={colors.error} style={{ marginTop: 4 }}>
                {searchError}
              </Typography>
            )}
              {foundUser && !searchError && (
                <Typography variant="caption" color={colors.success} style={{ marginTop: 4 }}>
                  âœ“ KullanÄ±cÄ± bulundu
                </Typography>
              )}
            </View>

          {foundUser && (
            <View style={[styles.userCard, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}>
              <View style={styles.userCardHeader}>
                <View style={[styles.avatar, { backgroundColor: colors.primary + '20' }]}>
                  {foundUser.photo_url ? (
                    <Ionicons name="person" size={32} color={colors.primary} />
                  ) : (
                    <Ionicons name="person-outline" size={32} color={colors.primary} />
                  )}
                </View>
                <View style={styles.userInfo}>
                  <Typography variant="h5" color={colors.text} numberOfLines={1}>
                    {foundUser.display_name || 'Ä°simsiz KullanÄ±cÄ±'}
                  </Typography>
                  <Typography variant="caption" color={colors.secondaryText}>
                    @{foundUser.custom_user_id}
                  </Typography>
                  {foundUser.email && (
                    <Typography variant="caption" color={colors.secondaryText} style={{ marginTop: 2 }}>
                      {foundUser.email}
                    </Typography>
                  )}
                </View>
              </View>
            </View>
          )}

          {selectedGroup && (
            <View style={[styles.groupInfo, { backgroundColor: colors.cardBackground + '80', borderColor: colors.stroke }]}>
              <View style={styles.groupInfoHeader}>
                <Ionicons name="people" size={20} color={colors.secondaryText} />
                <Typography variant="caption" color={colors.secondaryText} style={{ marginLeft: 8 }}>
                  Davet gÃ¶nderilecek grup: <Typography variant="caption" color={colors.text} fontWeight="semibold">{selectedGroup.name}</Typography>
                </Typography>
              </View>
            </View>
          )}

          {!selectedGroup && (
            <View style={[styles.warningCard, { backgroundColor: colors.warning + '20', borderColor: colors.warning }]}>
              <Ionicons name="warning-outline" size={20} color={colors.warning} />
              <Typography variant="caption" color={colors.warning} style={{ marginLeft: 8, flex: 1 }}>
                Davet gÃ¶ndermek iÃ§in Ã¶nce bir grup seÃ§melisiniz veya grup yÃ¶netimi sayfasÄ±ndan davet gÃ¶nderebilirsiniz.
              </Typography>
            </View>
          )}

          <GeliomButton
            state={isSubmitting ? 'loading' : foundUser && (selectedGroup || selectedGroupId) ? 'active' : 'disabled'}
            layout="full-width"
            size="large"
            icon="send"
            onPress={handleSendInvite}
            disabled={!foundUser || (!selectedGroup && !selectedGroupId) || isSubmitting}
          >
            {isSubmitting ? 'GÃ¶nderiliyor...' : 'Davet GÃ¶nder'}
          </GeliomButton>
        </View>
        </ScrollView>
      </KeyboardAwareView>
    </>
  );
}

const styles = StyleSheet.create({
  contentContainer: {
    flexGrow: 1,
  },
  scrollContent: {
    padding: 24,
    paddingBottom: 100,
  },
  form: {
    gap: 24,
  },
  inputGroup: {
    gap: 4,
  },
  searchContainer: {
    flexDirection: 'row',
    gap: 8,
    alignItems: 'center',
    position: 'relative',
  },
  input: {
    flex: 1,
    borderWidth: 1.5,
    borderRadius: 16,
    paddingHorizontal: 16,
    paddingRight: 50,
    paddingVertical: 16,
    fontSize: 18,
    fontFamily: 'Comfortaa-Medium',
  },
  searchButton: {
    position: 'absolute',
    right: 8,
    width: 40,
    height: 40,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  userCard: {
    borderRadius: 16,
    borderWidth: 1.5,
    padding: 16,
  },
  userCardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  avatar: {
    width: 56,
    height: 56,
    borderRadius: 28,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  userInfo: {
    flex: 1,
  },
  groupInfo: {
    borderRadius: 12,
    borderWidth: 1,
    padding: 12,
  },
  groupInfoHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  warningCard: {
    borderRadius: 12,
    borderWidth: 1,
    padding: 12,
    flexDirection: 'row',
    alignItems: 'center',
  },
});
</file>

<file path="app/(drawer)/settings.tsx">
import { BaseLayout, Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useTheme } from '@/contexts/ThemeContext';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React from 'react';
import { Alert, ScrollView, StyleSheet, Switch, TouchableOpacity, View } from 'react-native';

export default function SettingsScreen() {
  const { colors, toggleTheme, isDark } = useTheme();
  const { user } = useAuth();
  const router = useRouter();

  const handleNotificationSettings = () => {
    Alert.alert('Bildirimler', 'Bildirim ayarlarÄ± yakÄ±nda eklenecek');
  };

  const handlePrivacySettings = () => {
    Alert.alert('Gizlilik', 'Gizlilik ayarlarÄ± yakÄ±nda eklenecek');
  };

  const handleLanguageSettings = () => {
    Alert.alert('Dil', 'Dil ayarlarÄ± yakÄ±nda eklenecek');
  };

  const handleClearCache = () => {
    Alert.alert(
      'Ã–nbelleÄŸi Temizle',
      'Ã–nbelleÄŸiniz temizlensin mi?',
      [
        { text: 'Ä°ptal', style: 'cancel' },
        { text: 'Temizle', onPress: () => Alert.alert('BaÅŸarÄ±lÄ±', 'Ã–nbellek temizlendi') },
      ]
    );
  };

  return (
    <BaseLayout
      headerShow={false}
      backgroundColor={colors.background}
    >
      <ScrollView style={styles.container} showsVerticalScrollIndicator={false}>
        <View style={styles.content}>
          {/* Genel Ayarlar */}
          <Typography variant="h6" color={colors.secondaryText} style={styles.sectionTitle}>
            GENEL
          </Typography>

          <View style={[styles.settingItem, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}>
            <View style={styles.settingLeft}>
              <Ionicons name={isDark ? "moon" : "sunny"} size={22} color={colors.text} />
              <Typography variant="body" color={colors.text} style={styles.settingText}>
                Koyu Tema
              </Typography>
            </View>
            <Switch
              value={isDark}
              onValueChange={toggleTheme}
              trackColor={{ false: colors.stroke, true: colors.primary + '80' }}
              thumbColor={isDark ? colors.primary : colors.white}
            />
          </View>

          <TouchableOpacity
            style={[styles.settingItem, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}
            onPress={handleNotificationSettings}
          >
            <View style={styles.settingLeft}>
              <Ionicons name="notifications" size={22} color={colors.text} />
              <Typography variant="body" color={colors.text} style={styles.settingText}>
                Bildirimler
              </Typography>
            </View>
            <Ionicons name="chevron-forward" size={20} color={colors.secondaryText} />
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.settingItem, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}
            onPress={handleLanguageSettings}
          >
            <View style={styles.settingLeft}>
              <Ionicons name="language" size={22} color={colors.text} />
              <Typography variant="body" color={colors.text} style={styles.settingText}>
                Dil
              </Typography>
            </View>
            <View style={styles.settingRight}>
              <Typography variant="caption" color={colors.secondaryText} style={{ marginRight: 8 }}>
                TÃ¼rkÃ§e
              </Typography>
              <Ionicons name="chevron-forward" size={20} color={colors.secondaryText} />
            </View>
          </TouchableOpacity>

          {/* Gizlilik & GÃ¼venlik */}
          <Typography variant="h6" color={colors.secondaryText} style={styles.sectionTitle}>
            GÄ°ZLÄ°LÄ°K & GÃœVENLÄ°K
          </Typography>

          <TouchableOpacity
            style={[styles.settingItem, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}
            onPress={handlePrivacySettings}
          >
            <View style={styles.settingLeft}>
              <Ionicons name="shield-checkmark" size={22} color={colors.text} />
              <Typography variant="body" color={colors.text} style={styles.settingText}>
                Gizlilik AyarlarÄ±
              </Typography>
            </View>
            <Ionicons name="chevron-forward" size={20} color={colors.secondaryText} />
          </TouchableOpacity>

          {/* DiÄŸer */}
          <Typography variant="h6" color={colors.secondaryText} style={styles.sectionTitle}>
            DÄ°ÄER
          </Typography>

          <TouchableOpacity
            style={[styles.settingItem, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}
            onPress={handleClearCache}
          >
            <View style={styles.settingLeft}>
              <Ionicons name="trash" size={22} color={colors.error} />
              <Typography variant="body" color={colors.error} style={styles.settingText}>
                Ã–nbelleÄŸi Temizle
              </Typography>
            </View>
            <Ionicons name="chevron-forward" size={20} color={colors.secondaryText} />
          </TouchableOpacity>

          {/* KullanÄ±cÄ± Bilgileri */}
          <View style={[styles.userInfo, { backgroundColor: colors.secondaryBackground, borderColor: colors.stroke }]}>
            <Typography variant="caption" color={colors.secondaryText}>
              Oturum aÃ§an: {user?.custom_user_id}
            </Typography>
          </View>
        </View>
      </ScrollView>
    </BaseLayout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    padding: 20,
  },
  sectionTitle: {
    marginTop: 24,
    marginBottom: 12,
    marginLeft: 4,
    fontSize: 12,
    fontWeight: 'bold',
  },
  settingItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 16,
    borderRadius: 12,
    borderWidth: 1,
    marginBottom: 8,
  },
  settingLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  settingRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  settingText: {
    marginLeft: 12,
  },
  userInfo: {
    marginTop: 32,
    padding: 16,
    borderRadius: 12,
    borderWidth: 1,
    alignItems: 'center',
  },
});
</file>

<file path="app/(drawer)/showroom.tsx">
import { BaseLayout, GeliomButton, Typography } from "@/components/shared";
import { useTheme } from "@/contexts/ThemeContext";
import React from 'react';
import { ScrollView, View } from "react-native";

export default function ShowroomScreen() {
  const { colors } = useTheme();

  return (
    <BaseLayout
      headerShow={false} // Drawer navigation kendi header'Ä±nÄ± kullanacak
    >
      <ScrollView 
        style={{ flex: 1 }}
        contentContainerStyle={{ paddingHorizontal: 20, paddingTop: 8, paddingBottom: 20 }}
        showsVerticalScrollIndicator={false}
      >
        <Typography 
          variant="h2" 
          color={colors.text}
          style={{ marginBottom: 6, textAlign: 'center' }}
        >
          ğŸŒ¿ GeliomButton Showroom
        </Typography>
        
        <Typography 
          variant="body" 
          color={colors.secondaryText}
          style={{ marginBottom: 24, textAlign: 'center' }}
        >
          Forest-Sage-Pine temalÄ± ana button sistemi
        </Typography>

        {/* GeliomButton - Ana Button Sistemi */}
        <View style={{ marginBottom: 32 }}>
          <Typography
            variant="h3"
            color={colors.primary}
            style={{ marginBottom: 16 }}
          >
            ğŸŒ¿ GeliomButton - Ana Button Sistemi
          </Typography>
          <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 20 }}>
            Forest (Active), Sage (Passive), Pine (Loading) - AdaÃ§ayÄ± tarzÄ± organik tasarÄ±m
          </Typography>

          {/* Button States */}
          <View style={{ gap: 16 }}>
            <View>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 12 }}>
                Button DurumlarÄ±:
              </Typography>
              <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 12 }}>
                <GeliomButton state="active" onPress={() => console.log('Active pressed')}>
                  ğŸŒ² Active (Forest)
                </GeliomButton>
                <GeliomButton state="passive" onPress={() => console.log('Passive pressed')}>
                  ğŸŒ¾ Passive (Sage)
                </GeliomButton>
                <GeliomButton state="loading" onPress={() => console.log('Loading pressed')}>
                  ğŸŒ² Loading (Pine)
                </GeliomButton>
              </View>
            </View>

            {/* Button Sizes */}
            <View>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 12 }}>
                Boyutlar (AdaÃ§ayÄ± TarzÄ± Organik):
              </Typography>
              <View style={{ flexDirection: 'row', flexWrap: 'wrap', alignItems: 'center', gap: 12 }}>
                <GeliomButton state="active" size="small">
                  Small
                </GeliomButton>
                <GeliomButton state="active" size="medium">
                  Medium
                </GeliomButton>
                <GeliomButton state="active" size="large">
                  Large
                </GeliomButton>
                <GeliomButton state="active" size="xl">
                  XL
                </GeliomButton>
              </View>
            </View>

            {/* Icon Layouts */}
            <View>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 12 }}>
                Icon Layout'larÄ±:
              </Typography>
              <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 12 }}>
                <GeliomButton 
                  state="active" 
                  layout="icon-left" 
                  icon="leaf"
                  onPress={() => console.log('Icon left')}
                >
                  Sol Icon
                </GeliomButton>
                <GeliomButton 
                  state="passive" 
                  layout="icon-right" 
                  icon="flower"
                  onPress={() => console.log('Icon right')}
                >
                  SaÄŸ Icon
                </GeliomButton>
                <GeliomButton 
                  state="active" 
                  layout="icon-only" 
                  icon="heart"
                  onPress={() => console.log('Icon only')}
                />
              </View>
            </View>

            {/* Size + Layout Combinations */}
            <View>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 12 }}>
                Boyut + Layout KombinasyonlarÄ±:
              </Typography>
              <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 12 }}>
                <GeliomButton 
                  state="active" 
                  size="small"
                  layout="icon-left" 
                  icon="leaf"
                >
                  ğŸŒ¿ KÃ¼Ã§Ã¼k
                </GeliomButton>
                <GeliomButton 
                  state="passive" 
                  size="large"
                  layout="icon-right" 
                  icon="flower"
                >
                  ğŸŒ¸ BÃ¼yÃ¼k
                </GeliomButton>
                <GeliomButton 
                  state="active" 
                  size="xl"
                  layout="icon-left" 
                  icon="leaf"
                >
                  ğŸŒ³ Extra Large
                </GeliomButton>
              </View>
            </View>

            {/* Icon Only Different Sizes */}
            <View>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 12 }}>
                Icon-Only FarklÄ± Boyutlar:
              </Typography>
              <View style={{ flexDirection: 'row', flexWrap: 'wrap', alignItems: 'center', gap: 12 }}>
                <GeliomButton 
                  state="active" 
                  size="small"
                  layout="icon-only" 
                  icon="heart"
                />
                <GeliomButton 
                  state="passive" 
                  size="medium"
                  layout="icon-only" 
                  icon="star"
                />
                <GeliomButton 
                  state="active" 
                  size="large"
                  layout="icon-only" 
                  icon="diamond"
                />
                <GeliomButton 
                  state="loading" 
                  size="xl"
                  layout="icon-only" 
                  icon="flash"
                />
              </View>
            </View>

            {/* Full Width Examples */}
            <View>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 12 }}>
                Full Width Ã–rnekleri:
              </Typography>
              <View style={{ gap: 12 }}>
                <GeliomButton 
                  state="active" 
                  layout="full-width"
                  icon="checkmark-circle"
                  onPress={() => console.log('Full width active')}
                >
                  ğŸŒ² Tam GeniÅŸlik Active Button
                </GeliomButton>
                <GeliomButton 
                  state="passive" 
                  layout="full-width"
                  size="large"
                  icon="information-circle"
                  onPress={() => console.log('Full width passive')}
                >
                  ğŸŒ¾ BÃ¼yÃ¼k Passive Button
                </GeliomButton>
              </View>
            </View>

            {/* Mixed State Examples */}
            <View>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 12 }}>
                KarÄ±ÅŸÄ±k Durum Ã–rnekleri:
              </Typography>
              <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 12 }}>
                <GeliomButton 
                  state="active" 
                  size="small"
                  layout="icon-left" 
                  icon="leaf"
                >
                  ğŸŒ¿ Aktif
                </GeliomButton>
                <GeliomButton 
                  state="passive" 
                  size="medium"
                  layout="icon-right" 
                  icon="pause"
                >
                  â¸ï¸ Pasif
                </GeliomButton>
                <GeliomButton 
                  state="loading" 
                  size="large"
                  layout="icon-left" 
                  icon="refresh"
                >
                  ğŸ”„ YÃ¼kleniyor
                </GeliomButton>
              </View>
            </View>

            {/* Disabled Examples */}
            <View>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 12 }}>
                Disabled DurumlarÄ±:
              </Typography>
              <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 12 }}>
                <GeliomButton 
                  state="active" 
                  disabled
                  icon="ban"
                >
                  Disabled Active
                </GeliomButton>
                <GeliomButton 
                  state="passive" 
                  disabled
                  layout="icon-right"
                  icon="close"
                >
                  Disabled Passive
                </GeliomButton>
              </View>
            </View>
          </View>
        </View>

        <View style={{ marginBottom: 32 }}>
          <Typography 
            variant="h3" 
            color={colors.text}
            style={{ marginBottom: 16 }}
          >
            DiÄŸer Component'ler
          </Typography>
          
          <View style={{
            backgroundColor: colors.disabled,
            padding: 20,
            borderRadius: 12,
            alignItems: 'center',
          }}>
            <Typography variant="body" color={colors.secondaryText}>
              Daha fazla component yakÄ±nda...
            </Typography>
          </View>
        </View>
      </ScrollView>
    </BaseLayout>
  );
}
</file>

<file path="components/anim/AnimatedComponents.tsx">
import * as Haptics from 'expo-haptics';
import React, { useEffect } from 'react';
import { Pressable, StyleProp, ViewStyle } from 'react-native';
import Animated, {
    FadeIn,
    Layout,
    useAnimatedStyle,
    useSharedValue,
    withRepeat,
    withSequence,
    withTiming
} from 'react-native-reanimated';
import { useTheme } from '../../contexts/ThemeContext';

// 1. SNAPPY BUTTON (HÄ±zlÄ±, Net, OpaklÄ±k DeÄŸiÅŸtiren)
interface BouncyButtonProps {
  children: React.ReactNode;
  onPress?: () => void;
  style?: StyleProp<ViewStyle>;
  scaleTo?: number; 
  activeOpacity?: number; 
  disabled?: boolean;
}

export const BouncyButton = ({ 
  children, 
  onPress, 
  style, 
  scaleTo = 0.98, 
  activeOpacity = 0.7, 
  disabled 
}: BouncyButtonProps) => {
  const scale = useSharedValue(1);
  const opacity = useSharedValue(1);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
    opacity: opacity.value,
  }));

  const handlePressIn = () => {
    if (disabled) return;
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    scale.value = withTiming(scaleTo, { duration: 50 });
    opacity.value = withTiming(activeOpacity, { duration: 50 });
  };

  const handlePressOut = () => {
    if (disabled) return;
    scale.value = withTiming(1, { duration: 100 });
    opacity.value = withTiming(1, { duration: 100 });
  };

  return (
    <Pressable
      onPress={onPress}
      onPressIn={handlePressIn}
      onPressOut={handlePressOut}
      disabled={disabled}
    >
      <Animated.View style={[style, animatedStyle]}>
        {children}
      </Animated.View>
    </Pressable>
  );
};

// 2. Nefes Alan Arkaplan (Ambient)
export const BreathingBackground = () => {
  const { colors } = useTheme();
  const opacity = useSharedValue(0.3);
  
  useEffect(() => {
    opacity.value = withRepeat(
      withSequence(
        withTiming(0.4, { duration: 4000 }),
        withTiming(0.2, { duration: 4000 })
      ),
      -1,
      true
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    opacity: opacity.value,
  }));

  return (
    <Animated.View
      style={[
        {
          position: 'absolute',
          top: -200,
          left: -100,
          right: -100,
          bottom: -200,
          backgroundColor: colors.tertiary,
          zIndex: -1,
          borderRadius: 1000,
          opacity: 0.2,
          transform: [{ scale: 1.2 }]
        },
        animatedStyle,
      ]}
    />
  );
};

// 3. Liste ElemanlarÄ± (Instant GiriÅŸ)
export const StaggeredItem = ({ children, index, style }: { children: React.ReactNode, index: number, style?: StyleProp<ViewStyle> }) => {
  return (
    <Animated.View
      entering={FadeIn.delay(index * 15).duration(200)} 
      layout={Layout.duration(150)}
      style={style}
    >
      {children}
    </Animated.View>
  );
};
</file>

<file path="components/dashboard/AddStatusMoodModal.tsx">
import { GeliomButton, Typography } from '@/components/shared';
import { useTheme } from '@/contexts/ThemeContext';
import { Ionicons } from '@expo/vector-icons';
import { BlurView } from 'expo-blur';
import React, { useState } from 'react';
import { KeyboardAvoidingView, Modal, Platform, StyleSheet, TextInput, TouchableOpacity, View } from 'react-native';

interface AddStatusMoodModalProps {
  visible: boolean;
  type: 'status' | 'mood';
  onClose: () => void;
  onSave: (text: string, emoji: string) => void;
}

export default function AddStatusMoodModal({ visible, type, onClose, onSave }: AddStatusMoodModalProps) {
  const { colors } = useTheme();
  const [text, setText] = useState('');
  const [emoji, setEmoji] = useState(type === 'mood' ? 'ğŸ˜Š' : '');

  const handleSave = () => {
    if (!text.trim()) return;
    onSave(text.trim(), emoji);
    setText('');
    setEmoji(type === 'mood' ? 'ğŸ˜Š' : '');
    onClose();
  };

  const EMOJI_OPTIONS = ['ğŸ˜Š', 'ğŸ˜”', 'ğŸ˜¡', 'ğŸ˜´', 'ğŸ¥³', 'ğŸ¤”', 'ğŸ¤¢', 'ğŸ˜', 'ğŸ¤¯', 'ğŸ¥º'];

  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onClose}
    >
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.container}
      >
        <View style={styles.backdrop}>
          <TouchableOpacity style={StyleSheet.absoluteFill} onPress={onClose} />
          <BlurView intensity={20} tint="dark" style={StyleSheet.absoluteFill} />
        </View>

        <View style={[styles.content, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}>
          <View style={styles.header}>
            <Typography variant="h6" color={colors.text}>
              {type === 'status' ? 'Yeni Durum Ekle' : 'Yeni Mood Ekle'}
            </Typography>
            <TouchableOpacity onPress={onClose}>
              <Ionicons name="close" size={24} color={colors.secondaryText} />
            </TouchableOpacity>
          </View>

          <View style={styles.form}>
            {type === 'mood' && (
              <View style={styles.emojiSection}>
                <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 8 }}>
                  Emoji SeÃ§
                </Typography>
                <View style={styles.emojiList}>
                  {EMOJI_OPTIONS.map((e) => (
                    <TouchableOpacity
                      key={e}
                      onPress={() => setEmoji(e)}
                      style={[
                        styles.emojiItem,
                        emoji === e && { backgroundColor: colors.primary + '20', borderColor: colors.primary }
                      ]}
                    >
                      <Typography variant="h5">{e}</Typography>
                    </TouchableOpacity>
                  ))}
                </View>
              </View>
            )}

            <View style={styles.inputContainer}>
              <Typography variant="body" color={colors.secondaryText} style={{ marginBottom: 8 }}>
                {type === 'status' ? 'Durum Metni' : 'Mood AdÄ±'}
              </Typography>
              <TextInput
                style={[styles.input, { color: colors.text, borderColor: colors.stroke, backgroundColor: colors.background }]}
                placeholder={type === 'status' ? "Ã–rn: ToplantÄ±da" : "Ã–rn: Harika"}
                placeholderTextColor={colors.secondaryText}
                value={text}
                onChangeText={setText}
                autoFocus
              />
            </View>
          </View>

          <View style={styles.footer}>
            <GeliomButton
              state="passive"
              onPress={onClose}
              style={{ marginRight: 12, flex: 1 }}
            >
              Ä°ptal
            </GeliomButton>
            <GeliomButton
              state={text.trim() ? 'active' : 'passive'}
              onPress={handleSave}
              style={{ flex: 1 }}
            >
              Ekle
            </GeliomButton>
          </View>
        </View>
      </KeyboardAvoidingView>
    </Modal>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  backdrop: {
    ...StyleSheet.absoluteFillObject,
    zIndex: 1,
  },
  content: {
    width: '100%',
    maxWidth: 400,
    borderRadius: 24,
    borderWidth: 1,
    padding: 24,
    zIndex: 2,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.25,
    shadowRadius: 20,
    elevation: 10,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 24,
  },
  form: {
    gap: 20,
    marginBottom: 24,
  },
  emojiSection: {
    gap: 8,
  },
  emojiList: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  emojiItem: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'transparent',
  },
  inputContainer: {
    gap: 8,
  },
  input: {
    height: 48,
    borderRadius: 12,
    borderWidth: 1,
    paddingHorizontal: 16,
    fontSize: 16,
  },
  footer: {
    flexDirection: 'row',
  },
});
</file>

<file path="components/dashboard/CurrentUserHeader.tsx">
import { Typography } from '@/components/shared';
import { useTheme } from '@/contexts/ThemeContext';
import type { GroupMemberWithUser, UserGroupMoodWithMood, UserStatusWithStatus } from '@/types/database';
import { getAvatarSource } from '@/utils/avatar';
import { Image } from 'expo-image';
import React from 'react';
import { StyleSheet, View } from 'react-native';
import Animated from 'react-native-reanimated';

interface CurrentUserHeaderProps {
  member: GroupMemberWithUser;
  status?: UserStatusWithStatus;
  mood?: UserGroupMoodWithMood;
}

export default function CurrentUserHeader({ member, status, mood }: CurrentUserHeaderProps) {
  const { colors } = useTheme();

  const user = member.user as any;
  const displayName = user?.full_name || user?.email?.split('@')[0] || 'Ben';
  const avatarSource = getAvatarSource(user?.avatar);

  const statusText = status?.status?.text;
  const statusColor = status?.status?.is_custom
    ? colors.primary
    : (status?.status?.notifies ? colors.warning : colors.secondaryText);

  const moodEmoji = mood?.mood?.emoji;
  const moodText = mood?.mood?.text;

  return (
    <Animated.View
      style={styles.container}
    >
      <View style={styles.topRow}>
        {/* Avatar & Greeting */}
        <View style={styles.userInfo}>
          <Image
            source={avatarSource}
            style={styles.avatar}
          />
          <View style={styles.greetingContainer}>
            <Typography variant="caption" color={colors.secondaryText}>
              Tekrar merhaba,
            </Typography>
            <Typography variant="h4" color={colors.text} style={styles.name}>
              {displayName}
            </Typography>
          </View>
        </View>

        {/* Mood Indicator (Top Right) */}
        {moodEmoji && (
          <View style={[styles.moodBadge, { backgroundColor: colors.cardBackground }]}>
            <Typography variant="h3">{moodEmoji}</Typography>
          </View>
        )}
      </View>

      {/* Status Display (Large & Bold) */}
      <View style={styles.statusContainer}>
        <View style={[styles.statusDot, { backgroundColor: statusColor }]} />
        <Typography
          variant="h3"
          color={statusText ? colors.text : colors.secondaryText}
          style={styles.statusText}
        >
          {statusText || 'Durum ayarla...'}
        </Typography>
      </View>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  container: {
    paddingVertical: 24,
    paddingHorizontal: 4,
  },
  topRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  userInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  avatar: {
    width: 48,
    height: 48,
    borderRadius: 24,
  },
  greetingContainer: {
    justifyContent: 'center',
  },
  name: {
    fontWeight: '700',
  },
  moodBadge: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  statusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    paddingLeft: 4,
  },
  statusDot: {
    width: 12,
    height: 12,
    borderRadius: 6,
  },
  statusText: {
    fontWeight: '800', // Extra bold for emphasis
  },
});
</file>

<file path="components/dashboard/index.ts">
export { default as DashboardView } from './DashboardView';
export { default as EmptyStateView } from './EmptyStateView';
export { default as MemberCard } from './MemberCard';
export { default as StatusSelector } from './StatusSelector';
</file>

<file path="components/shared/AvatarSelector.tsx">
import { useTheme } from '@/contexts/ThemeContext';
import { getAvailableAvatars, getAvatarSource } from '@/utils/avatar';
import { Ionicons } from '@expo/vector-icons';
import React, { useEffect, useState } from 'react';
import { Image, Modal, ScrollView, StyleSheet, TouchableOpacity, View } from 'react-native';
import { GeliomButton } from './index';
import Typography from './Typography';

interface AvatarSelectorProps {
  visible: boolean;
  currentAvatar: string | null | undefined;
  onSelect: (avatar: string | null) => void;
  onClose: () => void;
}

export default function AvatarSelector({ visible, currentAvatar, onSelect, onClose }: AvatarSelectorProps) {
  const { colors } = useTheme();
  const avatars = getAvailableAvatars();
  const [selectedAvatar, setSelectedAvatar] = useState<string | null>(currentAvatar || null);

  // Modal aÃ§Ä±ldÄ±ÄŸÄ±nda currentAvatar'Ä± selectedAvatar'a set et
  useEffect(() => {
    if (visible) {
      setSelectedAvatar(currentAvatar || null);
    }
  }, [visible, currentAvatar]);

  return (
    <Modal
      visible={visible}
      transparent
      animationType="fade"
      onRequestClose={onClose}
    >
      <TouchableOpacity
        style={styles.modalOverlay}
        activeOpacity={1}
        onPress={onClose}
      >
        <TouchableOpacity
          activeOpacity={1}
          onPress={(e) => e.stopPropagation()}
          style={[styles.modalContent, { backgroundColor: colors.cardBackground }]}
        >
          <View style={styles.header}>
            <Typography variant="h5" color={colors.text}>
              Avatar SeÃ§
            </Typography>
            <TouchableOpacity onPress={onClose} style={styles.closeButton}>
              <Ionicons name="close" size={24} color={colors.text} />
            </TouchableOpacity>
          </View>

          <ScrollView
            contentContainerStyle={styles.avatarGrid}
            showsVerticalScrollIndicator={false}
          >
            {avatars.map((avatar) => {
              const isSelected = selectedAvatar === avatar;
              return (
                <TouchableOpacity
                  key={avatar}
                  onPress={() => setSelectedAvatar(avatar)}
                  style={[
                    styles.avatarItem,
               
                  ]}
                >
                  <Image
                    source={getAvatarSource(avatar)}
                    style={styles.avatarImage}
                    resizeMode="cover"
                  />
                  {isSelected && (
                    <View style={[styles.checkmark, { backgroundColor: colors.primary }]}>
                      <Ionicons name="checkmark" size={16} color={colors.white} />
                    </View>
                  )}
                </TouchableOpacity>
              );
            })}
          </ScrollView>

          {/* Kaydet Butonu */}
          <View style={styles.footer}>
            <GeliomButton
              state="active"
              size="large"
              layout="full-width"
              onPress={() => {
                onSelect(selectedAvatar);
                onClose();
              }}
            >
              Kaydet
            </GeliomButton>
          </View>
        </TouchableOpacity>
      </TouchableOpacity>
    </Modal>
  );
}

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '90%',
    maxWidth: 400,
    maxHeight: '80%',
    borderRadius: 20,
    padding: 20,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  closeButton: {
    padding: 4,
  },
  avatarGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 12,
    paddingBottom: 16,
  },
  avatarItem: {
    width: '30%',
    aspectRatio: 1,
    overflow: 'hidden',
    position: 'relative',
  },
  avatarImage: {
    width: '100%',
    height: '100%',
  },
  checkmark: {
    position: 'absolute',
    top: 8,
    right: 8,
    width: 24,
    height: 24,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  footer: {
    paddingTop: 16,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0, 0, 0, 0.1)',
    marginTop: 8,
  },
});
</file>

<file path="components/shared/BlurButton.tsx">
import { useTheme } from '@/contexts/ThemeContext';
import { fonts, typography } from '@/theme/typography';
import { BlurView } from 'expo-blur';
import { LinearGradient } from 'expo-linear-gradient';
import React, { ReactNode } from 'react';
import {
    StyleSheet,
    Text,
    TouchableOpacity,
    View,
    ViewStyle,
} from 'react-native';

// Button variant tipleri
export type BlurButtonVariant = 
  | 'primary'      // 1. Ana yeÅŸil gradient
  | 'secondary'    // 2. Ä°kincil yeÅŸil
  | 'tertiary'     // 3. AÃ§Ä±k yeÅŸil
  | 'success'      // 4. BaÅŸarÄ± yeÅŸili
  | 'glass'        // 5. Åeffaf cam efekti
  | 'outline'      // 6. Ã‡erÃ§eveli
  | 'ghost'        // 7. Hayalet buton
  | 'danger'       // 8. Hata/silme butonu
  | 'forest'       // 9. Orman yeÅŸili
  | 'mint'         // 10. Nane yeÅŸili
  | 'lime'         // 11. Limon yeÅŸili
  | 'emerald'      // 12. ZÃ¼mrÃ¼t yeÅŸili
  | 'sage'         // 13. AdaÃ§ayÄ± yeÅŸili
  | 'olive'        // 14. Zeytin yeÅŸili
  | 'jade'         // 15. YeÅŸim yeÅŸili
  | 'teal'         // 16. Ã‡amurcun yeÅŸili
  | 'pine'         // 17. Ã‡am yeÅŸili
  | 'moss'         // 18. Yosun yeÅŸili
  | 'seafoam'      // 19. Deniz kÃ¶pÃ¼ÄŸÃ¼
  | 'spring'       // 20. Bahar yeÅŸili

export type BlurButtonSize = 'small' | 'medium' | 'large';

export type BlurButtonRadius = 'none' | 'small' | 'medium' | 'large' | 'full';

export interface BlurButtonProps {
  children: ReactNode;
  variant?: BlurButtonVariant;
  size?: BlurButtonSize;
  radius?: BlurButtonRadius;
  disabled?: boolean;
  onPress?: () => void;
  style?: ViewStyle;
  icon?: ReactNode;
  iconPosition?: 'left' | 'right';
  fullWidth?: boolean;
  loading?: boolean;
}

const BlurButton: React.FC<BlurButtonProps> = ({
  children,
  variant = 'primary',
  size = 'medium',
  radius = 'medium',
  disabled = false,
  onPress,
  style,
  icon,
  iconPosition = 'left',
  fullWidth = false,
  loading = false,
}) => {
  const { colors, isDark } = useTheme();

  // Size configurations
  const sizeConfig = {
    small: {
      paddingHorizontal: 16,
      paddingVertical: 8,
      fontSize: typography.caption.fontSize,
      fontFamily: fonts[typography.caption.defaultFontWeight],
      minHeight: 36,
    },
    medium: {
      paddingHorizontal: 20,
      paddingVertical: 12,
      fontSize: typography.button.fontSize,
      fontFamily: fonts[typography.button.defaultFontWeight],
      minHeight: 44,
    },
    large: {
      paddingHorizontal: 24,
      paddingVertical: 16,
      fontSize: typography.h6.fontSize,
      fontFamily: fonts[typography.h6.defaultFontWeight],
      minHeight: 52,
    },
  };

  const currentSize = sizeConfig[size];

  // Radius configurations
  const radiusConfig = {
    none: 0,
    small: 6,
    medium: 12,
    large: 20,
    full: 9999,
  };

  const currentRadius = radiusConfig[radius];

  // Variant configurations
  const getVariantStyle = () => {
    switch (variant) {
      case 'primary':
        return {
          gradient: [colors.primary, colors.secondary] as const,
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: colors.primary,
          useGradient: true,
          useBlur: false,
        };
      
      case 'secondary':
        return {
          backgroundColor: colors.secondary,
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: colors.secondary,
          useGradient: false,
          useBlur: false,
        };
      
      case 'tertiary':
        return {
          backgroundColor: colors.tertiary,
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: colors.tertiary,
          useGradient: false,
          useBlur: false,
        };
      
      case 'success':
        return {
          backgroundColor: colors.success,
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: colors.success,
          useGradient: false,
          useBlur: false,
        };
      
      case 'glass':
        return {
          backgroundColor: 'transparent',
          textColor: colors.text,
          borderColor: colors.stroke,
          shadowColor: colors.shadow,
          useGradient: false,
          useBlur: true,
        };
      
      case 'outline':
        return {
          backgroundColor: 'transparent',
          textColor: colors.primary,
          borderColor: colors.primary,
          shadowColor: 'transparent',
          useGradient: false,
          useBlur: false,
        };
      
      case 'ghost':
        return {
          backgroundColor: colors.primary + '20',
          textColor: colors.primary,
          borderColor: 'transparent',
          shadowColor: 'transparent',
          useGradient: false,
          useBlur: false,
        };
      
      case 'danger':
        return {
          backgroundColor: colors.error,
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: colors.error,
          useGradient: false,
          useBlur: false,
        };
      
      case 'forest':
        return {
          backgroundColor: (colors as any).forest || '#1B5E20',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).forest || '#1B5E20',
          useGradient: false,
          useBlur: false,
        };
      
      case 'mint':
        return {
          backgroundColor: (colors as any).mint || '#00E676',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).mint || '#00E676',
          useGradient: false,
          useBlur: false,
        };
      
      case 'lime':
        return {
          backgroundColor: (colors as any).lime || '#8BC34A',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).lime || '#8BC34A',
          useGradient: false,
          useBlur: false,
        };
      
      case 'emerald':
        return {
          backgroundColor: (colors as any).emerald || '#009688',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).emerald || '#009688',
          useGradient: false,
          useBlur: false,
        };
      
      case 'sage':
        return {
          backgroundColor: (colors as any).sage || '#87A96B',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).sage || '#87A96B',
          useGradient: false,
          useBlur: false,
        };
      
      case 'olive':
        return {
          backgroundColor: (colors as any).olive || '#6B8E23',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).olive || '#6B8E23',
          useGradient: false,
          useBlur: false,
        };
      
      case 'jade':
        return {
          backgroundColor: (colors as any).jade || '#00A86B',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).jade || '#00A86B',
          useGradient: false,
          useBlur: false,
        };
      
      case 'teal':
        return {
          backgroundColor: (colors as any).teal || '#008080',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).teal || '#008080',
          useGradient: false,
          useBlur: false,
        };
      
      case 'pine':
        return {
          backgroundColor: (colors as any).pine || '#01796F',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).pine || '#01796F',
          useGradient: false,
          useBlur: false,
        };
      
      case 'moss':
        return {
          backgroundColor: (colors as any).moss || '#8A9A5B',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).moss || '#8A9A5B',
          useGradient: false,
          useBlur: false,
        };
      
      case 'seafoam':
        return {
          backgroundColor: (colors as any).seafoam || '#71BC78',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).seafoam || '#71BC78',
          useGradient: false,
          useBlur: false,
        };
      
      case 'spring':
        return {
          backgroundColor: (colors as any).spring || '#00FF7F',
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: (colors as any).spring || '#00FF7F',
          useGradient: false,
          useBlur: false,
        };
      
      default:
        return {
          backgroundColor: colors.primary,
          textColor: colors.white,
          borderColor: 'transparent',
          shadowColor: colors.primary,
          useGradient: false,
          useBlur: false,
        };
    }
  };

  const variantStyle = getVariantStyle();

  const buttonStyle: ViewStyle = {
    ...currentSize,
    borderRadius: currentRadius,
    borderWidth: variantStyle.borderColor !== 'transparent' ? 1 : 0,
    borderColor: variantStyle.borderColor,
    opacity: disabled ? 0.5 : 1,
    width: fullWidth ? '100%' : undefined,
    shadowColor: variantStyle.shadowColor,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 5,
    overflow: 'hidden',
    ...style,
  };

  const renderContent = () => (
    <View style={styles.contentContainer}>
      {icon && iconPosition === 'left' && (
        <View style={styles.iconContainer}>{icon}</View>
      )}
      
      <Text
        style={[
          styles.text,
          {
            color: variantStyle.textColor,
            fontSize: currentSize.fontSize,
            fontFamily: currentSize.fontFamily,
          },
        ]}
      >
        {loading ? 'YÃ¼kleniyor...' : children}
      </Text>
      
      {icon && iconPosition === 'right' && (
        <View style={styles.iconContainer}>{icon}</View>
      )}
    </View>
  );

  const renderButton = () => {
    if (variantStyle.useBlur) {
      return (
        <BlurView
          intensity={20}
          tint={isDark ? 'dark' : 'light'}
          style={buttonStyle}
        >
          {renderContent()}
        </BlurView>
      );
    }

    if (variantStyle.useGradient && variantStyle.gradient) {
      return (
        <LinearGradient
          colors={variantStyle.gradient}
          style={buttonStyle}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        >
          {renderContent()}
        </LinearGradient>
      );
    }

    return (
      <View style={[buttonStyle, { backgroundColor: variantStyle.backgroundColor }]}>
        {renderContent()}
      </View>
    );
  };

  return (
    <TouchableOpacity
      onPress={onPress}
      disabled={disabled || loading}
      activeOpacity={0.8}
      style={styles.touchable}
    >
      {renderButton()}
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  touchable: {
    alignSelf: 'flex-start',
  },
  contentContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
  },
  text: {
    textAlign: 'center',
    fontWeight: '600',
  },
  iconContainer: {
    alignItems: 'center',
    justifyContent: 'center',
  },
});

export default BlurButton;
</file>

<file path="components/shared/Popover.tsx">
import { useTheme } from "@/contexts/ThemeContext";
import React, { useRef, useState } from "react";
import { Dimensions, Modal, StyleSheet, TouchableOpacity, TouchableWithoutFeedback, View } from "react-native";
import CustomText from "./Text";

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

export interface PopoverItem {
    id: string;
    label: string;
    icon?: React.ReactNode;
    onPress: () => void;
}

interface PopoverProps {
    items: PopoverItem[];
    trigger: React.ReactNode; // TÄ±klanacak element (icon, button, vs.)
    width?: number; // Popover geniÅŸliÄŸi (default: 200)
}

interface Position {
    top?: number;
    bottom?: number;
    left?: number;
    right?: number;
}

export default function Popover({ items, trigger, width = 200 }: PopoverProps) {
    const { colors } = useTheme();
    const [visible, setVisible] = useState(false);
    const [position, setPosition] = useState<Position>({});
    const triggerRef = useRef<View>(null);

    const POPOVER_PADDING = 8; // Ekran kenarÄ±ndan minimum mesafe
    const ITEM_HEIGHT = 48; // Her item'Ä±n yÃ¼ksekliÄŸi
    const POPOVER_HEIGHT = items.length * ITEM_HEIGHT;

    // Trigger'a tÄ±klandÄ±ÄŸÄ±nda popover'Ä± aÃ§ ve pozisyonu hesapla
    const handleOpen = () => {
        triggerRef.current?.measureInWindow((x, y, triggerWidth, triggerHeight) => {
            const calculatedPosition = calculatePosition(x, y, triggerWidth, triggerHeight);
            setPosition(calculatedPosition);
            setVisible(true);
        });
    };

    // En uygun pozisyonu hesapla
    const calculatePosition = (
        triggerX: number,
        triggerY: number,
        triggerWidth: number,
        triggerHeight: number
    ): Position => {
        const pos: Position = {};

        // Yatay pozisyon (saÄŸ veya sol)
        const spaceOnRight = SCREEN_WIDTH - (triggerX + triggerWidth);
        const spaceOnLeft = triggerX;

        if (spaceOnRight >= width + POPOVER_PADDING) {
            // SaÄŸda yeterli alan var, saÄŸa aÃ§
            pos.left = triggerX + triggerWidth + POPOVER_PADDING;
        } else if (spaceOnLeft >= width + POPOVER_PADDING) {
            // Solda yeterli alan var, sola aÃ§
            pos.right = SCREEN_WIDTH - triggerX + POPOVER_PADDING;
        } else {
            // Her iki tarafta da yeterli alan yok, trigger'Ä±n altÄ±na/Ã¼stÃ¼ne ortalÄ± aÃ§
            const centeredLeft = triggerX + triggerWidth / 2 - width / 2;
            pos.left = Math.max(POPOVER_PADDING, Math.min(centeredLeft, SCREEN_WIDTH - width - POPOVER_PADDING));
        }

        // Dikey pozisyon (alt veya Ã¼st)
        const spaceBelow = SCREEN_HEIGHT - (triggerY + triggerHeight);
        const spaceAbove = triggerY;

        if (spaceBelow >= POPOVER_HEIGHT + POPOVER_PADDING) {
            // Altta yeterli alan var
            pos.top = triggerY + triggerHeight + POPOVER_PADDING;
        } else if (spaceAbove >= POPOVER_HEIGHT + POPOVER_PADDING) {
            // Ãœstte yeterli alan var
            pos.bottom = SCREEN_HEIGHT - triggerY + POPOVER_PADDING;
        } else {
            // Her iki tarafta da yeterli alan yok, trigger'Ä±n yanÄ±na ortalÄ± aÃ§
            if (pos.left !== undefined || pos.right !== undefined) {
                // Yatay aÃ§Ä±lÄ±m yapÄ±lmÄ±ÅŸsa, dikey olarak trigger'la hizala
                pos.top = Math.max(POPOVER_PADDING, Math.min(triggerY, SCREEN_HEIGHT - POPOVER_HEIGHT - POPOVER_PADDING));
            } else {
                // EkranÄ±n ortasÄ±na yerleÅŸtir
                pos.top = (SCREEN_HEIGHT - POPOVER_HEIGHT) / 2;
            }
        }

        return pos;
    };

    const handleClose = () => {
        setVisible(false);
    };

    const handleItemPress = (item: PopoverItem) => {
        item.onPress();
        handleClose();
    };

    return (
        <>
            {/* Trigger Element */}
            <View ref={triggerRef} collapsable={false}>
                <TouchableOpacity onPress={handleOpen} activeOpacity={0.7}>
                    {trigger}
                </TouchableOpacity>
            </View>

            {/* Popover Modal */}
            <Modal
                visible={visible}
                transparent
                animationType="fade"
                onRequestClose={handleClose}
            >
                <TouchableWithoutFeedback onPress={handleClose}>
                    <View style={styles.overlay}>
                        <TouchableWithoutFeedback>
                            <View
                                style={[
                                    styles.popoverContainer,
                                    {
                                        backgroundColor: colors.background,
                                        borderColor: colors.stroke,
                                        width: width,
                                    },
                                    position,
                                ]}
                            >
                                {items.map((item, index) => (
                                    <React.Fragment key={item.id}>
                                        <TouchableOpacity
                                            style={styles.item}
                                            onPress={() => handleItemPress(item)}
                                            activeOpacity={0.7}
                                        >
                                            <CustomText
                                                variant="h7"
                                                fontWeight="regular"
                                                style={[styles.label, { color: colors.text }]}
                                            >
                                                {item.label}
                                            </CustomText>
                                            {item.icon && (
                                                <View style={styles.iconContainer}>
                                                    {item.icon}
                                                </View>
                                            )}
                                        </TouchableOpacity>
                                        {index < items.length - 1 && (
                                            <View style={[styles.divider, { backgroundColor: colors.stroke }]} />
                                        )}
                                    </React.Fragment>
                                ))}
                            </View>
                        </TouchableWithoutFeedback>
                    </View>
                </TouchableWithoutFeedback>
            </Modal>
        </>
    );
}

const styles = StyleSheet.create({
    overlay: {
        flex: 1,
        backgroundColor: 'transparent', // Overlay yok
    },
    popoverContainer: {
        position: 'absolute',
        borderRadius: 12,
        borderWidth: 1,
        overflow: 'hidden',
    },
    item: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        paddingHorizontal: 16,
        paddingVertical: 12,
        height: 48,
    },
    label: {
        flex: 1,
    },
    iconContainer: {
        marginLeft: 12,
    },
    divider: {
        height: 1,
        marginHorizontal: 0, // Kenarlara sÄ±fÄ±r
    },
});
</file>

<file path="components/shared/SplashScreen.tsx">
import { useTheme } from '@/contexts/ThemeContext';
import { fonts } from '@/theme/typography';
import React, { useEffect } from 'react';
import { ActivityIndicator, StyleSheet, View } from 'react-native';
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withSpring,
  withTiming
} from 'react-native-reanimated';

export const SplashScreen: React.FC = () => {
  const { colors } = useTheme();
  const opacity = useSharedValue(0);
  const scale = useSharedValue(0.3);

  useEffect(() => {
    opacity.value = withTiming(1, { duration: 800 });
    scale.value = withSpring(1, {
      damping: 10,
      stiffness: 100,
    });
  }, []);

  const animatedStyle = useAnimatedStyle(() => {
    return {
      opacity: opacity.value,
      transform: [{ scale: scale.value }],
    };
  });

  return (
    <View style={[styles.container, { backgroundColor: colors.background }]}>
      <Animated.View style={[styles.content, animatedStyle]}>
        <View style={styles.logoContainer}>
          <Animated.Text
            style={[
              styles.logo,
              {
                color: colors.primary,
                fontFamily: fonts.bold,
              },
            ]}
          >
            Geliom
          </Animated.Text>
        </View>

        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={colors.primary} />
          <Animated.Text
            style={[
              styles.loadingText,
              {
                color: colors.secondaryText,
                fontFamily: fonts.regular,
              },
            ]}
          >
            YÃ¼kleniyor...
          </Animated.Text>
        </View>
      </Animated.View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  content: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  logoContainer: {
    marginBottom: 60,
  },
  logo: {
    fontSize: 48,
    letterSpacing: 2,
  },
  loadingContainer: {
    alignItems: 'center',
    gap: 16,
  },
  loadingText: {
    fontSize: 16,
    letterSpacing: 0.5,
  },
});
</file>

<file path="components/shared/Text.tsx">
import { useTheme } from '@/contexts/ThemeContext';
import { fonts, typography, type Fonts, type TypographyKeys } from '@/theme/typography';
import { Platform, Text as RNText, TextProps as RNTextProps, StyleProp, TextStyle } from 'react-native';

interface TextProps extends RNTextProps {
    variant?: keyof TypographyKeys;
    fontWeight?: keyof Fonts;
    color?: string;
}

export default function CustomText({
    variant = 'body',
    fontWeight,
    children,
    style,
    color,
    ...props
}: TextProps) {
    const { colors } = useTheme();
    const variantStyle = typography[variant];
    const { defaultFontWeight, ...baseVariantStyles } = variantStyle;
    const finalWeight = fontWeight || defaultFontWeight;
    const fontFamily = fonts[finalWeight];

    let processedChildren = children;

    if (typeof children === 'string') {
        processedChildren = children
            .replace(/tt/g, 't\u200Bt') 
            .replace(/fi/g, 'f\u200Bi') 
            .replace(/fl/g, 'f\u200Bl') 
            .replace(/ti/g, 't\u200Bi') 
            .replace(/ff/g, 'f\u200Bf');
    }

    const combinedStyle = [
        { color: color || colors.text },
        baseVariantStyles,
        { fontFamily: fontFamily },
        style,
    ] as StyleProp<TextStyle>[];

    return (
        <RNText 
            style={[combinedStyle, Platform.OS === 'android' && {fontVariant: ['no-common-ligatures']}]} 
            {...props}
        >
            {processedChildren}
        </RNText>
    );
};
</file>

<file path="components/shared/Typography.tsx">
import { useTheme } from '@/contexts/ThemeContext';
import { fonts, typography, TypographyKeys } from '@/theme/typography';
import React from 'react';
import { Text, TextProps, TextStyle } from 'react-native';

// Typography component props
interface TypographyProps extends TextProps {
  variant?: keyof TypographyKeys;
  color?: string;
  fontWeight?: keyof typeof fonts;
  children: React.ReactNode;
}

// Typography component - Geliom iÃ§in optimize edilmiÅŸ
const Typography: React.FC<TypographyProps> = ({
  variant = 'body',
  color,
  fontWeight,
  style,
  children,
  ...props
}) => {
  const { colors } = useTheme();
  
  // SeÃ§ilen variant'Ä±n stillerini al
  const variantStyle = typography[variant];
  
  // Font weight'i belirle (prop > variant default > regular)
  const finalFontWeight = fontWeight || variantStyle.defaultFontWeight;
  
  // Final style'Ä± oluÅŸtur
  const textStyle: TextStyle = {
    fontSize: variantStyle.fontSize,
    lineHeight: variantStyle.lineHeight,
    fontFamily: fonts[finalFontWeight],
    letterSpacing: variantStyle.letterSpacing,
    color: color || colors.text,
    ...(Array.isArray(style) ? Object.assign({}, ...style) : style),
  };

  return (
    <Text style={textStyle} {...props}>
      {children}
    </Text>
  );
};

export default Typography;
</file>

<file path="contexts/NetworkToastContext.tsx">
import NetworkToast, { NetworkToastType } from "@/components/ui/NetworkToast";
import { useNetworkStatus } from "@/hooks/useNetworkStatus";
import React, { createContext, useContext, useState } from "react";

interface ToastState {
  visible: boolean;
  type: NetworkToastType;
  message: string;
}

interface NetworkToastContextType {
  showWeakConnectionToast: (message?: string) => void;
  showOfflineToast: (message?: string) => void;
  hideToast: () => void;
  checkAndShowToast: () => Promise<boolean>; // Returns true if connection is OK
}

const NetworkToastContext = createContext<NetworkToastContextType | undefined>(undefined);

const DEFAULT_MESSAGES = {
  weak: "Face not recognized in the photo. Please upload a clearer photo.",
  offline: "No social media profile found for this person. Please try another photo.",
};

export function NetworkToastProvider({ children }: { children: React.ReactNode }) {
  const [toastState, setToastState] = useState<ToastState>({
    visible: false,
    type: 'weak',
    message: '',
  });
  const { checkConnection } = useNetworkStatus();

  const showWeakConnectionToast = (message?: string) => {
    setToastState({
      visible: true,
      type: 'weak',
      message: message || DEFAULT_MESSAGES.weak,
    });
  };

  const showOfflineToast = (message?: string) => {
    setToastState({
      visible: true,
      type: 'offline',
      message: message || DEFAULT_MESSAGES.offline,
    });
  };

  const hideToast = () => {
    setToastState((prev) => ({ ...prev, visible: false }));
  };

  const checkAndShowToast = async (): Promise<boolean> => {
    const status = await checkConnection();

    if (status === 'offline') {
      showOfflineToast();
      return false;
    }

    if (status === 'weak') {
      showWeakConnectionToast();
      return false;
    }

    return true;
  };

  return (
    <NetworkToastContext.Provider
      value={{
        showWeakConnectionToast,
        showOfflineToast,
        hideToast,
        checkAndShowToast,
      }}
    >
      {children}
      <NetworkToast
        type={toastState.type}
        message={toastState.message}
        visible={toastState.visible}
        onHide={hideToast}
        duration={3000}
      />
    </NetworkToastContext.Provider>
  );
}

export function useNetworkToast() {
  const context = useContext(NetworkToastContext);
  if (!context) {
    throw new Error('useNetworkToast must be used within NetworkToastProvider');
  }
  return context;
}
</file>

<file path="contexts/ThemeContext.tsx">
import AsyncStorage from '@react-native-async-storage/async-storage';
import React, { createContext, useContext, useEffect, useState } from 'react';
import { useColorScheme } from 'react-native';
import { darkColors, lightColors } from '../theme/colors';

// 1. Context'i oluÅŸtur
export const ThemeContext = createContext({
  isDark: false,
  colors: lightColors,
  toggleTheme: () => {},
});

// 2. Provider component'ini oluÅŸtur
export const ThemeProvider = ({ children }: { children: React.ReactNode }) => {
  // CihazÄ±n temasÄ±nÄ± al
  const colorScheme = useColorScheme(); 
  
  // State'i tanÄ±mla. BaÅŸlangÄ±Ã§ta cihazÄ±n temasÄ±na gÃ¶re ayarla.
  const [isDark, setIsDark] = useState(colorScheme === 'dark');

  // Tema deÄŸiÅŸtiÄŸinde Ã§alÄ±ÅŸacak olan effect
  useEffect(() => {
    // KullanÄ±cÄ±nÄ±n daha Ã¶nce kaydettiÄŸi bir tercih var mÄ± diye kontrol et
    const loadTheme = async () => {
      try {
        const savedTheme = await AsyncStorage.getItem('theme');
        if (savedTheme !== null) {
          setIsDark(savedTheme === 'dark');
        }
      } catch (error) {
        console.error("Failed to load theme from storage", error);
      }
    };

    loadTheme();
  }, []);

  // TemayÄ± deÄŸiÅŸtiren fonksiyon
  const toggleTheme = async () => {
    const newIsDark = !isDark;
    setIsDark(newIsDark);
    try {
      await AsyncStorage.setItem('theme', newIsDark ? 'dark' : 'light');
    } catch (error) {
      console.error("Failed to save theme to storage", error);
    }
  };

  // Mevcut temaya gÃ¶re doÄŸru renk paletini seÃ§
  const themeColors = isDark ? darkColors : lightColors;

  return (
    <ThemeContext.Provider value={{ isDark, colors: themeColors, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

// 3. Kolay kullanÄ±m iÃ§in custom hook oluÅŸtur
export const useTheme = () => useContext(ThemeContext);
</file>

<file path="docs/BaseLayout-usage.md">
# BaseLayout KullanÄ±m KÄ±lavuzu

BaseLayout component'i, tÃ¼m sayfalarda kullanabileceÄŸiniz esnek ve performanslÄ± bir layout sistemidir.

## Temel KullanÄ±m

```tsx
import { BaseLayout } from '@/components/shared';

export default function MyPage() {
  return (
    <BaseLayout>
      <Text>Ä°Ã§erik buraya gelir</Text>
    </BaseLayout>
  );
}
```

## Ã–zellikler

### 1. Header GÃ¶sterimi
```tsx
// Header'Ä± gizle
<BaseLayout headerShow={false}>
  <Text>Header yok</Text>
</BaseLayout>

// Header'Ä± gÃ¶ster (default: true)
<BaseLayout headerShow={true}>
  <Text>Header var</Text>
</BaseLayout>
```

### 2. Full Screen Modu
```tsx
// Tam ekran - Safe area yok
<BaseLayout fullScreen={true}>
  <Text>Tam ekran iÃ§erik</Text>
</BaseLayout>

// Normal mod - Safe area var (default)
<BaseLayout fullScreen={false}>
  <Text>Safe area ile iÃ§erik</Text>
</BaseLayout>
```

### 3. Header KonfigÃ¼rasyonu

#### Sol Icon + Title + SaÄŸ Icon
```tsx
<BaseLayout
  header={{
    leftIcon: {
      icon: <Ionicons name="menu" size={24} color={colors.text} />,
      onPress: () => console.log('Menu'),
    },
    title: <Text style={{ color: colors.text }}>Sayfa BaÅŸlÄ±ÄŸÄ±</Text>,
    rightIcon: {
      icon: <Ionicons name="settings" size={24} color={colors.text} />,
      onPress: () => console.log('Settings'),
    },
  }}
>
  <Text>Ä°Ã§erik</Text>
</BaseLayout>
```

#### Sadece Title
```tsx
<BaseLayout
  header={{
    title: <Text style={{ color: colors.text }}>Sadece BaÅŸlÄ±k</Text>,
  }}
>
  <Text>Ä°Ã§erik</Text>
</BaseLayout>
```

#### Sadece Sol Icon
```tsx
<BaseLayout
  header={{
    leftIcon: {
      icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
      onPress: () => router.back(),
    },
  }}
>
  <Text>Ä°Ã§erik</Text>
</BaseLayout>
```

### 4. Background Image
```tsx
<BaseLayout
  backgroundImage={require('@/assets/images/background.jpg')}
>
  <Text>Background image ile</Text>
</BaseLayout>
```

### 5. Custom Background Color
```tsx
<BaseLayout
  backgroundColor="#FF0000"
>
  <Text>KÄ±rmÄ±zÄ± arkaplan</Text>
</BaseLayout>
```

### 6. Custom Styles
```tsx
<BaseLayout
  style={{ padding: 20 }}
  contentStyle={{ backgroundColor: 'rgba(0,0,0,0.5)' }}
>
  <Text>Custom style'lar</Text>
</BaseLayout>
```

### 7. Header Customization
```tsx
<BaseLayout
  header={{
    leftIcon: {
      icon: <Ionicons name="menu" size={24} color={colors.text} />,
      onPress: openMenu,
    },
    title: <Text>BaÅŸlÄ±k</Text>,
    backgroundColor: colors.primary,
    height: 60,
    style: { borderBottomWidth: 1, borderBottomColor: colors.stroke },
  }}
>
  <Text>Ä°Ã§erik</Text>
</BaseLayout>
```

## Kompleks Ã–rnek

```tsx
import { BaseLayout } from '@/components/shared';
import { useTheme } from '@/contexts/ThemeContext';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';

export default function ProfilePage() {
  const { colors, toggleTheme, isDark } = useTheme();

  return (
    <BaseLayout
      headerShow={true}
      header={{
        leftIcon: {
          icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
          onPress: () => router.back(),
        },
        title: (
          <Text style={{ 
            color: colors.text, 
            fontSize: 18, 
            fontWeight: 'bold' 
          }}>
            Profil
          </Text>
        ),
        rightIcon: {
          icon: <Ionicons name={isDark ? "sunny" : "moon"} size={24} color={colors.text} />,
          onPress: toggleTheme,
        },
        backgroundColor: colors.background,
      }}
      style={{ backgroundColor: colors.background }}
    >
      <ScrollView style={{ flex: 1, padding: 16 }}>
        <Text style={{ color: colors.text }}>Profil iÃ§eriÄŸi...</Text>
      </ScrollView>
    </BaseLayout>
  );
}
```

## Performans NotlarÄ±

- Component memoized deÄŸil, gerekirse `React.memo` ile sarmalayÄ±n
- Header icon'larÄ± TouchableOpacity ile optimize edilmiÅŸ
- Status bar otomatik tema rengine gÃ¶re ayarlanÄ±r
- Safe area insets otomatik hesaplanÄ±r
- Background image lazy load deÄŸil, gerekirse optimize edin

## Props ReferansÄ±

| Prop | Tip | Default | AÃ§Ä±klama |
|------|-----|---------|----------|
| `children` | ReactNode | - | Sayfa iÃ§eriÄŸi |
| `fullScreen` | boolean | false | Tam ekran modu |
| `headerShow` | boolean | true | Header gÃ¶sterimi |
| `header` | HeaderProps | - | Header konfigÃ¼rasyonu |
| `backgroundImage` | any | - | Arkaplan resmi |
| `backgroundColor` | string | theme.colors.background | Arkaplan rengi |
| `style` | ViewStyle | - | Container style |
| `contentStyle` | ViewStyle | - | Ä°Ã§erik style |

### HeaderProps

| Prop | Tip | Default | AÃ§Ä±klama |
|------|-----|---------|----------|
| `leftIcon` | HeaderIconProps | - | Sol icon |
| `rightIcon` | HeaderIconProps | - | SaÄŸ icon |
| `title` | ReactNode | - | BaÅŸlÄ±k |
| `backgroundColor` | string | theme.colors.background | Header arkaplan |
| `height` | number | 56 | Header yÃ¼ksekliÄŸi |
| `style` | ViewStyle | - | Header style |

### HeaderIconProps

| Prop | Tip | Default | AÃ§Ä±klama |
|------|-----|---------|----------|
| `icon` | ReactNode | - | Icon component |
| `onPress` | () => void | - | TÄ±klama fonksiyonu |
</file>

<file path="docs/bildirim-sistemi.md">
# Bildirim Sistemi - Geliom

## ğŸ“‹ Genel BakÄ±ÅŸ

Geliom projesinde bildirimler **OneSignal** kullanÄ±larak gÃ¶nderilir. Bildirimler grup bazlÄ±dÄ±r ve her bildirimde grup bilgisi bulunur.

## ğŸ¯ Bildirim FormatÄ±

### Title FormatÄ±
```
[Grup AdÄ±] - [Bildirim BaÅŸlÄ±ÄŸÄ±]
```

**Ã–rnek:**
- `Aile Grubu - Yeni KatÄ±lma Ä°steÄŸi`
- `Ä°ÅŸ ArkadaÅŸlarÄ± - Durum GÃ¼ncellendi`

### Body FormatÄ±
```
[Grup AdÄ±] grubundan: [Mesaj]
```

**Ã–rnek:**
- `Aile Grubu grubundan: Ahmet grubunuza katÄ±lmak istiyor`
- `Ä°ÅŸ ArkadaÅŸlarÄ± grubundan: Mehmet durumunu "ToplantÄ±da" olarak gÃ¼ncelledi`

### Additional Data
Her bildirimde ÅŸu bilgiler gÃ¶nderilir:
```json
{
  "group_id": "uuid",
  "group_name": "Grup AdÄ±",
  "type": "join_request" | "join_request_status" | "status_update" | "mood_update" | "event_reminder"
}
```

## ğŸ”” Bildirim TÃ¼rleri

### 1. KatÄ±lma Ä°steÄŸi (join_request)
- **GÃ¶nderen:** Ä°stek yapan kullanÄ±cÄ±
- **AlÄ±cÄ±:** Grup sahibi
- **BaÅŸlÄ±k:** `Yeni KatÄ±lma Ä°steÄŸi`
- **Mesaj:** `[KullanÄ±cÄ± AdÄ±] grubunuza katÄ±lmak istiyor`

### 2. KatÄ±lma Ä°steÄŸi Durumu (join_request_status)
- **GÃ¶nderen:** Grup sahibi
- **AlÄ±cÄ±:** Ä°stek yapan kullanÄ±cÄ±
- **BaÅŸlÄ±k:** `KatÄ±lma Ä°steÄŸi OnaylandÄ±` veya `KatÄ±lma Ä°steÄŸi Reddedildi`
- **Mesaj:** `[Grup AdÄ±] grubuna katÄ±lma isteÄŸiniz onaylandÄ±!` veya `[Grup AdÄ±] grubuna katÄ±lma isteÄŸiniz reddedildi.`

### 3. Durum GÃ¼ncellemesi (status_update)
- **GÃ¶nderen:** Durum gÃ¼ncelleyen kullanÄ±cÄ±
- **AlÄ±cÄ±:** Grup Ã¼yeleri
- **BaÅŸlÄ±k:** `Durum GÃ¼ncellendi`
- **Mesaj:** `[KullanÄ±cÄ± AdÄ±] durumunu "[Durum]" olarak gÃ¼ncelledi`

### 4. Mood GÃ¼ncellemesi (mood_update)
- **GÃ¶nderen:** Mood gÃ¼ncelleyen kullanÄ±cÄ±
- **AlÄ±cÄ±:** Grup Ã¼yeleri
- **BaÅŸlÄ±k:** `Mood GÃ¼ncellendi`
- **Mesaj:** `[KullanÄ±cÄ± AdÄ±] mood'unu "[Mood]" olarak gÃ¼ncelledi`

### 5. Etkinlik HatÄ±rlatÄ±cÄ±sÄ± (event_reminder)
- **GÃ¶nderen:** Sistem (zamanlanmÄ±ÅŸ)
- **AlÄ±cÄ±:** Grup Ã¼yeleri
- **BaÅŸlÄ±k:** `Etkinlik HatÄ±rlatÄ±cÄ±sÄ±`
- **Mesaj:** `[Etkinlik AdÄ±] iÃ§in 1 saat kaldÄ±!`

## ğŸ“± Bildirime TÄ±klama DavranÄ±ÅŸÄ±

KullanÄ±cÄ± bir bildirime tÄ±kladÄ±ÄŸÄ±nda:

1. **NotificationHandler** component'i bildirimi yakalar
2. `additionalData`'dan `group_id` ve `group_name` alÄ±nÄ±r
3. **GroupContext** kullanÄ±larak ilgili grup seÃ§ilir
4. KullanÄ±cÄ± **ana sayfaya** (`/(drawer)/home`) yÃ¶nlendirilir
5. SeÃ§ili grup otomatik olarak gÃ¶sterilir

## ğŸ—ï¸ Mimari

### 1. OneSignal Servisi (`services/onesignal.ts`)
- OneSignal SDK initialize
- Player ID alma
- Login/Logout iÅŸlemleri
- Tag yÃ¶netimi

### 2. Notification Handler (`components/NotificationHandler.tsx`)
- Bildirim tÄ±klama event'lerini dinler
- Grup seÃ§imi ve navigation yapar
- GroupContext ve Router kullanÄ±r

### 3. Bildirim API (`api/notifications.ts`)
- Supabase Edge Function'Ä± Ã§aÄŸÄ±rÄ±r
- FarklÄ± bildirim tÃ¼rleri iÃ§in helper fonksiyonlar
- Type-safe bildirim gÃ¶nderme

### 4. Supabase Edge Function (`supabase/functions/send-notification/index.ts`)
- OneSignal REST API'yi Ã§aÄŸÄ±rÄ±r
- Bildirim formatÄ±nÄ± oluÅŸturur
- CORS desteÄŸi

## ğŸ”§ Entegrasyon NoktalarÄ±

### Grup KatÄ±lma Ä°steÄŸi
- **Dosya:** `api/groups.ts`
- **Hook:** `useCreateJoinRequest`
- **Bildirim:** Grup sahibine katÄ±lma isteÄŸi bildirimi

### Ä°stek Onaylama/Reddetme
- **Dosya:** `api/groups.ts`
- **Hook'lar:** `useApproveJoinRequest`, `useRejectJoinRequest`
- **Bildirim:** Ä°stek yapan kullanÄ±cÄ±ya durum bildirimi

## âš™ï¸ Kurulum

### 1. OneSignal App ID
`app.json` dosyasÄ±nda tanÄ±mlÄ±:
```json
{
  "extra": {
    "oneSignalAppId": "dbee675a-f056-44f4-8cfc-77075183897d"
  }
}
```

### 2. Supabase Edge Function Environment Variables
```bash
ONESIGNAL_APP_ID=your-app-id
ONESIGNAL_REST_API_KEY=your-rest-api-key
```

### 3. Edge Function Deploy
```bash
supabase functions deploy send-notification
```

## ğŸ“ Notlar

- Bildirim gÃ¶nderme iÅŸlemleri **non-blocking**'dir (hata olsa bile uygulama Ã§alÄ±ÅŸmaya devam eder)
- Player ID'ler kullanÄ±cÄ± giriÅŸ yaptÄ±ÄŸÄ±nda otomatik olarak kaydedilir
- Bildirimler grup bazlÄ±dÄ±r, her bildirimde grup bilgisi bulunur
- Bildirime tÄ±klandÄ±ÄŸÄ±nda kullanÄ±cÄ± ilgili gruba yÃ¶nlendirilir
</file>

<file path="docs/Component-Showroom.md">
# Geliom - Component Showroom

Geliom uygulamasÄ±nÄ±n component'lerinin sergilendiÄŸi ve test edildiÄŸi alan.

## ğŸ¨ Showroom YapÄ±sÄ±

### EriÅŸim
- Ana sayfadan "ğŸ¨ Component Showroom" butonuna tÄ±klayarak eriÅŸilebilir
- Route: `/(app)/showroom`
- Header ile navigation ve theme toggle

### AmaÃ§
- Component'leri gÃ¶rsel olarak test etmek
- FarklÄ± variant'larÄ± karÅŸÄ±laÅŸtÄ±rmak
- Development sÃ¼recinde hÄ±zlÄ± prototype
- Design system dokÃ¼mantasyonu

## ğŸ”˜ BlurButton Component

### 12 FarklÄ± Variant

#### 1. Primary - Gradient YeÅŸil
```tsx
<BlurButton variant="primary">1. Primary</BlurButton>
```
- **GÃ¶rÃ¼nÃ¼m**: YeÅŸil gradient (primary â†’ secondary)
- **KullanÄ±m**: Ana CTA butonlarÄ±
- **Ã–zellik**: LinearGradient ile blur efekti

#### 2. Secondary - DÃ¼z YeÅŸil
```tsx
<BlurButton variant="secondary">2. Secondary</BlurButton>
```
- **GÃ¶rÃ¼nÃ¼m**: DÃ¼z secondary yeÅŸil
- **KullanÄ±m**: Ä°kincil aksiyonlar
- **Ã–zellik**: Solid background

#### 3. Tertiary - AÃ§Ä±k YeÅŸil
```tsx
<BlurButton variant="tertiary">3. Tertiary</BlurButton>
```
- **GÃ¶rÃ¼nÃ¼m**: AÃ§Ä±k yeÅŸil ton
- **KullanÄ±m**: ÃœÃ§Ã¼ncÃ¼l aksiyonlar
- **Ã–zellik**: Soft appearance

#### 4. Success - BaÅŸarÄ± YeÅŸili
```tsx
<BlurButton variant="success">4. Success</BlurButton>
```
- **GÃ¶rÃ¼nÃ¼m**: BaÅŸarÄ± yeÅŸili
- **KullanÄ±m**: Onay, baÅŸarÄ± mesajlarÄ±
- **Ã–zellik**: Positive feedback

#### 5. Glass - Cam Efekti
```tsx
<BlurButton variant="glass">5. Glass</BlurButton>
```
- **GÃ¶rÃ¼nÃ¼m**: Åeffaf cam efekti
- **KullanÄ±m**: Overlay butonlarÄ±
- **Ã–zellik**: BlurView ile glassmorphism

#### 6. Outline - Ã‡erÃ§eveli
```tsx
<BlurButton variant="outline">6. Outline</BlurButton>
```
- **GÃ¶rÃ¼nÃ¼m**: Åeffaf arkaplan, yeÅŸil Ã§erÃ§eve
- **KullanÄ±m**: Ä°kincil aksiyonlar
- **Ã–zellik**: Minimal appearance

#### 7. Ghost - Hayalet
```tsx
<BlurButton variant="ghost">7. Ghost</BlurButton>
```
- **GÃ¶rÃ¼nÃ¼m**: Åeffaf yeÅŸil arkaplan
- **KullanÄ±m**: Subtle aksiyonlar
- **Ã–zellik**: %20 opacity background

#### 8. Danger - Hata/Silme
```tsx
<BlurButton variant="danger">8. Danger</BlurButton>
```
- **GÃ¶rÃ¼nÃ¼m**: KÄ±rmÄ±zÄ± arkaplan
- **KullanÄ±m**: Silme, iptal aksiyonlarÄ±
- **Ã–zellik**: Warning appearance

#### 9. Forest - Orman YeÅŸili
```tsx
<BlurButton variant="forest">9. Forest</BlurButton>
```
- **GÃ¶rÃ¼nÃ¼m**: Koyu orman yeÅŸili (#1B5E20)
- **KullanÄ±m**: DoÄŸa temalÄ± aksiyonlar
- **Ã–zellik**: Deep green tone

#### 10. Mint - Nane YeÅŸili
```tsx
<BlurButton variant="mint">10. Mint</BlurButton>
```
- **GÃ¶rÃ¼nÃ¼m**: Parlak nane yeÅŸili (#00E676)
- **KullanÄ±m**: Fresh, energetic aksiyonlar
- **Ã–zellik**: Bright vibrant green

#### 11. Lime - Limon YeÅŸili
```tsx
<BlurButton variant="lime">11. Lime</BlurButton>
```
- **GÃ¶rÃ¼nÃ¼m**: Limon yeÅŸili (#8BC34A)
- **KullanÄ±m**: Playful, friendly aksiyonlar
- **Ã–zellik**: Light green tone

#### 12. Emerald - ZÃ¼mrÃ¼t YeÅŸili
```tsx
<BlurButton variant="emerald">12. Emerald</BlurButton>
```
- **GÃ¶rÃ¼nÃ¼m**: ZÃ¼mrÃ¼t yeÅŸili (#009688)
- **KullanÄ±m**: Premium, elegant aksiyonlar
- **Ã–zellik**: Sophisticated green

### 3 FarklÄ± Boyut

#### Small - KÃ¼Ã§Ã¼k
```tsx
<BlurButton size="small">Small</BlurButton>
```
- **Boyut**: 36px min height
- **Padding**: 16px horizontal, 8px vertical
- **Font**: Caption size

#### Medium - Orta (Default)
```tsx
<BlurButton size="medium">Medium</BlurButton>
```
- **Boyut**: 44px min height
- **Padding**: 20px horizontal, 12px vertical
- **Font**: Button size

#### Large - BÃ¼yÃ¼k
```tsx
<BlurButton size="large">Large</BlurButton>
```
- **Boyut**: 52px min height
- **Padding**: 24px horizontal, 16px vertical
- **Font**: H6 size

### 5 FarklÄ± Radius

#### None - KÃ¶ÅŸesiz
```tsx
<BlurButton radius="none">Radius: None</BlurButton>
```
- **Radius**: 0px
- **GÃ¶rÃ¼nÃ¼m**: Keskin kÃ¶ÅŸeler
- **KullanÄ±m**: Modern, geometric tasarÄ±m

#### Small - KÃ¼Ã§Ã¼k
```tsx
<BlurButton radius="small">Radius: Small</BlurButton>
```
- **Radius**: 6px
- **GÃ¶rÃ¼nÃ¼m**: Hafif yuvarlaklÄ±k
- **KullanÄ±m**: Subtle rounded corners

#### Medium - Orta (Default)
```tsx
<BlurButton radius="medium">Radius: Medium</BlurButton>
```
- **Radius**: 12px
- **GÃ¶rÃ¼nÃ¼m**: Standart yuvarlaklÄ±k
- **KullanÄ±m**: Balanced appearance

#### Large - BÃ¼yÃ¼k
```tsx
<BlurButton radius="large">Radius: Large</BlurButton>
```
- **Radius**: 20px
- **GÃ¶rÃ¼nÃ¼m**: Belirgin yuvarlaklÄ±k
- **KullanÄ±m**: Soft, friendly appearance

#### Full - Tam Yuvarlak
```tsx
<BlurButton radius="full">Radius: Full</BlurButton>
```
- **Radius**: 9999px (pill shape)
- **GÃ¶rÃ¼nÃ¼m**: Tam yuvarlak kenarlar
- **KullanÄ±m**: Pill buttons, tags

### Icon DesteÄŸi

#### Sol Icon
```tsx
<BlurButton 
  variant="primary" 
  icon={<Ionicons name="heart" size={20} color="white" />}
  iconPosition="left"
>
  BeÄŸen
</BlurButton>
```

#### SaÄŸ Icon
```tsx
<BlurButton 
  variant="secondary" 
  icon={<Ionicons name="share" size={20} color="white" />}
  iconPosition="right"
>
  PaylaÅŸ
</BlurButton>
```

### Ã–zel Ã–zellikler

#### Full Width
```tsx
<BlurButton variant="primary" fullWidth>
  Tam GeniÅŸlik Button
</BlurButton>
```

#### Disabled State
```tsx
<BlurButton variant="primary" disabled>
  Disabled
</BlurButton>
```

#### Loading State
```tsx
<BlurButton variant="secondary" loading>
  Loading
</BlurButton>
```

## ğŸ¯ Geliom'a Ã–zel TasarÄ±m

### DoÄŸa TemalÄ± Renkler
- TÃ¼m variant'lar yeÅŸil tonlarda
- DoÄŸal gradient geÃ§iÅŸleri
- Tema uyumlu renk paleti

### Blur Effects
- Glass variant'ta BlurView kullanÄ±mÄ±
- Modern glassmorphism tasarÄ±mÄ±
- iOS/Android uyumlu blur

### Typography Integration
- Comfortaa font ailesi
- Responsive font boyutlarÄ±
- Typography system entegrasyonu

### Shadow & Elevation
- Platform-specific shadow
- Depth hierarchy
- Visual feedback

## ğŸ“± KullanÄ±m Ã–rnekleri

### Ana Sayfa CTA
```tsx
<BlurButton variant="primary" size="large" fullWidth>
  GruplarÄ±m ğŸ‘¥
</BlurButton>
```

### Navigation Button
```tsx
<BlurButton 
  variant="glass" 
  icon={<Ionicons name="settings" size={20} />}
  iconPosition="left"
>
  Ayarlar
</BlurButton>
```

### Action Buttons
```tsx
<BlurButton variant="success" size="small">
  Onayla
</BlurButton>

<BlurButton variant="danger" size="small">
  Sil
</BlurButton>
```

### KarÄ±ÅŸÄ±k Ã–rnekler
```tsx
{/* Orman temalÄ± kÃ¼Ã§Ã¼k pill button */}
<BlurButton 
  variant="forest" 
  size="small" 
  radius="full"
  icon={<Ionicons name="leaf" size={16} color="white" />}
>
  Orman
</BlurButton>

{/* Nane temalÄ± bÃ¼yÃ¼k kÃ¶ÅŸesiz button */}
<BlurButton 
  variant="mint" 
  size="large" 
  radius="none"
  icon={<Ionicons name="flash" size={20} color="white" />}
  iconPosition="right"
>
  Nane
</BlurButton>

{/* ZÃ¼mrÃ¼t temalÄ± bÃ¼yÃ¼k radius button */}
<BlurButton 
  variant="emerald" 
  radius="large"
  icon={<Ionicons name="diamond" size={18} color="white" />}
>
  ZÃ¼mrÃ¼t
</BlurButton>
```

## ğŸš€ Performance

### Optimizasyonlar
- useCallback ile stable references
- Conditional rendering
- Platform-specific implementations
- Memory efficient blur effects

### Best Practices
- Variant seÃ§imi kullanÄ±m amacÄ±na gÃ¶re
- Icon boyutlarÄ± button size'a uygun
- Loading state'lerde user feedback
- Accessibility considerations

Bu showroom Geliom'un component library'sinin temelini oluÅŸturmaktadÄ±r. ğŸŒ¿ğŸ¨
</file>

<file path="docs/cron-job-setup.md">
# Supabase Cron Job Kurulumu

## Process Pending Notifications Cron Job

`process-pending-notifications` Edge Function'Ä±nÄ± her dakika Ã§alÄ±ÅŸtÄ±rmak iÃ§in Supabase cron job kurulumu:

### 1. Supabase Dashboard'dan Kurulum

1. Supabase Dashboard â†’ Database â†’ Cron Jobs
2. "New Cron Job" butonuna tÄ±kla
3. AÅŸaÄŸÄ±daki ayarlarÄ± yap:

**Job Name:** `process-pending-notifications`

**Schedule:** `* * * * *` (Her dakika)

**Command:**
```sql
SELECT net.http_post(
  url := 'https://jtqmntczxkdmftoqspdx.supabase.co/functions/v1/process-pending-notifications',
  headers := jsonb_build_object(
    'Content-Type', 'application/json',
    'Authorization', 'Bearer YOUR_SERVICE_ROLE_KEY'
  ),
  body := '{}'::jsonb
);
```

**NOT:** 
- `YOUR_PROJECT_REF` â†’ Supabase proje referansÄ±nÄ±z
- `YOUR_SERVICE_ROLE_KEY` â†’ Supabase Service Role Key (Settings â†’ API)

### 2. Alternatif: pg_cron Extension KullanÄ±mÄ±

EÄŸer Supabase Dashboard'da cron job Ã¶zelliÄŸi yoksa, `pg_cron` extension'Ä±nÄ± kullanabilirsiniz:

```sql
-- pg_cron extension'Ä±nÄ± etkinleÅŸtir
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Cron job oluÅŸtur
SELECT cron.schedule(
  'process-pending-notifications',
  '* * * * *', -- Her dakika
  $$
  SELECT net.http_post(
    url := 'https://YOUR_PROJECT_REF.supabase.co/functions/v1/process-pending-notifications',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer YOUR_SERVICE_ROLE_KEY'
    ),
    body := '{}'::jsonb
  );
  $$
);
```

### 3. Cron Job KontrolÃ¼

Cron job'un Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± kontrol etmek iÃ§in:

```sql
-- Aktif cron job'larÄ± listele
SELECT * FROM cron.job;

-- Cron job geÃ§miÅŸini gÃ¶rÃ¼ntÃ¼le
SELECT * FROM cron.job_run_details 
WHERE jobid = (SELECT jobid FROM cron.job WHERE jobname = 'process-pending-notifications')
ORDER BY start_time DESC 
LIMIT 10;
```

### 4. Cron Job'u Durdurma

```sql
-- Cron job'u durdur
SELECT cron.unschedule('process-pending-notifications');
```

### 5. Test

Cron job'un Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± test etmek iÃ§in:

1. Bir kullanÄ±cÄ± status'unu deÄŸiÅŸtir
2. `pending_notifications` tablosunda kayÄ±t oluÅŸtuÄŸunu kontrol et
3. 1 dakika sonra kaydÄ±n silindiÄŸini ve bildirimin gÃ¶nderildiÄŸini kontrol et

### 6. Edge Function URL

Edge Function URL'ini bulmak iÃ§in:
- Supabase Dashboard â†’ Edge Functions â†’ `process-pending-notifications`
- URL: `https://YOUR_PROJECT_REF.supabase.co/functions/v1/process-pending-notifications`
</file>

<file path="docs/database-function-update.sql">
-- GÃ¼ncellenmiÅŸ Database Function
-- Bu function, auth.users tablosuna yeni kullanÄ±cÄ± eklendiÄŸinde otomatik Ã§alÄ±ÅŸÄ±r
-- custom_user_id, email ve diÄŸer profil bilgilerini otomatik oluÅŸturur

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  random_id TEXT;
  chars TEXT := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  i INTEGER;
  char_index INTEGER;
BEGIN
  -- Rastgele ve eÅŸsiz bir custom_user_id oluÅŸtur (tam 8 karakter)
  -- Sadece Ä°ngilizce harf (A-Z) ve sayÄ± (0-9) kullanÄ±lÄ±r
  LOOP
    -- 8 karakterlik random string oluÅŸtur
    random_id := '';
    FOR i IN 1..8 LOOP
      -- Random bir index seÃ§ (0-35 arasÄ±: 26 harf + 10 sayÄ±)
      char_index := floor(random() * 36)::INTEGER;
      -- Index'e gÃ¶re karakteri al (1-based indexing iÃ§in +1)
      random_id := random_id || substr(chars, char_index + 1, 1);
    END LOOP;
    
    -- Bu ID'nin baÅŸka bir kullanÄ±cÄ±da olmadÄ±ÄŸÄ±ndan emin ol
    EXIT WHEN NOT EXISTS (SELECT 1 FROM public.users WHERE custom_user_id = random_id);
  END LOOP;

  -- `public.users` tablosuna yeni kullanÄ±cÄ±yÄ± ekle
  INSERT INTO public.users (
    id,
    custom_user_id,
    email,
    display_name,
    photo_url,
    show_mood
  )
  VALUES (
    new.id,
    random_id,
    new.email, -- auth.users'dan email al
    COALESCE(
      new.raw_user_meta_data->>'full_name',
      new.raw_user_meta_data->>'name',
      split_part(new.email, '@', 1) -- Email'den kullanÄ±cÄ± adÄ± Ã§Ä±kar
    ),
    COALESCE(
      new.raw_user_meta_data->>'avatar_url',
      new.raw_user_meta_data->>'picture'
    ),
    false -- VarsayÄ±lan olarak mood gÃ¶sterimi kapalÄ±
  );

  -- `public.subscriptions` tablosuna varsayÄ±lan 'free' aboneliÄŸi ekle
  INSERT INTO public.subscriptions (user_id, status)
  VALUES (new.id, 'free');

  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger'Ä± oluÅŸtur (eÄŸer yoksa)
-- NOT: Trigger zaten varsa bu komut hataya sebep olmaz
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();
</file>

<file path="docs/database-migration-create-join-request-rpc.sql">
-- Function to handle group join requests securely and atomically
create or replace function create_join_request(
  p_group_id uuid,
  p_requester_id uuid,
  p_invite_code text
) returns jsonb
language plpgsql
security definer -- Runs with privileges of the creator (to access tables if RLS blocks, but we'll rely on internal logic)
as $$
declare
  v_group_id uuid;
  v_existing_member_id uuid;
  v_existing_request_id uuid;
  v_new_request_id uuid;
  v_request_status text;
begin
  -- 1. Validate Group and Invite Code
  select id into v_group_id
  from groups
  where id = p_group_id and invite_code = p_invite_code;

  if v_group_id is null then
    return jsonb_build_object('success', false, 'error', 'GeÃ§ersiz davet kodu veya grup bulunamadÄ±.');
  end if;

  -- 2. Check if user is already a member
  select user_id into v_existing_member_id
  from group_members
  where group_id = p_group_id and user_id = p_requester_id;

  if v_existing_member_id is not null then
    return jsonb_build_object('success', false, 'error', 'Zaten bu grubun Ã¼yesisiniz.');
  end if;

  -- 3. Check for existing PENDING request
  select id into v_existing_request_id
  from group_join_requests
  where group_id = p_group_id 
    and requester_id = p_requester_id 
    and status = 'pending';

  if v_existing_request_id is not null then
    return jsonb_build_object('success', false, 'error', 'Bu grup iÃ§in zaten bekleyen bir isteÄŸiniz var.');
  end if;

  -- 4. Clean up old APPROVED or REJECTED requests (if user is not a member anymore)
  -- This handles cases where a user was removed or rejected previously and wants to try again
  delete from group_join_requests
  where group_id = p_group_id 
    and requester_id = p_requester_id 
    and status in ('approved', 'rejected');

  -- 5. Create new request
  insert into group_join_requests (group_id, requester_id, status)
  values (p_group_id, p_requester_id, 'pending')
  returning id, status into v_new_request_id, v_request_status;

  return jsonb_build_object(
    'success', true, 
    'data', jsonb_build_object(
      'id', v_new_request_id,
      'group_id', p_group_id,
      'requester_id', p_requester_id,
      'status', v_request_status
    )
  );

exception when others then
  return jsonb_build_object('success', false, 'error', SQLERRM);
end;
$$;
</file>

<file path="docs/database-migration-custom-status-mood-group-based.sql">
-- Database Migration: Custom Status ve Mood Grup BazlÄ± YapÄ±sÄ±
-- Bu migration, custom status ve mood'larÄ± grup bazlÄ± hale getirir
-- Default status/mood'lar tÃ¼m gruplar iÃ§in geÃ§erli kalÄ±r (group_id = NULL)
-- Custom status/mood'lar sadece oluÅŸturulduÄŸu grupta gÃ¶rÃ¼nÃ¼r (group_id = <grup_id>)

-- ============================================
-- 1. statuses Tablosu GÃ¼ncellemesi
-- ============================================

-- group_id kolonu ekle
ALTER TABLE public.statuses 
ADD COLUMN IF NOT EXISTS group_id UUID NULL;

-- Foreign key constraint ekle (Ã¶nce varsa sil, sonra ekle)
ALTER TABLE public.statuses
DROP CONSTRAINT IF EXISTS statuses_group_id_fkey;

ALTER TABLE public.statuses
ADD CONSTRAINT statuses_group_id_fkey 
FOREIGN KEY (group_id) REFERENCES public.groups(id) ON DELETE CASCADE;

-- Index ekle (performans iÃ§in)
CREATE INDEX IF NOT EXISTS idx_statuses_group_id 
ON public.statuses(group_id);

-- Mevcut custom status'leri gÃ¼ncelle
-- Custom status'ler (is_custom = true) iÃ§in owner'Ä±n ilk grubunu bul ve ona ata
-- EÄŸer owner'Ä±n grubu yoksa group_id = NULL kalÄ±r (manuel dÃ¼zeltme gerekir)
UPDATE public.statuses s
SET group_id = (
  SELECT gm.group_id 
  FROM public.group_members gm
  WHERE gm.user_id = s.owner_id
  ORDER BY gm.joined_at ASC
  LIMIT 1
)
WHERE s.is_custom = true 
  AND s.group_id IS NULL
  AND s.owner_id IS NOT NULL
  AND EXISTS (
    SELECT 1 
    FROM public.group_members gm 
    WHERE gm.user_id = s.owner_id
  );

-- Default status'ler iÃ§in group_id = NULL olduÄŸundan emin ol
UPDATE public.statuses
SET group_id = NULL
WHERE is_custom = false;

-- ============================================
-- 2. moods Tablosu GÃ¼ncellemesi
-- ============================================

-- group_id kolonu ekle
ALTER TABLE public.moods 
ADD COLUMN IF NOT EXISTS group_id UUID NULL;

-- Foreign key constraint ekle (Ã¶nce varsa sil, sonra ekle)
ALTER TABLE public.moods
DROP CONSTRAINT IF EXISTS moods_group_id_fkey;

ALTER TABLE public.moods
ADD CONSTRAINT moods_group_id_fkey 
FOREIGN KEY (group_id) REFERENCES public.groups(id) ON DELETE CASCADE;

-- Index ekle (performans iÃ§in)
CREATE INDEX IF NOT EXISTS idx_moods_group_id 
ON public.moods(group_id);

-- Not: moods tablosunda owner_id veya is_custom alanÄ± yok
-- Bu yÃ¼zden mevcut mood'larÄ± default olarak kabul ediyoruz (group_id = NULL)
-- Custom mood'lar yeni eklendiÄŸinde group_id ile eklenecek

-- ============================================
-- 3. Kontrol SorgularÄ±
-- ============================================

-- Custom status'lerin group_id'si var mÄ± kontrol et
-- SELECT id, text, is_custom, owner_id, group_id 
-- FROM public.statuses 
-- WHERE is_custom = true 
-- ORDER BY group_id NULLS LAST;

-- Default status'lerin group_id'si NULL mu kontrol et
-- SELECT id, text, is_custom, group_id 
-- FROM public.statuses 
-- WHERE is_custom = false 
-- AND group_id IS NOT NULL;
</file>

<file path="docs/database-migration-group-based-status-mood.sql">
-- Database Migration: Group-Based Status & Mood System
-- Bu migration, user_statuses ve moods sistemini grup bazlÄ± hale getirir

-- ============================================
-- 1. user_statuses Tablosu GÃ¼ncellemesi
-- ============================================

-- Ã–nce mevcut primary key constraint'i kaldÄ±r
ALTER TABLE public.user_statuses DROP CONSTRAINT IF EXISTS user_statuses_pkey;

-- group_id kolonu ekle (NULL olabilir - global status iÃ§in)
ALTER TABLE public.user_statuses 
ADD COLUMN IF NOT EXISTS group_id UUID NULL;

-- Foreign key constraint ekle
ALTER TABLE public.user_statuses
ADD CONSTRAINT user_statuses_group_id_fkey 
FOREIGN KEY (group_id) REFERENCES public.groups(id) ON DELETE CASCADE;

-- Mevcut verileri group_id = NULL ile gÃ¼ncelle (global status olarak)
UPDATE public.user_statuses 
SET group_id = NULL 
WHERE group_id IS NULL;

-- Yeni composite primary key oluÅŸtur (user_id, group_id)
-- NOT: PostgreSQL'de NULL deÄŸerler unique constraint'te farklÄ± davranÄ±r
-- Bu yÃ¼zden partial unique index kullanacaÄŸÄ±z
ALTER TABLE public.user_statuses
ADD CONSTRAINT user_statuses_pkey PRIMARY KEY (user_id, group_id);

-- NULL group_id iÃ§in unique constraint (bir kullanÄ±cÄ±nÄ±n tek global status'u olabilir)
CREATE UNIQUE INDEX IF NOT EXISTS user_statuses_user_id_null_group_unique 
ON public.user_statuses(user_id) 
WHERE group_id IS NULL;

-- Performance iÃ§in index'ler
CREATE INDEX IF NOT EXISTS idx_user_statuses_group_id 
ON public.user_statuses(group_id);

CREATE INDEX IF NOT EXISTS idx_user_statuses_user_id_group_id 
ON public.user_statuses(user_id, group_id);

-- ============================================
-- 2. user_group_moods Tablosu OluÅŸtur
-- ============================================

CREATE TABLE IF NOT EXISTS public.user_group_moods (
  user_id UUID NOT NULL,
  group_id UUID NULL,
  mood_id INTEGER NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  CONSTRAINT user_group_moods_pkey PRIMARY KEY (user_id, group_id),
  CONSTRAINT user_group_moods_user_id_fkey 
    FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE,
  CONSTRAINT user_group_moods_group_id_fkey 
    FOREIGN KEY (group_id) REFERENCES public.groups(id) ON DELETE CASCADE,
  CONSTRAINT user_group_moods_mood_id_fkey 
    FOREIGN KEY (mood_id) REFERENCES public.moods(id) ON DELETE CASCADE
) TABLESPACE pg_default;

-- NULL group_id iÃ§in unique constraint (bir kullanÄ±cÄ±nÄ±n tek global mood'u olabilir)
CREATE UNIQUE INDEX IF NOT EXISTS user_group_moods_user_id_null_group_unique 
ON public.user_group_moods(user_id) 
WHERE group_id IS NULL;

-- Performance iÃ§in index'ler
CREATE INDEX IF NOT EXISTS idx_user_group_moods_group_id 
ON public.user_group_moods(group_id);

CREATE INDEX IF NOT EXISTS idx_user_group_moods_user_id_group_id 
ON public.user_group_moods(user_id, group_id);

CREATE INDEX IF NOT EXISTS idx_user_group_moods_mood_id 
ON public.user_group_moods(mood_id);

-- ============================================
-- 3. Mevcut users.mood_id Verilerini Migrate Et
-- ============================================

-- Mevcut users tablosundaki mood_id deÄŸerlerini user_group_moods'a taÅŸÄ±
-- (sadece mood_id NULL olmayan kayÄ±tlar iÃ§in)
INSERT INTO public.user_group_moods (user_id, group_id, mood_id, updated_at)
SELECT 
  id as user_id,
  NULL as group_id,  -- Global mood olarak
  mood_id,
  updated_at
FROM public.users
WHERE mood_id IS NOT NULL
ON CONFLICT (user_id, group_id) DO NOTHING;

-- ============================================
-- 4. RLS (Row Level Security) Policies
-- ============================================

-- user_statuses iÃ§in RLS policy (eÄŸer RLS aktifse)
-- KullanÄ±cÄ±lar sadece kendi status'larÄ±nÄ± gÃ¶rebilir/gÃ¼ncelleyebilir
-- Veya grup Ã¼yeleri grup status'larÄ±nÄ± gÃ¶rebilir

-- user_group_moods iÃ§in RLS policy (eÄŸer RLS aktifse)
-- KullanÄ±cÄ±lar sadece kendi mood'larÄ±nÄ± gÃ¶rebilir/gÃ¼ncelleyebilir
-- Veya grup Ã¼yeleri grup mood'larÄ±nÄ± gÃ¶rebilir

-- NOT: RLS policy'leri projenin gÃ¼venlik gereksinimlerine gÃ¶re ayrÄ±ca eklenmelidir

-- ============================================
-- 5. Migration TamamlandÄ±
-- ============================================

-- Migration sonrasÄ± kontrol sorgularÄ±:
-- SELECT COUNT(*) FROM public.user_statuses WHERE group_id IS NULL; -- Global status sayÄ±sÄ±
-- SELECT COUNT(*) FROM public.user_group_moods WHERE group_id IS NULL; -- Global mood sayÄ±sÄ±
-- SELECT COUNT(*) FROM public.user_group_moods; -- Toplam mood kaydÄ±
</file>

<file path="docs/database-migration-status-emoji.sql">
-- Database Migration: Status Emoji Kolonu
-- Bu migration, statuses tablosuna emoji kolonu ekler

-- ============================================
-- 1. statuses Tablosu GÃ¼ncellemesi
-- ============================================

-- emoji kolonu ekle
ALTER TABLE public.statuses 
ADD COLUMN IF NOT EXISTS emoji TEXT NULL;

-- ============================================
-- 2. Kontrol SorgularÄ±
-- ============================================

-- Status'lerin emoji'si var mÄ± kontrol et
-- SELECT id, text, emoji, is_custom 
-- FROM public.statuses 
-- ORDER BY is_custom DESC, text;
</file>

<file path="docs/database-migration-status-notifications.sql">
-- Database Migration: Status Bildirim Sistemi
-- Bu migration, status bildirimleri iÃ§in messages kolonu ve pending_notifications tablosunu ekler

-- ============================================
-- 1. statuses Tablosuna Messages Kolonu Ekle
-- ============================================

ALTER TABLE public.statuses 
ADD COLUMN IF NOT EXISTS messages TEXT[] NULL;

-- Ã–rnek mesajlar ekle (default status'ler iÃ§in)
-- Not: Bu mesajlar admin panelinden veya seed script'ten eklenebilir
-- Ã–rnek:
-- UPDATE public.statuses 
-- SET messages = ARRAY['{name} artÄ±k mÃ¼sait!', '{name} ÅŸimdi mÃ¼sait durumda', '{name} mÃ¼sait oldu']
-- WHERE text = 'MÃ¼saitim' AND notifies = true;

-- ============================================
-- 2. pending_notifications Tablosu OluÅŸtur
-- ============================================

CREATE TABLE IF NOT EXISTS public.pending_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sender_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  receiver_ids UUID[] NOT NULL,
  group_id UUID NOT NULL REFERENCES public.groups(id) ON DELETE CASCADE,
  status_id INTEGER NOT NULL REFERENCES public.statuses(id) ON DELETE CASCADE,
  scheduled_at TIMESTAMP WITH TIME ZONE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Bir kullanÄ±cÄ±nÄ±n aynÄ± grup iÃ§in sadece 1 pending bildirimi olabilir
  CONSTRAINT pending_notifications_sender_group_unique UNIQUE (sender_id, group_id)
);

-- Index'ler (performans iÃ§in)
CREATE INDEX IF NOT EXISTS idx_pending_notifications_scheduled_at 
ON public.pending_notifications(scheduled_at);

CREATE INDEX IF NOT EXISTS idx_pending_notifications_sender_id 
ON public.pending_notifications(sender_id);

CREATE INDEX IF NOT EXISTS idx_pending_notifications_group_id 
ON public.pending_notifications(group_id);

-- ============================================
-- 3. updated_at Trigger Fonksiyonu
-- ============================================

CREATE OR REPLACE FUNCTION update_pending_notifications_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger ekle
DROP TRIGGER IF EXISTS trigger_update_pending_notifications_updated_at ON public.pending_notifications;
CREATE TRIGGER trigger_update_pending_notifications_updated_at
  BEFORE UPDATE ON public.pending_notifications
  FOR EACH ROW
  EXECUTE FUNCTION update_pending_notifications_updated_at();
</file>

<file path="docs/database-rate-limiting-migration.sql">
-- Rate Limiting Tablosu
-- Bildirim spam'ini Ã¶nlemek iÃ§in kullanÄ±lÄ±r

CREATE TABLE IF NOT EXISTS public.notification_rate_limits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sender_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  receiver_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  group_id UUID REFERENCES groups(id) ON DELETE CASCADE,
  notification_type TEXT NOT NULL CHECK (notification_type IN (
    'join_request',
    'join_request_status',
    'direct_invite',
    'status_update',
    'mood_update',
    'event_reminder'
  )),
  last_sent_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(sender_id, receiver_id, group_id, notification_type)
);

-- Index'ler (performans iÃ§in)
CREATE INDEX IF NOT EXISTS idx_rate_limits_sender_receiver 
  ON notification_rate_limits(sender_id, receiver_id);
CREATE INDEX IF NOT EXISTS idx_rate_limits_group 
  ON notification_rate_limits(group_id);
CREATE INDEX IF NOT EXISTS idx_rate_limits_type 
  ON notification_rate_limits(notification_type);
CREATE INDEX IF NOT EXISTS idx_rate_limits_last_sent 
  ON notification_rate_limits(last_sent_at);

-- Eski kayÄ±tlarÄ± temizlemek iÃ§in function (24 saatten eski)
CREATE OR REPLACE FUNCTION cleanup_old_rate_limits()
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  DELETE FROM notification_rate_limits
  WHERE last_sent_at < NOW() - INTERVAL '24 hours';
END;
$$;

-- Rate limit kontrolÃ¼ iÃ§in helper function
CREATE OR REPLACE FUNCTION check_rate_limit(
  p_sender_id UUID,
  p_receiver_id UUID,
  p_group_id UUID,
  p_notification_type TEXT,
  p_limit_minutes INTEGER
)
RETURNS TABLE(
  can_send BOOLEAN,
  wait_until TIMESTAMP WITH TIME ZONE
)
LANGUAGE plpgsql
AS $$
DECLARE
  v_last_sent_at TIMESTAMP WITH TIME ZONE;
  v_wait_until TIMESTAMP WITH TIME ZONE;
  v_can_send BOOLEAN;
BEGIN
  -- Son gÃ¶nderim zamanÄ±nÄ± al
  SELECT nrl.last_sent_at INTO v_last_sent_at
  FROM notification_rate_limits nrl
  WHERE nrl.sender_id = p_sender_id
    AND nrl.receiver_id = p_receiver_id
    AND (p_group_id IS NULL OR nrl.group_id = p_group_id)
    AND nrl.notification_type = p_notification_type;

  -- EÄŸer kayÄ±t yoksa, gÃ¶nderebilir
  IF v_last_sent_at IS NULL THEN
    v_can_send := TRUE;
    v_wait_until := NOW();
  ELSE
    -- Bekleme sÃ¼resini hesapla
    v_wait_until := v_last_sent_at + (p_limit_minutes || ' minutes')::INTERVAL;

    -- Åu anki zaman beklenen zamandan sonra mÄ±?
    IF NOW() >= v_wait_until THEN
      v_can_send := TRUE;
    ELSE
      v_can_send := FALSE;
    END IF;
  END IF;

  -- EÄŸer gÃ¶nderebiliyorsa, kaydÄ± gÃ¼ncelle/ekle
  IF v_can_send THEN
    INSERT INTO notification_rate_limits (
      sender_id, receiver_id, group_id, notification_type, last_sent_at
    )
    VALUES (
      p_sender_id, p_receiver_id, p_group_id, p_notification_type, NOW()
    )
    ON CONFLICT (sender_id, receiver_id, group_id, notification_type)
    DO UPDATE SET last_sent_at = NOW();
  END IF;

  -- Sonucu dÃ¶ndÃ¼r
  RETURN QUERY SELECT v_can_send, v_wait_until;
END;
$$;

-- RLS (Row Level Security) - Åimdilik kapalÄ±, proje bitiminde aÃ§Ä±lacak
-- ALTER TABLE notification_rate_limits ENABLE ROW LEVEL SECURITY;
</file>

<file path="docs/database-realtime-fix.sql">
-- ============================================
-- Realtime Fix: REPLICA IDENTITY FULL
-- ============================================
-- Bu migration, composite primary key'li tablolarda
-- UPDATE ve DELETE iÅŸlemlerinin Realtime'da dÃ¼zgÃ¼n Ã§alÄ±ÅŸmasÄ± iÃ§in gereklidir.

-- user_statuses tablosu iÃ§in REPLICA IDENTITY FULL
ALTER TABLE public.user_statuses REPLICA IDENTITY FULL;

-- user_group_moods tablosu iÃ§in REPLICA IDENTITY FULL
ALTER TABLE public.user_group_moods REPLICA IDENTITY FULL;

-- group_members tablosu iÃ§in REPLICA IDENTITY FULL (composite key: group_id, user_id)
ALTER TABLE public.group_members REPLICA IDENTITY FULL;

-- group_join_requests tablosu iÃ§in REPLICA IDENTITY FULL
ALTER TABLE public.group_join_requests REPLICA IDENTITY FULL;

-- groups tablosu iÃ§in REPLICA IDENTITY FULL
ALTER TABLE public.groups REPLICA IDENTITY FULL;

-- Not: users tablosu iÃ§in REPLICA IDENTITY FULL gerekmez
-- KullanÄ±cÄ± profil gÃ¼ncellemeleri (display_name, photo_url) nadiren olur ve kritik deÄŸil
-- Realtime subscription kullanÄ±lmÄ±yor (useUsersRealtime hook'u hiÃ§bir yerde Ã§aÄŸrÄ±lmÄ±yor)

-- ============================================
-- Realtime Publication: TablolarÄ± Ekle
-- ============================================
-- EÄŸer tablolar publication'da yoksa ekle

-- user_statuses
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables 
    WHERE pubname = 'supabase_realtime' 
      AND tablename = 'user_statuses'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.user_statuses;
  END IF;
END $$;

-- user_group_moods
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables 
    WHERE pubname = 'supabase_realtime' 
      AND tablename = 'user_group_moods'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.user_group_moods;
  END IF;
END $$;

-- group_members
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables 
    WHERE pubname = 'supabase_realtime' 
      AND tablename = 'group_members'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.group_members;
  END IF;
END $$;

-- group_join_requests
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables 
    WHERE pubname = 'supabase_realtime' 
      AND tablename = 'group_join_requests'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.group_join_requests;
  END IF;
END $$;

-- groups
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables 
    WHERE pubname = 'supabase_realtime' 
      AND tablename = 'groups'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.groups;
  END IF;
END $$;

-- Not: users tablosu realtime'a eklenmiyor
-- KullanÄ±cÄ± profil gÃ¼ncellemeleri nadiren olur ve kritik deÄŸil
-- useUsersRealtime hook'u hiÃ§bir yerde kullanÄ±lmÄ±yor

-- ============================================
-- Kontrol: Realtime Publication Durumu
-- ============================================
-- Bu sorguyu Ã§alÄ±ÅŸtÄ±rarak hangi tablolarÄ±n realtime'da olduÄŸunu gÃ¶rebilirsiniz
SELECT 
  schemaname,
  tablename,
  CASE 
    WHEN tablename IN ('user_statuses', 'user_group_moods', 'group_members', 'group_join_requests', 'groups') 
    THEN 'âœ… Kritik Tablo'
    ELSE 'â„¹ï¸ DiÄŸer'
  END as importance
FROM pg_publication_tables
WHERE pubname = 'supabase_realtime'
ORDER BY importance DESC, tablename;

-- ============================================
-- Kontrol: REPLICA IDENTITY Durumu
-- ============================================
-- Bu sorguyu Ã§alÄ±ÅŸtÄ±rarak hangi tablolarÄ±n REPLICA IDENTITY FULL olduÄŸunu gÃ¶rebilirsiniz
SELECT 
  n.nspname as schemaname,
  c.relname as tablename,
  CASE 
    WHEN c.relreplident = 'f' THEN 'âœ… FULL'
    WHEN c.relreplident = 'd' THEN 'âŒ DEFAULT (Sadece Primary Key)'
    WHEN c.relreplident = 'n' THEN 'âŒ NOTHING'
    WHEN c.relreplident = 'i' THEN 'âŒ INDEX'
    ELSE 'â“ UNKNOWN'
  END as replica_identity
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE n.nspname = 'public'
  AND c.relkind = 'r'
  AND c.relname IN ('user_statuses', 'user_group_moods', 'group_members', 'group_join_requests', 'groups')
ORDER BY c.relname;

-- ============================================
-- Not: RLS (Row Level Security)
-- ============================================
-- Åu an RLS kapalÄ±, bu yÃ¼zden policy kontrolÃ¼ yapmÄ±yoruz.
-- EÄŸer ileride RLS aÃ§arsanÄ±z, Realtime'Ä±n Ã§alÄ±ÅŸmasÄ± iÃ§in
-- authenticated kullanÄ±cÄ±larÄ±n SELECT izni olmalÄ±.
</file>

<file path="docs/edge-function-secrets-setup.md">
# Supabase Edge Function Secrets Kurulumu

## OneSignal REST API Key Ekleme

Edge Function'larÄ±n Ã§alÄ±ÅŸmasÄ± iÃ§in OneSignal REST API Key'i Supabase Secrets'a eklenmelidir.

### AdÄ±mlar

1. **OneSignal Dashboard'dan REST API Key'i al:**
   - OneSignal Dashboard â†’ Settings â†’ Keys & IDs
   - **REST API Key**'i kopyala

2. **Supabase Dashboard'a git:**
   - Supabase Dashboard â†’ Edge Functions â†’ Settings â†’ Secrets

3. **Secret ekle:**
   - **Name:** `ONESIGNAL_REST_API_KEY`
   - **Value:** OneSignal REST API Key (kopyaladÄ±ÄŸÄ±n deÄŸer)
   - **Save**

4. **DiÄŸer gerekli secrets:**
   - `ONESIGNAL_APP_ID` - OneSignal App ID (zaten var olabilir)
   - `SUPABASE_URL` - Otomatik eklenir
   - `SUPABASE_SERVICE_ROLE_KEY` - Otomatik eklenir

### Kontrol

Edge Function log'larÄ±nda ÅŸu hata gÃ¶rÃ¼nmemeli:
```
âŒ ONESIGNAL_REST_API_KEY environment variable eksik!
```

EÄŸer gÃ¶rÃ¼nÃ¼yorsa, secret'Ä± eklediÄŸinden emin ol.

### Test

Edge Function'Ä± test et:
- Supabase Dashboard â†’ Edge Functions â†’ `send-notification` â†’ Test
- Body'ye test payload'Ä± ekle
- Invoke et
- Log'larÄ± kontrol et

## SQL Fonksiyonu GÃ¼ncelleme

`check_rate_limit` fonksiyonunu gÃ¼ncellemek iÃ§in:

1. Supabase Dashboard â†’ SQL Editor
2. `docs/database-rate-limiting-migration.sql` dosyasÄ±ndaki `check_rate_limit` fonksiyonunu Ã§alÄ±ÅŸtÄ±r
3. Fonksiyon gÃ¼ncellenecek

### DeÄŸiÅŸiklikler

- `RETURNS TABLE`'dan `last_sent_at` kaldÄ±rÄ±ldÄ± (ambiguous hatasÄ± iÃ§in)
- Sadece `can_send` ve `wait_until` dÃ¶ndÃ¼rÃ¼yor
- SELECT'te tablo alias kullanÄ±lÄ±yor (`nrl.last_sent_at`)
</file>

<file path="docs/expo-notifications-kullanim.md">
# expo-notifications KullanÄ±mÄ± - Geliom Projesi

## ğŸ“± expo-notifications Ne Ä°ÅŸe Yarar?

`expo-notifications` paketi, **local notifications** (cihazda zamanlanmÄ±ÅŸ bildirimler) gÃ¶ndermek iÃ§in kullanÄ±lÄ±r.

## ğŸ¯ Projede KullanÄ±m AlanlarÄ±

### 1. ZamanlanmÄ±ÅŸ Etkinlikler (Faz 4 - Premium Ã–zellik)

**KullanÄ±m Senaryosu:**
- Premium kullanÄ±cÄ± bir grup iÃ§in etkinlik oluÅŸturur (Ã¶rn: "Cumartesi KahvaltÄ±sÄ±")
- Etkinlik tarihi: 2025-01-25 10:00
- Bildirim zamanÄ±: 2025-01-25 09:00 (1 saat Ã¶nce)

**NasÄ±l Ã‡alÄ±ÅŸÄ±r:**
1. KullanÄ±cÄ± etkinlik oluÅŸturduÄŸunda `scheduled_events` tablosuna kaydedilir
2. `expo-notifications` ile cihazda **local notification** zamanlanÄ±r
3. Bildirim zamanÄ± geldiÄŸinde cihazda bildirim gÃ¶sterilir
4. KullanÄ±cÄ± bildirime tÄ±klayÄ±nca uygulama aÃ§Ä±lÄ±r ve etkinlik detayÄ±na gider

**Ã–rnek KullanÄ±m:**
```typescript
import * as Notifications from 'expo-notifications';

// Etkinlik oluÅŸturulduÄŸunda
const scheduleNotification = async (event: ScheduledEvent) => {
  if (event.notification_time) {
    await Notifications.scheduleNotificationAsync({
      content: {
        title: 'Etkinlik HatÄ±rlatÄ±cÄ±sÄ±',
        body: `${event.title} iÃ§in 1 saat kaldÄ±!`,
        data: { eventId: event.id, groupId: event.group_id },
      },
      trigger: {
        date: new Date(event.notification_time),
      },
    });
  }
};
```

## ğŸ”” OneSignal vs expo-notifications FarkÄ±

### OneSignal (react-native-onesignal)
- **Push Notifications** (sunucudan gÃ¶nderilen)
- Ä°nternet baÄŸlantÄ±sÄ± gerekir
- KullanÄ±cÄ± uygulamayÄ± kapatsa bile Ã§alÄ±ÅŸÄ±r
- **KullanÄ±m:** Grup katÄ±lma istekleri, durum gÃ¼ncellemeleri, direkt mesajlar

### expo-notifications
- **Local Notifications** (cihazda zamanlanan)
- Ä°nternet baÄŸlantÄ±sÄ± gerekmez
- Uygulama kapalÄ± olsa bile Ã§alÄ±ÅŸÄ±r (iOS/Android native Ã¶zellik)
- **KullanÄ±m:** ZamanlanmÄ±ÅŸ etkinlik hatÄ±rlatÄ±cÄ±larÄ±

## ğŸ“‹ KullanÄ±m SenaryolarÄ±

### Senaryo 1: Etkinlik HatÄ±rlatÄ±cÄ±sÄ±
```
KullanÄ±cÄ±: "YarÄ±n 10:00'da kahvaltÄ± var"
Bildirim: "YarÄ±n 09:00'da" â†’ "KahvaltÄ± iÃ§in 1 saat kaldÄ±!"
```

### Senaryo 2: Tekrarlayan HatÄ±rlatÄ±cÄ±lar (Gelecekte)
```
Her hafta Pazar gÃ¼nÃ¼ 18:00'da â†’ "HaftalÄ±k toplantÄ± zamanÄ±!"
```

## âš™ï¸ Teknik Detaylar

### Bildirim Ä°zinleri
- iOS: KullanÄ±cÄ±dan izin istenir
- Android: Otomatik izin verilir (Android 13+ iÃ§in izin gerekir)

### Bildirim Zamanlama
- Maksimum 64 bildirim aynÄ± anda zamanlanabilir
- Bildirimler cihaz yeniden baÅŸlatÄ±ldÄ±ÄŸÄ±nda kaybolur (yeniden zamanlanmalÄ±)

### Bildirim TÄ±klama
- Bildirime tÄ±klandÄ±ÄŸÄ±nda uygulama aÃ§Ä±lÄ±r
- `data` objesi ile etkinlik ID'si gÃ¶nderilir
- Uygulama aÃ§Ä±ldÄ±ÄŸÄ±nda ilgili ekrana yÃ¶nlendirilir

## ğŸš€ Gelecek KullanÄ±mlar

1. **Etkinlik HatÄ±rlatÄ±cÄ±larÄ±** (Faz 4)
2. **GÃ¼nlÃ¼k HatÄ±rlatÄ±cÄ±lar** (Gelecekte)
3. **Tekrarlayan Bildirimler** (Gelecekte)

## ğŸ“ Notlar

- `expo-notifications` sadece **local notifications** iÃ§in
- **Push notifications** iÃ§in `OneSignal` kullanÄ±lacak
- Ä°kisi birlikte kullanÄ±labilir (farklÄ± amaÃ§lar iÃ§in)
</file>

<file path="docs/faz2-todo.md">
# Faz 2: Grup KatÄ±lma Sistemi ve Bildirimler - YapÄ±lacaklar Listesi

## ğŸ“‹ Genel BakÄ±ÅŸ
Grup katÄ±lma onay sistemi ve bildirim altyapÄ±sÄ±nÄ± kurmak.

---

## ğŸ—„ï¸ 1. VeritabanÄ± Ä°ÅŸlemleri

### 1.1. `group_join_requests` Tablosu OluÅŸturma
- âœ… Supabase SQL Editor'de yeni tablo oluÅŸtur:
  ```sql
  CREATE TABLE public.group_join_requests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    group_id UUID NOT NULL REFERENCES groups(id) ON DELETE CASCADE,
    requester_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(group_id, requester_id) -- AynÄ± kullanÄ±cÄ± aynÄ± gruba tekrar istek gÃ¶nderemez
  );
  ```
- [ ] RLS (Row Level Security) politikalarÄ± ekle:
  - [ ] Grup kurucusu tÃ¼m istekleri gÃ¶rebilir
  - [ ] Ä°stek sahibi kendi isteklerini gÃ¶rebilir
  - [ ] Ä°stek sahibi yeni istek oluÅŸturabilir
  - [ ] Grup kurucusu istekleri onaylayÄ±p reddedebilir
- [ ] Index'ler ekle (performans iÃ§in):
  - [ ] `group_id` Ã¼zerinde index
  - [ ] `requester_id` Ã¼zerinde index
  - [ ] `status` Ã¼zerinde index

### 1.2. TypeScript Tipleri GÃ¼ncelleme
- âœ… `types/database.ts` dosyasÄ±na `GroupJoinRequest` interface'i ekle
- âœ… `CreateGroupJoinRequest` ve `UpdateGroupJoinRequest` tiplerini ekle
- âœ… `GroupJoinRequestWithDetails` interface'i eklendi

---

## ğŸ” 2. KullanÄ±cÄ± Arama ve Davet Sistemi

### 2.1. API Hook'larÄ±
- âœ… `api/users.ts` dosyasÄ±na `useUserByCustomId` hook'u ekle (zaten mevcut)
- âœ… Custom user ID ile kullanÄ±cÄ± arama fonksiyonu yaz (zaten mevcut)

### 2.2. UI Component'leri
- âœ… **Ekran: KullanÄ±cÄ± Arama EkranÄ±** (`app/(drawer)/(group)/search-user.tsx`)
  - âœ… Arama input'u (custom_user_id iÃ§in)
  - âœ… Arama butonu
  - âœ… Bulunan kullanÄ±cÄ± kartÄ± (display_name, custom_user_id, email)
  - âœ… Bulunan kullanÄ±cÄ±ya davet gÃ¶nderme butonu
  - âœ… SeÃ§ili grup bilgisi gÃ¶sterimi
  - âœ… Grup seÃ§ilmedi uyarÄ±sÄ±
  - âœ… Hata mesajlarÄ± ve validasyon
- âœ… DashboardView'e "KullanÄ±cÄ± Ara ve Davet Et" butonu eklendi (sadece owner iÃ§in)

---

## ğŸ“ 3. Grup KatÄ±lma Ä°steÄŸi GÃ¶nderme

### 3.1. API Hook'larÄ±
- âœ… `api/groups.ts` dosyasÄ±na ÅŸu hook'larÄ± ekle:
  - âœ… `useCreateJoinRequest` - KatÄ±lma isteÄŸi gÃ¶nderme
  - âœ… `useGroupJoinRequests` - Grup iÃ§in bekleyen istekleri getirme
  - âœ… `useMyJoinRequests` - KullanÄ±cÄ±nÄ±n gÃ¶nderdiÄŸi istekleri getirme

### 3.2. UI Component'leri
- âœ… **Ekran: Grup KatÄ±lma EkranÄ±** (`app/(drawer)/(group)/join-group.tsx`)
  - âœ… Davet kodu input'u
  - âœ… "KatÄ±lma Ä°steÄŸi GÃ¶nder" butonu
  - âœ… Grup bilgisi gÃ¶sterimi (kod geÃ§erliyse)
  - âœ… Hata mesajlarÄ± ve validasyon
- âœ… Ana ekranda "Gruba KatÄ±l" butonu eklendi (EmptyStateView'de)

---

## âœ… 4. Grup KatÄ±lma Ä°stekleri YÃ¶netimi (Grup Kurucusu)

### 4.1. API Hook'larÄ±
- âœ… `api/groups.ts` dosyasÄ±na ÅŸu hook'larÄ± ekle:
  - âœ… `useApproveJoinRequest` - Ä°steÄŸi onaylama mutation
  - âœ… `useRejectJoinRequest` - Ä°steÄŸi reddetme mutation
  - âœ… `useGroupJoinRequests` - Grup iÃ§in tÃ¼m istekleri getirme (owner iÃ§in)

### 4.2. UI Component'leri
- âœ… **Ekran: Grup KatÄ±lma Ä°stekleri** (`app/(drawer)/(group)/join-requests.tsx`)
  - âœ… Bekleyen istekler listesi (pending)
  - âœ… Her istek iÃ§in:
    - âœ… KullanÄ±cÄ± bilgileri (display_name, custom_user_id, photo_url)
    - âœ… Ä°stek zamanÄ± (created_at)
    - âœ… "Onayla" butonu
    - âœ… "Reddet" butonu
  - âœ… Empty state (istek yoksa)
  - âœ… Pull-to-refresh (yenileme)
  - âœ… Owner kontrolÃ¼ (sadece owner gÃ¶rebilir)
  - âœ… Grup seÃ§ilmedi durumu
- âœ… DashboardView'e "KatÄ±lma Ä°stekleri" butonu eklendi (sadece owner iÃ§in, badge ile sayÄ± gÃ¶sterimi)
- âœ… DashboardView'e "BaÅŸka Gruba KatÄ±l" butonu eklendi (her zaman gÃ¶rÃ¼nÃ¼r)

### 4.3. Backend Logic
- âœ… Ä°stek onaylandÄ±ÄŸÄ±nda:
  - âœ… `group_members` tablosuna yeni kayÄ±t ekle (useApproveJoinRequest iÃ§inde)
  - âœ… Ä°stek durumunu `approved` yap (useApproveJoinRequest iÃ§inde)
  - [ ] KullanÄ±cÄ±ya bildirim gÃ¶nder (OneSignal) - Faz 2'nin sonunda
- âœ… Ä°stek reddedildiÄŸinde:
  - âœ… Ä°stek durumunu `rejected` yap (useRejectJoinRequest iÃ§inde)
  - [ ] KullanÄ±cÄ±ya bildirim gÃ¶nder (OneSignal) - Faz 2'nin sonunda

---

## ğŸ”” 5. Bildirim Sistemi (OneSignal)

### 5.1. OneSignal SDK Entegrasyonu
- âœ… `package.json`'a `react-native-onesignal` paketini ekle
- âœ… OneSignal'Ä± initialize et (`app/Provider.tsx` ve `services/onesignal.ts`)
- âœ… KullanÄ±cÄ± giriÅŸ yaptÄ±ÄŸÄ±nda `onesignal_player_id`'yi al
- âœ… `users` tablosuna `onesignal_player_id` kolonunu ekle (zaten var)
- âœ… KullanÄ±cÄ± profil gÃ¼ncellemesinde `onesignal_player_id`'yi kaydet
- âœ… OneSignal login/logout entegrasyonu (external ID ile)

### 5.2. Bildirim GÃ¶nderme
- âœ… **Supabase Edge Function: `send-notification`**
  - âœ… OneSignal API key'ini environment variable olarak ekle (dokÃ¼mantasyonda belirtildi)
  - âœ… Grup Ã¼yelerine bildirim gÃ¶nderme fonksiyonu
  - âœ… KullanÄ±cÄ±ya bildirim gÃ¶nderme fonksiyonu
- âœ… **Bildirim GÃ¶nderme Entegrasyonu**
  - âœ… `useCreateJoinRequest` hook'unda grup sahibine bildirim gÃ¶nderme
  - âœ… `useApproveJoinRequest` hook'unda istek yapan kullanÄ±cÄ±ya bildirim gÃ¶nderme
  - âœ… `useRejectJoinRequest` hook'unda istek yapan kullanÄ±cÄ±ya bildirim gÃ¶nderme
- âœ… **Bildirim TÄ±klama Handler**
  - âœ… `NotificationHandler` component'i oluÅŸturuldu
  - âœ… Bildirime tÄ±klandÄ±ÄŸÄ±nda grup seÃ§imi ve navigation
  - âœ… Provider'a entegre edildi

### 5.3. Bildirim Ä°Ã§erikleri
- âœ… KatÄ±lma isteÄŸi geldiÄŸinde: "[Grup AdÄ±] - Yeni KatÄ±lma Ä°steÄŸi" / "[KullanÄ±cÄ± AdÄ±] grubunuza katÄ±lmak istiyor"
- âœ… Ä°stek onaylandÄ±ÄŸÄ±nda: "[Grup AdÄ±] - KatÄ±lma Ä°steÄŸi OnaylandÄ±" / "[Grup AdÄ±] grubuna katÄ±lma isteÄŸiniz onaylandÄ±!"
- âœ… Ä°stek reddedildiÄŸinde: "[Grup AdÄ±] - KatÄ±lma Ä°steÄŸi Reddedildi" / "[Grup AdÄ±] grubuna katÄ±lma isteÄŸiniz reddedildi."
- â³ Direkt davet geldiÄŸinde: "X kullanÄ±cÄ±sÄ± sizi Y grubuna davet etti" (Faz 3'te eklenecek)

---

## ğŸ”„ 6. Realtime GÃ¼ncellemeleri

### 6.1. Supabase Realtime Subscription
- âœ… `api/groups.ts` dosyasÄ±na `useGroupJoinRequestsRealtime` hook'u ekle
- âœ… `api/groups.ts` dosyasÄ±na `useMyJoinRequestsRealtime` hook'u ekle
- âœ… Grup kurucusu iÃ§in isteklerin anlÄ±k gÃ¼ncellenmesi (`join-requests.tsx` ve `DashboardView.tsx`)
- âœ… Ä°stek sahibi iÃ§in durum deÄŸiÅŸikliklerinin anlÄ±k gÃ¼ncellenmesi (hook hazÄ±r, kullanÄ±m iÃ§in ekran gerekli)
- âœ… Export'lar `api/index.ts`'e eklendi

---

## ğŸ¨ 7. UI/UX Ä°yileÅŸtirmeleri

### 7.1. Mevcut Ekranlara Entegrasyon
- [ ] Ana ekrana "Gruba KatÄ±l" butonu ekle
- [ ] Grup detay ekranÄ±na "KatÄ±lma Ä°stekleri" butonu ekle (sadece owner)
- [ ] Grup listesinde bekleyen istek sayÄ±sÄ±nÄ± gÃ¶ster (badge)

### 7.2. Navigation
- [ ] Drawer navigation'a yeni ekranlar ekle:
  - [ ] "Gruba KatÄ±l" ekranÄ±
  - [ ] "KullanÄ±cÄ± Ara" ekranÄ±
  - [ ] "KatÄ±lma Ä°stekleri" ekranÄ± (sadece grup owner'larÄ± iÃ§in)

---

## ğŸ§ª 8. Test ve DoÄŸrulama

### 8.1. Fonksiyonel Testler
- [ ] Davet kodu ile katÄ±lma isteÄŸi gÃ¶nderme
- [ ] Custom user ID ile kullanÄ±cÄ± arama
- [ ] Direkt davet gÃ¶nderme
- [ ] Ä°stek onaylama/reddetme
- [ ] Bildirimlerin doÄŸru gÃ¶nderilmesi
- [ ] Realtime gÃ¼ncellemelerinin Ã§alÄ±ÅŸmasÄ±

### 8.2. Edge Case'ler
- [ ] AynÄ± kullanÄ±cÄ± aynÄ± gruba tekrar istek gÃ¶nderemez
- [ ] Zaten Ã¼ye olan kullanÄ±cÄ± istek gÃ¶nderemez
- [ ] Grup limiti dolduÄŸunda istek gÃ¶nderilemez
- [ ] Silinen grup iÃ§in istekler temizlenir

---

## ğŸ“ 9. DokÃ¼mantasyon

### 9.1. Kod DokÃ¼mantasyonu
- [ ] Yeni API hook'larÄ± iÃ§in JSDoc yorumlarÄ±
- [ ] Yeni component'ler iÃ§in kullanÄ±m Ã¶rnekleri

### 9.2. KullanÄ±cÄ± DokÃ¼mantasyonu
- [ ] Grup katÄ±lma akÄ±ÅŸÄ±nÄ± aÃ§Ä±klayan dokÃ¼man
- [ ] Bildirim ayarlarÄ± dokÃ¼manÄ±

---

## âœ… Tamamlanma Kriterleri

Faz 2 tamamlanmÄ±ÅŸ sayÄ±lÄ±r eÄŸer:
- âœ… KullanÄ±cÄ±lar davet kodu ile grup katÄ±lma isteÄŸi gÃ¶nderebiliyor
- âœ… KullanÄ±cÄ±lar custom user ID ile arama yapÄ±p direkt davet gÃ¶nderebiliyor
- âœ… Grup kurucularÄ± katÄ±lma isteklerini gÃ¶rÃ¼p onaylayÄ±p reddedebiliyor
- âœ… Bildirimler doÄŸru ÅŸekilde gÃ¶nderiliyor (rate limiting ile)
- âœ… Realtime gÃ¼ncellemeler Ã§alÄ±ÅŸÄ±yor
- âœ… TÃ¼m edge case'ler handle ediliyor (tekrar istek gÃ¶nderme, zaten Ã¼ye kontrolÃ¼)

---

## ğŸš€ Ã–ncelik SÄ±rasÄ±

1. **YÃ¼ksek Ã–ncelik:**
   - VeritabanÄ± tablosu oluÅŸturma
   - API hook'larÄ±
   - Temel UI ekranlarÄ±
   - Bildirim sistemi

2. **Orta Ã–ncelik:**
   - Realtime gÃ¼ncellemeler
   - UI iyileÅŸtirmeleri
   - Edge case handling

3. **DÃ¼ÅŸÃ¼k Ã–ncelik:**
   - DokÃ¼mantasyon
   - Test coverage artÄ±rma
</file>

<file path="docs/future-packages.md">
# Gelecekte Gerekli Paketler - Prebuild Ã–ncesi YÃ¼kleme Listesi

## ğŸ“¦ Åimdiden YÃ¼klenmesi Gereken Paketler

### 1. Bildirimler (Faz 2+)
- âœ… `expo-notifications` - Local notifications iÃ§in (zamanlanmÄ±ÅŸ etkinlikler)

### 2. DiÄŸer YararlÄ± Paketler
- âœ… `expo-sharing` - Dosya paylaÅŸÄ±mÄ± iÃ§in (gelecekte gerekebilir)

## ğŸ“ Notlar

- Profil fotoÄŸrafÄ± yÃ¼kleme iÃ§in paketler (expo-image-picker, expo-file-system, expo-media-library) ÅŸimdilik yÃ¼klenmedi
- Ä°htiyaÃ§ duyulduÄŸunda prebuild sonrasÄ± da eklenebilir

## âš ï¸ Firebase Paketleri (Åimdilik EKLEMEYÄ°N)

Firebase Analytics ve Crashlytics iÃ§in native modÃ¼l gerektirir ve Expo managed workflow'da sorun Ã§Ä±karabilir. 
Prebuild sonrasÄ± gerekirse eklenebilir veya EAS Build kullanÄ±labilir.

## âœ… Zaten YÃ¼klÃ¼ Olan Paketler

- âœ… `react-native-onesignal` - Bildirimler iÃ§in
- âœ… `onesignal-expo-plugin` - OneSignal plugin
- âœ… `react-native-adapty` - Abonelik yÃ¶netimi iÃ§in
- âœ… TÃ¼m native modÃ¼ller (reanimated, gesture-handler, screens, vb.)
</file>

<file path="docs/GeliomButton-Documentation.md">
# GeliomButton - Ana Button Sistemi ğŸŒ¿

Geliom uygulamasÄ±nÄ±n ana button sistemi. Forest (Active), Sage (Passive), Pine (Loading) renklerini kullanarak adaÃ§ayÄ± tarzÄ± organik tasarÄ±m sunar.

## ğŸ¨ TasarÄ±m Felsefesi

GeliomButton, doÄŸanÄ±n organik formlarÄ±ndan ilham alÄ±narak tasarlanmÄ±ÅŸtÄ±r. AdaÃ§ayÄ± yapraÄŸÄ±nÄ±n yumuÅŸak, organik ÅŸekli button'larÄ±n radius ve padding sistemine yansÄ±tÄ±lmÄ±ÅŸtÄ±r.

### Renk Sistemi
- **ğŸŒ² Forest (#1B5E20)** - Active State (9. numara)
- **ğŸŒ¾ Sage (#87A96B)** - Passive State (13. numara)  
- **ğŸŒ² Pine (#01796F)** - Loading State (17. numara)

## ğŸ“ AdaÃ§ayÄ± TarzÄ± Boyut Sistemi

### Organik Padding ve Radius
Her boyut, adaÃ§ayÄ± yapraÄŸÄ±nÄ±n doÄŸal formunu taklit eder:

```tsx
small: {
  paddingHorizontal: 14,
  paddingVertical: 8,
  borderRadius: 14,        // KÃ¼Ã§Ã¼k yaprak formu
  fontSize: 14,
  iconSize: 16,
  minHeight: 32,
}

medium: {
  paddingHorizontal: 18,
  paddingVertical: 12,
  borderRadius: 18,        // Orta yaprak formu
  fontSize: 16,
  iconSize: 18,
  minHeight: 42,
}

large: {
  paddingHorizontal: 24,
  paddingVertical: 16,
  borderRadius: 22,        // BÃ¼yÃ¼k yaprak formu
  fontSize: 18,
  iconSize: 20,
  minHeight: 52,
}

xl: {
  paddingHorizontal: 32,
  paddingVertical: 20,
  borderRadius: 26,        // Extra bÃ¼yÃ¼k yaprak formu
  fontSize: 20,
  iconSize: 24,
  minHeight: 62,
}
```

## ğŸ”§ API ReferansÄ±

### Props

```tsx
interface GeliomButtonProps {
  children?: ReactNode;           // Button metni
  state?: GeliomButtonState;      // 'active' | 'passive' | 'loading'
  size?: GeliomButtonSize;        // 'small' | 'medium' | 'large' | 'xl'
  layout?: GeliomButtonLayout;    // Layout tipi
  icon?: keyof typeof Ionicons.glyphMap; // Ionicons icon adÄ±
  onPress?: () => void;           // TÄ±klama fonksiyonu
  disabled?: boolean;             // Disabled durumu
  style?: ViewStyle;              // Ek stil
}
```

### State Tipleri

```tsx
type GeliomButtonState = 'active' | 'passive' | 'loading';
```

- **active**: Ana aksiyonlar iÃ§in (Forest yeÅŸili)
- **passive**: Ä°kincil aksiyonlar iÃ§in (Sage yeÅŸili)
- **loading**: YÃ¼kleme durumu iÃ§in (Pine yeÅŸili)

### Layout Tipleri

```tsx
type GeliomButtonLayout = 
  | 'default'     // Sadece metin
  | 'icon-left'   // Icon solda, metin saÄŸda
  | 'icon-right'  // Metin solda, icon saÄŸda
  | 'icon-only'   // Sadece icon (kare form)
  | 'full-width'  // Tam geniÅŸlik
```

## ğŸ¯ KullanÄ±m Ã–rnekleri

### Temel KullanÄ±m

```tsx
import { GeliomButton } from '@/components/shared';

// Active button
<GeliomButton state="active" onPress={handlePress}>
  Kaydet
</GeliomButton>

// Passive button
<GeliomButton state="passive" onPress={handleCancel}>
  Ä°ptal
</GeliomButton>

// Loading button
<GeliomButton state="loading">
  YÃ¼kleniyor...
</GeliomButton>
```

### Icon'lu KullanÄ±m

```tsx
// Sol icon
<GeliomButton 
  state="active" 
  layout="icon-left" 
  icon="checkmark-circle"
>
  Onayla
</GeliomButton>

// SaÄŸ icon
<GeliomButton 
  state="passive" 
  layout="icon-right" 
  icon="arrow-forward"
>
  Ä°leri
</GeliomButton>

// Sadece icon
<GeliomButton 
  state="active" 
  layout="icon-only" 
  icon="heart"
/>
```

### Boyut VaryasyonlarÄ±

```tsx
// KÃ¼Ã§Ã¼k button
<GeliomButton state="active" size="small">
  KÃ¼Ã§Ã¼k
</GeliomButton>

// BÃ¼yÃ¼k button
<GeliomButton state="active" size="large">
  BÃ¼yÃ¼k
</GeliomButton>

// Extra bÃ¼yÃ¼k button
<GeliomButton state="active" size="xl">
  Extra BÃ¼yÃ¼k
</GeliomButton>
```

### Full Width

```tsx
<GeliomButton 
  state="active" 
  layout="full-width"
  icon="save"
>
  Tam GeniÅŸlik Kaydet
</GeliomButton>
```

### Kombinasyonlar

```tsx
// BÃ¼yÃ¼k, icon'lu, passive button
<GeliomButton 
  state="passive" 
  size="large"
  layout="icon-left" 
  icon="information-circle"
>
  Bilgi Al
</GeliomButton>

// XL boyutunda loading button
<GeliomButton 
  state="loading" 
  size="xl"
  layout="icon-left" 
  icon="refresh"
>
  YÃ¼kleniyor...
</GeliomButton>
```

## ğŸ¨ GÃ¶rsel Ã–zellikler

### Shadow ve Elevation
- **shadowOffset**: `{ width: 0, height: 4 }`
- **shadowOpacity**: `0.25`
- **shadowRadius**: `8`
- **elevation**: `6` (Android)

### Typography
- **fontFamily**: `Comfortaa-SemiBold`
- **textAlign**: `center`
- **color**: Otomatik (state'e gÃ¶re)

### Animasyonlar
- **activeOpacity**: `0.8`
- **Disabled opacity**: `0.6`

## ğŸŒ± DoÄŸa TemalÄ± KullanÄ±m Rehberi

### Duygusal Anlamlar

#### ğŸŒ² Forest (Active)
- **Duygu**: GÃ¼Ã§, kararlÄ±lÄ±k, bÃ¼yÃ¼me
- **KullanÄ±m**: Ana CTA'lar, Ã¶nemli aksiyonlar
- **Ã–rnek**: "Kaydet", "GÃ¶nder", "Onayla"

#### ğŸŒ¾ Sage (Passive)
- **Duygu**: Bilgelik, sakinlik, denge
- **KullanÄ±m**: Ä°kincil aksiyonlar, bilgi butonlarÄ±
- **Ã–rnek**: "Ä°ptal", "Geri", "Bilgi"

#### ğŸŒ² Pine (Loading)
- **Duygu**: DayanÄ±klÄ±lÄ±k, sÃ¼reklilik, bekleme
- **KullanÄ±m**: YÃ¼kleme durumlarÄ±, iÅŸlem sÃ¼reÃ§leri
- **Ã–rnek**: "YÃ¼kleniyor...", "Ä°ÅŸleniyor..."

### Icon SeÃ§imi Rehberi

#### DoÄŸa TemalÄ± Icon'lar
```tsx
// Yaprak ve bitki icon'larÄ±
icon="leaf"          // ğŸƒ Genel doÄŸa
icon="flower"        // ğŸŒ¸ GÃ¼zellik, bÃ¼yÃ¼me
icon="tree"          // ğŸŒ³ GÃ¼Ã§, stabilite

// DoÄŸal elementler
icon="water"         // ğŸ’§ Temizlik, akÄ±ÅŸ
icon="sunny"         // â˜€ï¸ Enerji, pozitiflik
icon="moon"          // ğŸŒ™ Sakinlik, gece modu
```

#### Aksiyon Icon'larÄ±
```tsx
// Pozitif aksiyonlar
icon="checkmark-circle"  // âœ… Onay
icon="heart"            // â¤ï¸ BeÄŸeni
icon="star"             // â­ Favorileme

// Navigasyon
icon="arrow-forward"    // â¡ï¸ Ä°leri
icon="arrow-back"       // â¬…ï¸ Geri
icon="home"             // ğŸ  Ana sayfa
```

## ğŸš€ Performance ve Optimizasyon

### Best Practices
1. **State Management**: Button state'ini component dÄ±ÅŸÄ±nda yÃ¶net
2. **Icon Optimization**: Sadece gerekli icon'larÄ± import et
3. **Callback Optimization**: `useCallback` kullan
4. **Style Memoization**: KarmaÅŸÄ±k stiller iÃ§in `useMemo`

### Accessibility
- **accessibilityRole**: "button" (otomatik)
- **accessibilityState**: disabled durumu otomatik
- **accessibilityLabel**: children text'i otomatik

## ğŸ¯ Geliom App'te KullanÄ±m SenaryolarÄ±

### Ana Sayfa
```tsx
// Grup oluÅŸtur butonu
<GeliomButton 
  state="active" 
  size="large"
  layout="full-width"
  icon="add-circle"
>
  ğŸŒ± Yeni Grup OluÅŸtur
</GeliomButton>
```

### Profil SayfasÄ±
```tsx
// Profil dÃ¼zenle
<GeliomButton 
  state="passive" 
  layout="icon-left"
  icon="create"
>
  âœï¸ Profili DÃ¼zenle
</GeliomButton>
```

### Chat Interface
```tsx
// Mesaj gÃ¶nder
<GeliomButton 
  state="active" 
  size="small"
  layout="icon-only"
  icon="send"
/>
```

Bu button sistemi, Geliom'un doÄŸa temalÄ± kimliÄŸini gÃ¼Ã§lendirirken, kullanÄ±cÄ±ya tutarlÄ± ve anlamlÄ± bir etkileÅŸim deneyimi sunar. ğŸŒ¿âœ¨
</file>

<file path="docs/KULLANICI_YAPILACAKLAR.md">
# KullanÄ±cÄ±nÄ±n YapmasÄ± Gerekenler

## 1. Database Migration SQL'i Ã‡alÄ±ÅŸtÄ±rma

**Ã–NEMLÄ°**: Bu adÄ±mÄ± Supabase Dashboard'da SQL Editor'da Ã§alÄ±ÅŸtÄ±rmanÄ±z gerekiyor.

### AdÄ±mlar:

1. Supabase Dashboard'a giriÅŸ yapÄ±n
2. SQL Editor'Ä± aÃ§Ä±n
3. `docs/database-migration-custom-status-mood-group-based.sql` dosyasÄ±ndaki SQL'i kopyalayÄ±n
4. SQL Editor'a yapÄ±ÅŸtÄ±rÄ±n ve Ã§alÄ±ÅŸtÄ±rÄ±n

### Migration SQL'i Ne YapÄ±yor?

- `statuses` tablosuna `group_id` kolonu ekler
- `moods` tablosuna `group_id` kolonu ekler
- Foreign key constraint'ler ekler
- Index'ler ekler (performans iÃ§in)
- Mevcut custom status'leri owner'Ä±n ilk grubuna atar (varsa)

### Migration SonrasÄ± Kontrol:

Migration baÅŸarÄ±lÄ± olduktan sonra ÅŸu sorgularÄ± Ã§alÄ±ÅŸtÄ±rarak kontrol edebilirsiniz:

```sql
-- Custom status'lerin group_id'si var mÄ± kontrol et
SELECT id, text, is_custom, owner_id, group_id 
FROM public.statuses 
WHERE is_custom = true 
ORDER BY group_id NULLS LAST;

-- Default status'lerin group_id'si NULL mu kontrol et
SELECT id, text, is_custom, group_id 
FROM public.statuses 
WHERE is_custom = false 
AND group_id IS NOT NULL;
```

EÄŸer `group_id = NULL` olan custom status'ler varsa, bunlarÄ± manuel olarak dÃ¼zeltmeniz gerekebilir.

## 2. Test Etme

Migration tamamlandÄ±ktan sonra:

1. **Custom Status Ekleme Testi**:
   - Bir gruba girin
   - Grup yÃ¶netimi sayfasÄ±na gidin
   - "Ã–zel Durum Ekle" butonuna tÄ±klayÄ±n
   - Yeni bir custom status oluÅŸturun
   - Status'un sadece o grupta gÃ¶rÃ¼ndÃ¼ÄŸÃ¼nÃ¼ kontrol edin

2. **Custom Mood Ekleme Testi**:
   - AynÄ± grup yÃ¶netimi sayfasÄ±nda
   - "Ã–zel Mood Ekle" butonuna tÄ±klayÄ±n
   - Yeni bir custom mood oluÅŸturun
   - Mood'un sadece o grupta gÃ¶rÃ¼ndÃ¼ÄŸÃ¼nÃ¼ kontrol edin

3. **FarklÄ± Grup Testi**:
   - BaÅŸka bir gruba geÃ§in
   - Ã–nceki grupta oluÅŸturduÄŸunuz custom status/mood'larÄ±n gÃ¶rÃ¼nmediÄŸini kontrol edin
   - Default status/mood'larÄ±n gÃ¶rÃ¼ndÃ¼ÄŸÃ¼nÃ¼ kontrol edin

## 3. Mevcut Custom Status/Mood'larÄ± DÃ¼zeltme (Opsiyonel)

EÄŸer migration sonrasÄ± `group_id = NULL` olan custom status'ler varsa:

1. Bu status'lerin hangi gruba ait olduÄŸunu belirleyin
2. Manuel olarak gÃ¼ncelleyin:

```sql
-- Ã–rnek: Bir custom status'Ã¼ belirli bir gruba ata
UPDATE public.statuses
SET group_id = 'grupun-uuid-si-buraya'
WHERE id = status-id-si-buraya
AND is_custom = true
AND group_id IS NULL;
```

## Notlar

- Migration gÃ¼venli bir ÅŸekilde tasarlandÄ±, mevcut verileri silmez
- Default status/mood'lar (`is_custom = false`) iÃ§in `group_id = NULL` kalÄ±r (tÃ¼m gruplar iÃ§in geÃ§erli)
- Custom status/mood'lar sadece oluÅŸturulduÄŸu grupta gÃ¶rÃ¼nÃ¼r
- Bildirim sistemi bozulmaz (custom status'ler `notifies: false` olduÄŸu iÃ§in bildirim gÃ¶ndermez)
</file>

<file path="docs/Login-System-usage.md">
# Geliom - Login Sistemi KullanÄ±m KÄ±lavuzu

Geliom uygulamasÄ±nÄ±n doÄŸa temalÄ±, blur efektli login sistemi ve Supabase OAuth entegrasyonu.

## ğŸ¨ TasarÄ±m Ã–zellikleri

### DoÄŸa TemalÄ± GÃ¶rsel TasarÄ±m
- **Gradient Background**: YeÅŸil tonlarda doÄŸal geÃ§iÅŸler
- **Blur Effects**: Modern glassmorphism tasarÄ±mÄ±
- **Decorative Elements**: DoÄŸal hissiyat iÃ§in dekoratif daireler
- **Full Screen**: Tam ekran deneyimi
- **Responsive**: TÃ¼m ekran boyutlarÄ±na uyumlu

### Renk Paleti
- **Primary**: `#2E7D32` (Orman yeÅŸili)
- **Secondary**: `#4CAF50` (Ã‡imen yeÅŸili)  
- **Tertiary**: `#81C784` (AÃ§Ä±k yeÅŸil)
- **Overlay**: Åeffaf yeÅŸil tonlar
- **Blur Background**: Dinamik blur efektleri

## ğŸ” Authentication Sistemi

### Desteklenen Platformlar
- **Google OAuth**: TÃ¼m platformlarda
- **Apple Sign In**: Sadece iOS'ta gÃ¶rÃ¼nÃ¼r
- **Supabase Backend**: GÃ¼venli auth yÃ¶netimi

### OAuth Flow
1. KullanÄ±cÄ± login butonuna tÄ±klar
2. Supabase OAuth provider'Ä±na yÃ¶nlendirilir
3. KullanÄ±cÄ± kimlik doÄŸrulamasÄ± yapar
4. `geliom://auth/callback` URL'sine geri dÃ¶ner
5. Callback handler session'Ä± kontrol eder
6. BaÅŸarÄ±lÄ± ise ana sayfaya yÃ¶nlendirir

## ğŸ“± KullanÄ±m

### Login SayfasÄ± Ã–zellikleri
```tsx
// Temel kullanÄ±m
<BaseLayout fullScreen={true} headerShow={true}>
  <LinearGradient colors={[primary, secondary, tertiary]}>
    <BlurView intensity={20}>
      {/* Login iÃ§eriÄŸi */}
    </BlurView>
  </LinearGradient>
</BaseLayout>
```

### Login ButonlarÄ±
```tsx
// Google Login
<TouchableOpacity onPress={handleGoogleLogin}>
  <Ionicons name="logo-google" />
  <Typography variant="button">Google ile GiriÅŸ Yap</Typography>
</TouchableOpacity>

// Apple Login (iOS only)
{Platform.OS === 'ios' && (
  <TouchableOpacity onPress={handleAppleLogin}>
    <Ionicons name="logo-apple" />
    <Typography variant="button">Apple ile GiriÅŸ Yap</Typography>
  </TouchableOpacity>
)}
```

## âš™ï¸ KonfigÃ¼rasyon

### app.json OAuth AyarlarÄ±
```json
{
  "ios": {
    "infoPlist": {
      "CFBundleURLTypes": [
        {
          "CFBundleURLName": "geliom-auth",
          "CFBundleURLSchemes": ["geliom"]
        }
      ]
    }
  },
  "android": {
    "intentFilters": [
      {
        "action": "VIEW",
        "autoVerify": true,
        "data": [{ "scheme": "geliom" }],
        "category": ["BROWSABLE", "DEFAULT"]
      }
    ]
  }
}
```

### Supabase KonfigÃ¼rasyonu
```typescript
// api/supabase.ts
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: AsyncStorage,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
});
```

### Environment Variables
```bash
# .env
EXPO_PUBLIC_SUPABASE_URL=your_supabase_url
EXPO_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
```

## ğŸ”§ OAuth Handler FonksiyonlarÄ±

### Google Login
```typescript
const handleGoogleLogin = async () => {
  try {
    setIsLoading(true);
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: 'google',
      options: {
        redirectTo: 'geliom://auth/callback',
      },
    });

    if (error) {
      Alert.alert('Hata', 'Google ile giriÅŸ yapÄ±lamadÄ±: ' + error.message);
      return;
    }

    if (data) {
      router.replace('/');
    }
  } catch (error) {
    Alert.alert('Hata', 'Beklenmeyen bir hata oluÅŸtu');
  } finally {
    setIsLoading(false);
  }
};
```

### Apple Login
```typescript
const handleAppleLogin = async () => {
  try {
    setIsLoading(true);
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: 'apple',
      options: {
        redirectTo: 'geliom://auth/callback',
      },
    });

    if (error) {
      Alert.alert('Hata', 'Apple ile giriÅŸ yapÄ±lamadÄ±: ' + error.message);
      return;
    }

    if (data) {
      router.replace('/');
    }
  } catch (error) {
    Alert.alert('Hata', 'Beklenmeyen bir hata oluÅŸtu');
  } finally {
    setIsLoading(false);
  }
};
```

## ğŸ“„ Callback Handler

### Auth Callback SayfasÄ±
```typescript
// app/(auth)/callback.tsx
export default function AuthCallback() {
  useEffect(() => {
    const handleAuthCallback = async () => {
      try {
        const { data, error } = await supabase.auth.getSession();
        
        if (error) {
          router.replace('/(auth)/login');
          return;
        }

        if (data.session) {
          router.replace('/');
        } else {
          router.replace('/(auth)/login');
        }
      } catch (error) {
        router.replace('/(auth)/login');
      }
    };

    handleAuthCallback();
  }, []);
}
```

## ğŸ¯ Geliom Ã–zel Ã–zellikler

### DoÄŸa TemalÄ± Mesajlar
- **HoÅŸ Geldin**: "HoÅŸ Geldin! ğŸ‘‹"
- **Tagline**: "ğŸŒ¿ DoÄŸal baÄŸlantÄ±lar kur"
- **AÃ§Ä±klama**: "ArkadaÅŸlarÄ±nla ve ailenle baÄŸlantÄ± kurmak iÃ§in giriÅŸ yap"
- **Loading**: "GiriÅŸ iÅŸlemi tamamlanÄ±yor... ğŸŒ¿"

### Blur Efektleri
```typescript
<BlurView 
  intensity={20} 
  tint={isDark ? 'dark' : 'light'} 
  style={styles.loginContainer}
>
  {/* Login iÃ§eriÄŸi */}
</BlurView>
```

### Dekoratif Elementler
```typescript
// DoÄŸal hissiyat iÃ§in daireler
<View style={[styles.decorativeCircle, styles.circle1]} />
<View style={[styles.decorativeCircle, styles.circle2]} />
<View style={[styles.decorativeCircle, styles.circle3]} />
```

## ğŸ”’ GÃ¼venlik

### Best Practices
1. **Environment Variables**: Hassas bilgileri .env dosyasÄ±nda saklayÄ±n
2. **HTTPS**: Sadece gÃ¼venli baÄŸlantÄ±lar kullanÄ±n
3. **Session Management**: Otomatik token yenileme aktif
4. **Error Handling**: KullanÄ±cÄ± dostu hata mesajlarÄ±
5. **Deep Linking**: GÃ¼venli callback URL'leri

### Hata YÃ¶netimi
```typescript
if (error) {
  Alert.alert('Hata', 'GiriÅŸ yapÄ±lamadÄ±: ' + error.message);
  return;
}
```

## ğŸ“± Platform DesteÄŸi

### iOS
- Apple Sign In entegrasyonu
- CFBundleURLTypes konfigÃ¼rasyonu
- Native blur effects

### Android
- Intent filters konfigÃ¼rasyonu
- Google OAuth entegrasyonu
- Material Design uyumlu

### Web
- OAuth popup flow
- Responsive tasarÄ±m
- Cross-browser uyumluluk

Bu login sistemi Geliom'un doÄŸal, samimi ve gÃ¼venli hissiyatÄ±nÄ± desteklemek iÃ§in Ã¶zel olarak tasarlanmÄ±ÅŸtÄ±r. ğŸŒ¿âœ¨
</file>

<file path="docs/Mock-Development-Setup.md">
# Geliom - Mock Development Setup

Geliom uygulamasÄ±nÄ±n mock data ile development ortamÄ±nda Ã§alÄ±ÅŸmasÄ± iÃ§in yapÄ±landÄ±rma.

## ğŸ¯ AmaÃ§

Login sistemini geÃ§erek direkt uygulama geliÅŸtirmesine odaklanmak iÃ§in mock user data kullanÄ±mÄ±.

## ğŸ“Š Mock Data YapÄ±sÄ±

### GeliomUser Interface
```typescript
interface GeliomUser {
  id: string;                    // Unique user ID
  email: string;                 // User email
  display_name: string;          // Display name
  custom_user_id: string;        // Custom username (@handle)
  show_mood: boolean;            // Mood visibility setting
  current_mood_id?: string;      // Current mood ID
  onesignal_player_id?: string;  // Push notification ID
  created_at: string;            // Creation timestamp
  updated_at: string;            // Last update timestamp
}
```

### Mock User Data
```typescript
export const MOCK_USER: GeliomUser = {
  id: 'mock-user-123',
  email: 'hakan@geliom.app',
  display_name: 'Hakan Dursun',
  custom_user_id: 'hakan_dev',
  show_mood: true,
  current_mood_id: '1', // Mutlu
  onesignal_player_id: undefined,
  created_at: '2024-01-15T10:30:00Z',
  updated_at: new Date().toISOString(),
};
```

### Mock Moods
```typescript
export const MOCK_MOODS: UserMood[] = [
  { id: '1', name: 'Mutlu', emoji: 'ğŸ˜Š', color: '#4CAF50' },
  { id: '2', name: 'HeyecanlÄ±', emoji: 'ğŸ¤©', color: '#FF9800' },
  { id: '3', name: 'Sakin', emoji: 'ğŸ˜Œ', color: '#2196F3' },
  { id: '4', name: 'Yorgun', emoji: 'ğŸ˜´', color: '#9E9E9E' },
  { id: '5', name: 'Enerjik', emoji: 'âš¡', color: '#FFEB3B' },
];
```

### Mock Statuses
```typescript
export const MOCK_STATUSES = [
  { id: '1', name: 'MÃ¼saitim', emoji: 'âœ…', color: '#4CAF50', notifies: true },
  { id: '2', name: 'MeÅŸgulÃ¼m', emoji: 'ğŸ”´', color: '#F44336', notifies: true },
  { id: '3', name: 'DÄ±ÅŸarÄ±dayÄ±m', emoji: 'ğŸš¶', color: '#2196F3', notifies: false },
  { id: '4', name: 'Evdeyim', emoji: 'ğŸ ', color: '#795548', notifies: false },
  { id: '5', name: 'Ã‡alÄ±ÅŸÄ±yorum', emoji: 'ğŸ’»', color: '#607D8B', notifies: true },
];
```

## ğŸ”§ Sistem KonfigÃ¼rasyonu

### AuthContext Mock Implementation
```typescript
// Mock session ve user data'yÄ± set et
const initializeAuth = async () => {
  setIsLoading(true);
  
  // SimÃ¼le edilmiÅŸ loading sÃ¼resi
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  setSession(MOCK_SESSION as any);
  setUser(MOCK_USER);
  
  setIsLoading(false);
};

// Mock sign out
const signOut = async () => {
  setSession(null);
  setUser(null);
};
```

### Routing Bypass
```typescript
// _layout.tsx - Login routing'i bypass et
useEffect(() => {
  if (isLoading) return;
  
  // Mock iÃ§in login bypass - direkt ana sayfada kal
  console.log('Layout routing bypassed for mock data');
  
  // GerÃ§ek auth kodu comment'te bekliyor
}, [session, isLoading, segments]);
```

## ğŸ“± UI GÃ¶sterimi

### Ana Sayfa Mock Data Display
```typescript
// User bilgileri
<Typography variant="body">
  {user?.display_name || 'Misafir KullanÄ±cÄ±'}
</Typography>

<Typography variant="caption">
  @{user?.custom_user_id || 'kullanici'}
</Typography>

// User mood gÃ¶sterimi
{currentMood && user?.show_mood && (
  <View style={moodContainerStyle}>
    <Typography>{currentMood.emoji}</Typography>
    <Typography>{currentMood.name}</Typography>
  </View>
)}
```

### Session Status
```typescript
// Mock session her zaman aktif
<Typography variant="status">
  {session ? 'ğŸŸ¢ Ã‡evrimiÃ§i' : 'ğŸ”´ Ã‡evrimdÄ±ÅŸÄ±'}
</Typography>
```

## ğŸš€ Development Workflow

### 1. Mock Mode Aktif
- Uygulama aÃ§Ä±lÄ±nca direkt ana sayfa
- Login ekranÄ± bypass edilir
- Mock user data otomatik yÃ¼klenir

### 2. User Data GÃ¶rÃ¼ntÃ¼leme
- Display name: "Hakan Dursun"
- Username: "@hakan_dev"
- Email: "hakan@geliom.app"
- Mood: "ğŸ˜Š Mutlu" (show_mood: true)
- Status: "ğŸŸ¢ Ã‡evrimiÃ§i"

### 3. Fonksiyonellik
- Sign out mock olarak Ã§alÄ±ÅŸÄ±r
- Auth state deÄŸiÅŸiklikleri simÃ¼le edilir
- Loading states normal Ã§alÄ±ÅŸÄ±r

## ğŸ”„ Production'a GeÃ§iÅŸ

### GerÃ§ek Auth Sistemi AktifleÅŸtirme
1. **AuthContext.tsx**: Mock kod yerine Supabase auth kodunu aktifleÅŸtir
2. **_layout.tsx**: Routing comment'lerini aÃ§
3. **types/user.ts**: Mock data'yÄ± kaldÄ±r veya development flag ile kontrol et

### GeÃ§iÅŸ AdÄ±mlarÄ±
```typescript
// 1. Environment variable ile kontrol
const IS_MOCK_MODE = process.env.EXPO_PUBLIC_MOCK_AUTH === 'true';

// 2. Conditional auth implementation
const initializeAuth = async () => {
  if (IS_MOCK_MODE) {
    // Mock implementation
  } else {
    // Real Supabase implementation
  }
};

// 3. Routing conditional
if (!IS_MOCK_MODE && !session && !inAuthGroup) {
  router.replace('/(auth)/login');
}
```

## ğŸ“‹ Avantajlar

### Development Speed
- Login sÃ¼reci bypass edilir
- Direkt feature development
- HÄ±zlÄ± test dÃ¶ngÃ¼sÃ¼

### Data Consistency
- TutarlÄ± test data
- Predictable user state
- Reliable development environment

### Team Collaboration
- Herkes aynÄ± mock data kullanÄ±r
- Backend baÄŸÄ±msÄ±z development
- Parallel development mÃ¼mkÃ¼n

## ğŸ¨ UI/UX Testing

### Mock Data ile Test SenaryolarÄ±
- User profile gÃ¶rÃ¼ntÃ¼leme
- Mood deÄŸiÅŸiklikleri
- Status updates
- Navigation flows
- Theme switching

Bu mock setup Geliom'un hÄ±zlÄ± development sÃ¼recini desteklemek iÃ§in optimize edilmiÅŸtir. ğŸŒ¿âš¡
</file>

<file path="docs/onesignal-api-key-setup.md">
# OneSignal REST API Key Kurulum Rehberi

Bu dokÃ¼mantasyon, OneSignal REST API Key'in nasÄ±l alÄ±nacaÄŸÄ±nÄ±, doÄŸru formatta nasÄ±l ayarlanacaÄŸÄ±nÄ± ve Supabase Edge Functions'da nasÄ±l kullanÄ±lacaÄŸÄ±nÄ± aÃ§Ä±klar.

## OneSignal REST API Key Nedir?

OneSignal REST API Key, OneSignal REST API'yi kullanarak bildirim gÃ¶ndermek iÃ§in gereken bir kimlik doÄŸrulama anahtarÄ±dÄ±r. Bu key, Supabase Edge Function (`send-notification`) tarafÄ±ndan OneSignal API'ye istek gÃ¶nderirken kullanÄ±lÄ±r.

## OneSignal REST API Key NasÄ±l AlÄ±nÄ±r?

1. **OneSignal Dashboard'a giriÅŸ yapÄ±n**
   - [OneSignal Dashboard](https://app.onesignal.com/) adresine gidin
   - GiriÅŸ yapÄ±n

2. **Settings â†’ Keys & IDs bÃ¶lÃ¼mÃ¼ne gidin**
   - Sol menÃ¼den **Settings** seÃ§eneÄŸine tÄ±klayÄ±n
   - **Keys & IDs** sekmesine gidin

3. **REST API Key'i kopyalayÄ±n**
   - **REST API Key** bÃ¶lÃ¼mÃ¼nde **"Show"** butonuna tÄ±klayÄ±n
   - API Key'i kopyalayÄ±n
   - âš ï¸ **Ã–NEMLÄ°**: API Key'i gÃ¼venli bir yerde saklayÄ±n, bir daha gÃ¶sterilmeyecek!

## OneSignal REST API Key FormatÄ±

- **Uzunluk**: Genellikle 40-50 karakter arasÄ± (bazÄ± durumlarda daha uzun olabilir)
- **Karakter Seti**: Alphanumerik karakterler ve bazÄ± Ã¶zel karakterler (`-`, `_`, vb.)
- **Format**: Base64 benzeri bir string (Ã¶rn: `YjE2MTYxMjEtOTBiNS00Y2IwLWEzZWUtOWUxOGYyZDY5MDdj`)

### Ã–rnek API Key FormatÄ±

```
YjE2MTYxMjEtOTBiNS00Y2IwLWEzZWUtOWUxOGYyZDY5MDdj
```

## Supabase Secrets'a OneSignal REST API Key Ekleme

### YÃ¶ntem 1: Supabase Dashboard (Ã–nerilen)

1. **Supabase Dashboard'a giriÅŸ yapÄ±n**
   - [Supabase Dashboard](https://app.supabase.com/) adresine gidin
   - Projenizi seÃ§in

2. **Edge Functions â†’ Settings â†’ Secrets bÃ¶lÃ¼mÃ¼ne gidin**
   - Sol menÃ¼den **Edge Functions** seÃ§eneÄŸine tÄ±klayÄ±n
   - **Settings** sekmesine gidin
   - **Secrets** bÃ¶lÃ¼mÃ¼ne scroll edin

3. **Yeni Secret ekleyin**
   - **"Add new secret"** butonuna tÄ±klayÄ±n
   - **Name**: `ONESIGNAL_REST_API_KEY`
   - **Value**: OneSignal Dashboard'dan kopyaladÄ±ÄŸÄ±nÄ±z REST API Key'i yapÄ±ÅŸtÄ±rÄ±n
   - âš ï¸ **Ã–NEMLÄ°**: API Key'in baÅŸÄ±nda/sonunda boÅŸluk olmamalÄ±!
   - **"Save"** butonuna tÄ±klayÄ±n

4. **DiÄŸer gerekli secrets'larÄ± kontrol edin**
   - `ONESIGNAL_APP_ID`: OneSignal App ID (Settings â†’ Keys & IDs â†’ App ID)
   - `SUPABASE_URL`: Supabase proje URL'i (Settings â†’ API â†’ Project URL)
   - `SUPABASE_SERVICE_ROLE_KEY`: Supabase Service Role Key (Settings â†’ API â†’ service_role key)

### YÃ¶ntem 2: Supabase CLI

```bash
# Supabase CLI ile secret ekleme
supabase secrets set ONESIGNAL_REST_API_KEY=your_api_key_here

# TÃ¼m secrets'larÄ± listeleme
supabase secrets list
```

## API Key DoÄŸrulama ve Test

### 1. Edge Function Log'larÄ±nÄ± Kontrol Edin

Supabase Dashboard â†’ Edge Functions â†’ Logs bÃ¶lÃ¼mÃ¼nden `send-notification` fonksiyonunun log'larÄ±nÄ± kontrol edin:

```
ğŸ”µ Edge Function environment variables: {
  ONESIGNAL_REST_API_KEY: "âœ… Set (113 karakter, YjE2M...MDdj)"
  ONESIGNAL_REST_API_KEY_VALID: "âœ… Valid"
}
```

EÄŸer `âŒ Invalid` gÃ¶rÃ¼yorsanÄ±z, API Key formatÄ±nÄ± kontrol edin.

### 2. cURL ile OneSignal API Testi

OneSignal REST API Key'inizi test etmek iÃ§in aÅŸaÄŸÄ±daki cURL komutunu kullanabilirsiniz:

```bash
# OneSignal REST API Key'inizi test edin
curl -X POST "https://onesignal.com/api/v1/notifications" \
  -H "Content-Type: application/json" \
  -H "Authorization: Basic YOUR_REST_API_KEY_HERE" \
  -d '{
    "app_id": "YOUR_ONESIGNAL_APP_ID",
    "include_player_ids": ["test_player_id"],
    "headings": {"en": "Test Notification"},
    "contents": {"en": "This is a test notification"}
  }'
```

**Beklenen SonuÃ§lar:**
- âœ… **200 OK**: API Key geÃ§erli, bildirim gÃ¶nderildi
- âŒ **403 Forbidden**: API Key geÃ§ersiz veya yanlÄ±ÅŸ format
- âŒ **400 Bad Request**: Request body formatÄ± hatalÄ±

### 3. Edge Function'dan Test Bildirimi GÃ¶nderme

Uygulama iÃ§inden bir test bildirimi gÃ¶ndererek API Key'in Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± kontrol edebilirsiniz:

1. Uygulamada bir grup oluÅŸturun veya mevcut bir gruba katÄ±lÄ±n
2. Bir kullanÄ±cÄ±ya katÄ±lma isteÄŸi gÃ¶nderin
3. Supabase Dashboard â†’ Edge Functions â†’ Logs bÃ¶lÃ¼mÃ¼nden log'larÄ± kontrol edin

**BaÅŸarÄ±lÄ± Log Ã–rneÄŸi:**
```
âœ… OneSignal bildirim gÃ¶nderildi: {
  id: "notification_id",
  recipients: 1
}
```

**Hata Log Ã–rneÄŸi:**
```
âŒ OneSignal API hatasÄ±: {
  status: 403,
  statusText: "Forbidden",
  error: "Access denied. Please include an 'Authorization: ...' header with a valid API key"
}
```

## YaygÄ±n Hatalar ve Ã‡Ã¶zÃ¼mleri

### Hata 1: "403 Forbidden - Access denied"

**Nedenler:**
- API Key yanlÄ±ÅŸ veya geÃ§ersiz
- API Key formatÄ± hatalÄ± (baÅŸÄ±nda/sonunda boÅŸluk var)
- API Key bu App ID iÃ§in yetkisiz
- API Key sÃ¼resi dolmuÅŸ veya iptal edilmiÅŸ

**Ã‡Ã¶zÃ¼mler:**
1. OneSignal Dashboard'dan yeni bir REST API Key oluÅŸturun
2. Supabase Secrets'dan API Key'i silin ve yeniden ekleyin (baÅŸÄ±nda/sonunda boÅŸluk olmadan)
3. API Key'in doÄŸru App ID ile eÅŸleÅŸtiÄŸinden emin olun
4. Edge Function log'larÄ±nda API Key preview'Ä±nÄ± kontrol edin

### Hata 2: "API Key Ã§ok kÄ±sa" veya "API Key formatÄ± hatalÄ±"

**Nedenler:**
- API Key yanlÄ±ÅŸ kopyalandÄ± (eksik karakterler)
- API Key'in baÅŸÄ±nda/sonunda gÃ¶rÃ¼nmez karakterler var

**Ã‡Ã¶zÃ¼mler:**
1. OneSignal Dashboard'dan API Key'i tekrar kopyalayÄ±n
2. Supabase Secrets'da API Key'i yeniden yapÄ±ÅŸtÄ±rÄ±n
3. API Key'in tamamÄ±nÄ± kopyaladÄ±ÄŸÄ±nÄ±zdan emin olun

### Hata 3: "ONESIGNAL_REST_API_KEY environment variable eksik"

**Nedenler:**
- Secret Supabase'e eklenmemiÅŸ
- Secret adÄ± yanlÄ±ÅŸ yazÄ±lmÄ±ÅŸ (bÃ¼yÃ¼k/kÃ¼Ã§Ã¼k harf duyarlÄ±)

**Ã‡Ã¶zÃ¼mler:**
1. Supabase Dashboard â†’ Edge Functions â†’ Settings â†’ Secrets bÃ¶lÃ¼mÃ¼nden kontrol edin
2. Secret adÄ±nÄ±n tam olarak `ONESIGNAL_REST_API_KEY` olduÄŸundan emin olun
3. Secret'Ä± silin ve yeniden ekleyin

## GÃ¼venlik Ã–nerileri

1. **API Key'i asla commit etmeyin**
   - `.env` dosyalarÄ±nÄ± `.gitignore`'a ekleyin
   - API Key'i kod iÃ§inde hardcode etmeyin
   - Sadece Supabase Secrets'da saklayÄ±n

2. **API Key'i dÃ¼zenli olarak rotate edin**
   - Her 3-6 ayda bir yeni API Key oluÅŸturun
   - Eski API Key'i iptal edin

3. **API Key eriÅŸimini sÄ±nÄ±rlandÄ±rÄ±n**
   - OneSignal Dashboard'da IP allowlisting kullanabilirsiniz
   - Sadece gerekli olan Edge Function'lara eriÅŸim verin

## Ä°lgili DokÃ¼mantasyon

- [OneSignal REST API Overview](https://documentation.onesignal.com/reference)
- [OneSignal Keys & IDs](https://documentation.onesignal.com/docs/accounts-and-keys)
- [Supabase Edge Functions Secrets](https://supabase.com/docs/guides/functions/secrets)
- [OneSignal Troubleshooting](https://documentation.onesignal.com/docs/troubleshooting)

## Destek

Sorun yaÅŸÄ±yorsanÄ±z:
1. Edge Function log'larÄ±nÄ± kontrol edin
2. OneSignal Dashboard'da API Key'in durumunu kontrol edin
3. Bu dokÃ¼mantasyondaki troubleshooting adÄ±mlarÄ±nÄ± takip edin
4. OneSignal ve Supabase destek ekipleriyle iletiÅŸime geÃ§in
</file>

<file path="docs/onesignal-fix-checklist.md">
# OneSignal Sorun Giderme Checklist

## Sorun 1: Edge Function 403 Forbidden HatasÄ±

### Hata
```
Access denied. Please include an 'Authorization: ...' header with a valid API key
```

### Ã‡Ã¶zÃ¼m

1. **OneSignal Dashboard'dan REST API Key'i al:**
   - OneSignal Dashboard â†’ Settings â†’ Keys & IDs
   - **REST API Key**'i kopyala (uzun bir string, Ã¶rn: `YjA3...`)

2. **Supabase Dashboard'a git:**
   - Supabase Dashboard â†’ Project â†’ Edge Functions â†’ Settings â†’ Secrets

3. **Secret ekle/gÃ¼ncelle:**
   - **Name:** `ONESIGNAL_REST_API_KEY`
   - **Value:** OneSignal REST API Key (kopyaladÄ±ÄŸÄ±n deÄŸer)
   - **Save**

4. **Edge Function'Ä± yeniden deploy et:**
   ```bash
   supabase functions deploy send-notification
   ```

5. **Kontrol:**
   - Edge Function log'larÄ±nda `ONESIGNAL_REST_API_KEY: âœ… Set` gÃ¶rÃ¼nmeli
   - `ONESIGNAL_REST_API_KEY_LENGTH` 0'dan bÃ¼yÃ¼k olmalÄ±

### Not
- REST API Key, OneSignal App ID'den farklÄ±dÄ±r
- REST API Key, OneSignal Dashboard â†’ Settings â†’ Keys & IDs'den alÄ±nÄ±r
- Secret'Ä± ekledikten sonra Edge Function'Ä± yeniden deploy etmek gerekebilir

## Sorun 2: OneSignal Dashboard'da User GÃ¶rÃ¼nmÃ¼yor

### Kontrol Listesi

1. **OneSignal SDK Initialize Edildi mi?**
   - Console'da `âœ… OneSignal SDK initialize edildi` gÃ¶rÃ¼nmeli
   - EÄŸer gÃ¶rÃ¼nmÃ¼yorsa, app'i yeniden baÅŸlat

2. **Permission Verildi mi?**
   - Console'da `âœ… OneSignal permission granted: true` gÃ¶rÃ¼nmeli
   - EÄŸer `false` ise, cihaz ayarlarÄ±ndan bildirim izni ver

3. **Player ID OluÅŸtu mu?**
   - Console'da `âœ… OneSignal Player ID hazÄ±r: <id>` gÃ¶rÃ¼nmeli
   - EÄŸer gÃ¶rÃ¼nmÃ¼yorsa, permission verildikten sonra 2-3 saniye bekle

4. **Login YapÄ±ldÄ± mÄ±?**
   - Console'da `âœ… OneSignal login baÅŸarÄ±lÄ±, external ID ayarlandÄ±: <id>` gÃ¶rÃ¼nmeli
   - EÄŸer gÃ¶rÃ¼nmÃ¼yorsa, app'i yeniden baÅŸlat veya logout/login yap

5. **OneSignal Dashboard'da Kontrol:**
   - OneSignal Dashboard â†’ Audience â†’ All Users
   - External ID ile ara (Supabase auth ID)
   - Veya Player ID ile ara

### Debug AdÄ±mlarÄ±

1. **App'i tamamen kapat ve yeniden aÃ§**
2. **Login yap**
3. **Console log'larÄ±nÄ± kontrol et:**
   ```
   ğŸ”µ OneSignal initialize ediliyor
   âœ… OneSignal SDK initialize edildi
   âœ… OneSignal permission granted: true
   âœ… OneSignal Player ID hazÄ±r: <id>
   ğŸ”µ OneSignal login yapÄ±lÄ±yor, external ID: <id>
   âœ… OneSignal login baÅŸarÄ±lÄ±
   âœ… OneSignal alias eklendi
   âœ… OneSignal tags eklendi
   ```

4. **EÄŸer Player ID gÃ¶rÃ¼nmÃ¼yorsa:**
   - Permission verildikten sonra 2-3 saniye bekle
   - Push subscription change listener Ã§alÄ±ÅŸacak
   - Console'da `ğŸ”” OneSignal push subscription changed` gÃ¶rÃ¼nmeli

5. **EÄŸer login yapÄ±lmÄ±yorsa:**
   - `pendingExternalId` mekanizmasÄ± Ã§alÄ±ÅŸÄ±yor olmalÄ±
   - Subscription oluÅŸunca otomatik login yapÄ±lacak
   - Console'da `ğŸ”µ Bekleyen external ID var, otomatik login yapÄ±lÄ±yor` gÃ¶rÃ¼nmeli

### iOS Ã–zel Notlar

- iOS'ta permission verildikten sonra subscription oluÅŸmasÄ± biraz zaman alabilir
- Test cihazÄ±nda APNs sertifikasÄ± doÄŸru yapÄ±landÄ±rÄ±lmÄ±ÅŸ olmalÄ±
- Development build'de sandbox APNs kullanÄ±lÄ±r, production build'de production APNs

### Android Ã–zel Notlar

- Android'de FCM (Firebase Cloud Messaging) yapÄ±landÄ±lmÄ±ÅŸ olmalÄ±
- `google-services.json` dosyasÄ± doÄŸru yapÄ±landÄ±rÄ±lmÄ±ÅŸ olmalÄ±
- OneSignal App ID ve FCM Server Key doÄŸru yapÄ±landÄ±rÄ±lmÄ±ÅŸ olmalÄ±

## Test

1. **Edge Function Test:**
   - Supabase Dashboard â†’ Edge Functions â†’ `send-notification` â†’ Test
   - Body'ye test payload'Ä± ekle
   - Invoke et
   - Log'larÄ± kontrol et

2. **OneSignal Dashboard Test:**
   - OneSignal Dashboard â†’ Messages â†’ New Push
   - Test kullanÄ±cÄ±sÄ±na bildirim gÃ¶nder
   - Bildirim geliyorsa, user oluÅŸmuÅŸ demektir
</file>

<file path="docs/onesignal-ios-fix-checklist.md">
# OneSignal iOS Bildirim Sorun Giderme Checklist

## HÄ±zlÄ± Kontrol Listesi

### âœ… 1. Player ID ile Test Bildirimi GÃ¶nder

**OneSignal Dashboard:**
1. Messages â†’ New Push
2. **Target Audience:** "Send to Specific Users"
3. **Player ID'yi girin:** `3cf0f9f5-fa07-4c20-af84-14b220633160` (log'lardan)
   - âš ï¸ **Ã–NEMLÄ°:** External ID deÄŸil, Player ID kullanÄ±n!
4. Mesaj gÃ¶nder

### âœ… 2. OneSignal Dashboard'da CihazÄ± Kontrol Et

1. Audience â†’ Devices
2. External ID ile arayÄ±n: `da9ed634-9b37-4812-b12d-ed9333c7310f`
3. CihazÄ±nÄ±z listede gÃ¶rÃ¼nÃ¼yor mu?
4. Push Subscription aktif mi? (Status: Subscribed)

### âœ… 3. iOS APNs YapÄ±landÄ±rmasÄ±

**OneSignal Dashboard:**
1. Settings â†’ Platforms â†’ iOS
2. **APNs Authentication Key** veya **APNs Certificate** yapÄ±landÄ±rÄ±lmÄ±ÅŸ mÄ±?
3. EÄŸer yoksa:
   - Apple Developer Portal'dan APNs Key oluÅŸturun
   - OneSignal'e yÃ¼kleyin

### âœ… 4. Build Type KontrolÃ¼

**Development build'de APNs Ã§alÄ±ÅŸmayabilir:**
- Production build'de test edin:
  ```bash
  eas build --platform ios --profile production
  ```

### âœ… 5. Notification Permission

**iOS Settings:**
1. Settings â†’ Geliom â†’ Notifications
2. "Allow Notifications" aÃ§Ä±k mÄ±?
3. "Lock Screen", "Notification Center", "Banners" aÃ§Ä±k mÄ±?

### âœ… 6. Uygulama Durumu

**iOS'ta bildirimler:**
- Uygulama arka plandayken gelir
- Uygulama kapalÄ±yken gelir
- Uygulama aÃ§Ä±kken (foreground) gelmeyebilir (NotificationHandler log'larÄ±nÄ± kontrol edin)

### âœ… 7. OneSignal API Response KontrolÃ¼

**OneSignal Dashboard:**
1. Messages â†’ Delivery Reports
2. GÃ¶nderdiÄŸiniz bildirimin durumunu kontrol edin
3. Hata mesajÄ± var mÄ±?
4. "Delivered" sayÄ±sÄ± > 0 mÄ±?

## Test AdÄ±mlarÄ±

### AdÄ±m 1: Player ID'yi DoÄŸrula

Log'lardan Player ID'yi alÄ±n:
```
âœ… OneSignal Player ID: 3cf0f9f5-fa07-4c20-af84-14b220633160
```

### AdÄ±m 2: OneSignal Dashboard'dan Test

1. Messages â†’ New Push
2. "Send to Specific Users" â†’ Player ID'yi yapÄ±ÅŸtÄ±r
3. "Test" mesajÄ± gÃ¶nder
4. Delivery Reports'ta durumu kontrol et

### AdÄ±m 3: Uygulama Durumunu Kontrol Et

- UygulamayÄ± arka plana alÄ±n (home button'a basÄ±n)
- Bildirim gelmeli
- Notification Center'Ä± kontrol edin

### AdÄ±m 4: Console Log'larÄ±nÄ± Kontrol Et

Uygulama aÃ§Ä±kken bildirim gelirse:
```
ğŸ”” OneSignal notification received in foreground: ...
```

Uygulama kapalÄ±yken bildirim gelirse:
- Notification Center'da gÃ¶rÃ¼nmeli
- Bildirime tÄ±klayÄ±nca uygulama aÃ§Ä±lmalÄ±

## YaygÄ±n Sorunlar

### Sorun 1: "Invalid Player ID"
- **Ã‡Ã¶zÃ¼m:** Player ID'yi doÄŸru kopyaladÄ±ÄŸÄ±nÄ±zdan emin olun
- Log'lardan: `âœ… OneSignal Player ID: 3cf0f9f5-fa07-4c20-af84-14b220633160`

### Sorun 2: "No devices found"
- **Ã‡Ã¶zÃ¼m:** 
  - Audience â†’ Devices'da cihazÄ± kontrol edin
  - External ID ile arayÄ±n: `da9ed634-9b37-4812-b12d-ed9333c7310f`
  - Push Subscription aktif mi kontrol edin

### Sorun 3: iOS'ta bildirim gelmiyor
- **Ã‡Ã¶zÃ¼m:**
  1. APNs sertifikasÄ± yapÄ±landÄ±rÄ±lmÄ±ÅŸ mÄ± kontrol edin
  2. Production build'de test edin
  3. Settings â†’ Geliom â†’ Notifications kontrol edin
  4. UygulamayÄ± arka plana alÄ±n

### Sorun 4: Bildirim gÃ¶nderiliyor ama gelmiyor
- **Ã‡Ã¶zÃ¼m:**
  1. Delivery Reports'ta durumu kontrol edin
  2. Hata mesajÄ± var mÄ± kontrol edin
  3. Uygulama durumunu kontrol edin (arka planda mÄ±?)
  4. Internet baÄŸlantÄ±sÄ± var mÄ± kontrol edin

## HÄ±zlÄ± Test

1. **Player ID'yi al:** `3cf0f9f5-fa07-4c20-af84-14b220633160`
2. **OneSignal Dashboard:** Messages â†’ New Push â†’ "Send to Specific Users" â†’ Player ID
3. **Mesaj gÃ¶nder:** "Test bildirimi"
4. **UygulamayÄ± arka plana al**
5. **Bildirim gelmeli**

## Debug KomutlarÄ±

### Player ID'yi Console'da GÃ¶rmek

Uygulama aÃ§Ä±kken console'da:
```
âœ… OneSignal Player ID: 3cf0f9f5-fa07-4c20-af84-14b220633160
```

### OneSignal Subscription Durumunu Kontrol Etmek

OneSignal Dashboard:
- Audience â†’ Devices
- External ID ile arayÄ±n: `da9ed634-9b37-4812-b12d-ed9333c7310f`
- Push Subscription durumunu kontrol edin
</file>

<file path="docs/onesignal-player-id-test.md">
# OneSignal Player ID Test Rehberi

## Durum

OneSignal Dashboard'da:
- **OneSignal ID:** `b1616121-90b5-4cb0-a3ee-9e18f2d6907c` (Dashboard'dan)
- **External ID:** GÃ¶rÃ¼nmÃ¼yor (bu normal, kod gÃ¼ncellendi, bir sonraki login'de gÃ¶rÃ¼necek)

Log'lardan:
- **Player ID:** `3cf0f9f5-fa07-4c20-af84-14b220633160` (Uygulama log'larÄ±ndan)

## Ã–nemli Not

**Player ID'ler farklÄ± olabilir!** Bu normal Ã§Ã¼nkÃ¼:
- Her cihaz/abonelik iÃ§in farklÄ± Player ID oluÅŸur
- Uygulama yeniden yÃ¼klendiÄŸinde yeni Player ID oluÅŸabilir
- Her zaman **en gÃ¼ncel Player ID'yi kullanÄ±n**

## Test Bildirimi GÃ¶nderme

### YÃ¶ntem 1: OneSignal Dashboard'dan (Player ID ile)

1. **OneSignal Dashboard â†’ Messages â†’ New Push**
2. **Target Audience:** "Send to Specific Users"
3. **Player ID'yi girin:**
   - Dashboard'dan: `b1616121-90b5-4cb0-a3ee-9e18f2d6907c`
   - Veya log'lardan: `3cf0f9f5-fa07-4c20-af84-14b220633160`
4. **Mesaj gÃ¶nder**

### YÃ¶ntem 2: En GÃ¼ncel Player ID'yi Bulma

**Uygulama aÃ§Ä±kken console'da:**
```
âœ… OneSignal Player ID: 3cf0f9f5-fa07-4c20-af84-14b220633160
```

**Supabase'den:**
```sql
SELECT id, display_name, onesignal_player_id 
FROM users 
WHERE id = 'da9ed634-9b37-4812-b12d-ed9333c7310f';
```

**OneSignal Dashboard:**
- Audience â†’ Devices
- CihazÄ±nÄ±zÄ± bulun
- Player ID'yi kopyalayÄ±n

## External ID GÃ¶rÃ¼nmÃ¼yor - Ã‡Ã¶zÃ¼m

Kod gÃ¼ncellendi, artÄ±k:
1. `OneSignal.login()` async olarak Ã§alÄ±ÅŸÄ±yor
2. `OneSignal.User.addAlias()` ile alias ekleniyor
3. Bir sonraki login'de external ID gÃ¶rÃ¼necek

**Test iÃ§in:**
1. UygulamayÄ± kapatÄ±n
2. Tekrar aÃ§Ä±n ve login olun
3. OneSignal Dashboard â†’ Audience â†’ Devices
4. External ID gÃ¶rÃ¼nmeli: `da9ed634-9b37-4812-b12d-ed9333c7310f`

## HÄ±zlÄ± Test

1. **En gÃ¼ncel Player ID'yi al:**
   - Console log'larÄ±ndan: `3cf0f9f5-fa07-4c20-af84-14b220633160`
   - Veya Supabase'den: `onesignal_player_id` kolonunu kontrol et

2. **OneSignal Dashboard:**
   - Messages â†’ New Push
   - "Send to Specific Users" â†’ Player ID'yi yapÄ±ÅŸtÄ±r
   - "Test" mesajÄ± gÃ¶nder

3. **UygulamayÄ± arka plana al** (iOS'ta bildirimler arka plandayken gelir)

4. **Bildirim gelmeli**

## Sorun Devam Ediyorsa

1. **Player ID'yi doÄŸrula:**
   - Console log'larÄ±ndan en gÃ¼ncel Player ID'yi al
   - Supabase'de `onesignal_player_id` kolonunu kontrol et
   - OneSignal Dashboard'da cihazÄ± bul ve Player ID'yi kontrol et

2. **OneSignal Dashboard â†’ Delivery Reports:**
   - Bildirimin durumunu kontrol et
   - Hata mesajÄ± var mÄ±?
   - "Delivered" sayÄ±sÄ± > 0 mÄ±?

3. **iOS APNs yapÄ±landÄ±rmasÄ±:**
   - OneSignal Dashboard â†’ Settings â†’ Platforms â†’ iOS
   - APNs Authentication Key veya Certificate yapÄ±landÄ±rÄ±lmÄ±ÅŸ mÄ±?

4. **Build type:**
   - Development build'de APNs Ã§alÄ±ÅŸmayabilir
   - Production build'de test et
</file>

<file path="docs/onesignal-test-notification.md">
# OneSignal Test Bildirimi GÃ¶nderme Rehberi

## Ã–nemli Notlar

### 1. Player ID vs External ID

**OneSignal Dashboard'dan test bildirimi gÃ¶nderirken:**
- **Player ID kullanÄ±n** (External ID deÄŸil!)
- Player ID: `3cf0f9f5-fa07-4c20-af84-14b220633160` (log'lardan)
- External ID: `da9ed634-9b37-4812-b12d-ed9333c7310f` (Supabase auth ID - bu sadece kullanÄ±cÄ±yÄ± bulmak iÃ§in)

### 2. Test Bildirimi GÃ¶nderme AdÄ±mlarÄ±

1. **OneSignal Dashboard'a gidin:**
   - https://dashboard.onesignal.com/
   - App'Ä±nÄ±zÄ± seÃ§in

2. **Messages â†’ New Push** tÄ±klayÄ±n

3. **Target Audience:**
   - "Send to Specific Users" seÃ§in
   - **Player ID'yi girin** (External ID deÄŸil!)
   - Player ID'yi bulmak iÃ§in:
     - Log'lardan: `âœ… OneSignal Player ID: 3cf0f9f5-fa07-4c20-af84-14b220633160`
     - Veya Supabase `users` tablosundan `onesignal_player_id` kolonunu kontrol edin

4. **Message:**
   - BaÅŸlÄ±k ve iÃ§erik girin
   - Test mesajÄ±: "Test bildirimi"

5. **Send** butonuna tÄ±klayÄ±n

### 3. iOS iÃ§in Ã–zel Kontroller

**iOS'ta bildirim gelmiyorsa:**

1. **APNs SertifikasÄ±:**
   - OneSignal Dashboard â†’ Settings â†’ Platforms â†’ iOS
   - APNs Authentication Key veya APNs Certificate yapÄ±landÄ±rÄ±lmÄ±ÅŸ olmalÄ±
   - Production sertifikasÄ± kullanÄ±lÄ±yorsa, production build'de test edin

2. **Build Type:**
   - Development build'de APNs Ã§alÄ±ÅŸmayabilir
   - Production build'de test edin:
     ```bash
     eas build --platform ios --profile production
     ```

3. **Entitlements:**
   - `app.json` iÃ§inde `aps-environment: production` olmalÄ± âœ… (zaten var)

4. **Notification Permission:**
   - Log'larda `âœ… OneSignal permission granted: true` gÃ¶rÃ¼nÃ¼yor âœ…
   - Ama Settings â†’ Geliom â†’ Notifications kontrol edin

### 4. Debug AdÄ±mlarÄ±

1. **Player ID'yi kontrol edin:**
   ```typescript
   // Console'da Ã§alÄ±ÅŸtÄ±rÄ±n
   import { getOneSignalPlayerId } from '@/services/onesignal';
   getOneSignalPlayerId().then(console.log);
   ```

2. **OneSignal Dashboard'da cihazÄ± kontrol edin:**
   - Audience â†’ Devices
   - CihazÄ±nÄ±z listede gÃ¶rÃ¼nÃ¼yor mu?
   - Push Subscription aktif mi?

3. **OneSignal API Response'unu kontrol edin:**
   - Messages â†’ Delivery Reports
   - Bildirimin durumunu kontrol edin
   - Hata mesajÄ± var mÄ±?

4. **Edge Function log'larÄ±nÄ± kontrol edin:**
   - Supabase Dashboard â†’ Edge Functions â†’ Logs
   - `send-notification` fonksiyonunun log'larÄ±nÄ± kontrol edin
   - OneSignal API response'unu kontrol edin

### 5. YaygÄ±n Sorunlar

#### Sorun 1: "Invalid Player ID"
- **Ã‡Ã¶zÃ¼m:** Player ID'yi doÄŸru kopyaladÄ±ÄŸÄ±nÄ±zdan emin olun
- Log'lardan Player ID'yi alÄ±n: `âœ… OneSignal Player ID: ...`

#### Sorun 2: "No devices found"
- **Ã‡Ã¶zÃ¼m:** 
  - CihazÄ±n OneSignal'e kayÄ±tlÄ± olduÄŸundan emin olun
  - Audience â†’ Devices'da cihazÄ± kontrol edin
  - Push Subscription aktif mi kontrol edin

#### Sorun 3: iOS'ta bildirim gelmiyor
- **Ã‡Ã¶zÃ¼m:**
  - APNs sertifikasÄ± yapÄ±landÄ±rÄ±lmÄ±ÅŸ mÄ± kontrol edin
  - Production build'de test edin
  - Settings â†’ Geliom â†’ Notifications â†’ Allow Notifications

#### Sorun 4: Bildirim gÃ¶nderiliyor ama gelmiyor
- **Ã‡Ã¶zÃ¼m:**
  - Internet baÄŸlantÄ±sÄ± var mÄ± kontrol edin
  - Uygulama arka planda mÄ±? (iOS'ta bildirimler arka planda gelir)
  - Notification Center'Ä± kontrol edin

### 6. Test SenaryolarÄ±

#### Senaryo 1: OneSignal Dashboard'dan Test
1. Player ID'yi log'lardan al
2. OneSignal Dashboard â†’ Messages â†’ New Push
3. "Send to Specific Users" â†’ Player ID'yi gir
4. Mesaj gÃ¶nder
5. Bildirim gelmeli

#### Senaryo 2: Edge Function'dan Test
1. Supabase Dashboard â†’ Edge Functions â†’ `send-notification`
2. Test butonuna tÄ±kla
3. Body'ye ÅŸunu ekle:
   ```json
   {
     "user_ids": ["3cf0f9f5-fa07-4c20-af84-14b220633160"],
     "group_id": "test-group-id",
     "group_name": "Test Grubu",
     "title": "Test",
     "message": "Test bildirimi",
     "type": "status_update"
   }
   ```
4. Invoke et
5. Log'larÄ± kontrol et
6. Bildirim gelmeli

### 7. Player ID'yi Bulma

**YÃ¶ntem 1: Log'lardan**
- Console'da: `âœ… OneSignal Player ID: 3cf0f9f5-fa07-4c20-af84-14b220633160`

**YÃ¶ntem 2: Supabase'den**
```sql
SELECT id, display_name, onesignal_player_id 
FROM users 
WHERE id = 'da9ed634-9b37-4812-b12d-ed9333c7310f';
```

**YÃ¶ntem 3: OneSignal Dashboard**
- Audience â†’ Devices
- External ID ile arayÄ±n: `da9ed634-9b37-4812-b12d-ed9333c7310f`
- Player ID'yi gÃ¶rÃ¼n

### 8. HÄ±zlÄ± Test

1. **Player ID'yi al:**
   - Log'lardan: `3cf0f9f5-fa07-4c20-af84-14b220633160`

2. **OneSignal Dashboard:**
   - Messages â†’ New Push
   - "Send to Specific Users" â†’ Player ID'yi yapÄ±ÅŸtÄ±r
   - "Test" mesajÄ± gÃ¶nder

3. **Beklenen sonuÃ§:**
   - Bildirim gelmeli
   - Console'da: `ğŸ”” OneSignal notification received in foreground:` veya
   - Notification Center'da bildirim gÃ¶rÃ¼nmeli
</file>

<file path="docs/onesignal-troubleshooting.md">
# OneSignal Bildirim Sorun Giderme Rehberi

## Test Bildirimi Gelmiyorsa Kontrol Edilecekler

### 1. OneSignal SDK Initialization

**Kontrol:**
- Uygulama baÅŸladÄ±ÄŸÄ±nda console'da ÅŸu log'lar gÃ¶rÃ¼nmeli:
  - `ğŸ”µ OneSignal initialize ediliyor, App ID: ...`
  - `âœ… OneSignal permission granted: true`
  - `âœ… OneSignal Player ID: ...`

**Sorun:** Log'lar gÃ¶rÃ¼nmÃ¼yorsa
- `app/Provider.tsx` iÃ§inde `initializeOneSignal()` Ã§aÄŸrÄ±lÄ±yor mu kontrol et
- `services/onesignal.ts` dosyasÄ±nda hata var mÄ± kontrol et

### 2. Player ID Kaydediliyor mu?

**Kontrol:**
- KullanÄ±cÄ± login olduktan sonra console'da ÅŸu log gÃ¶rÃ¼nmeli:
  - `âœ… OneSignal Player ID kaydedildi: ...`
- Supabase `users` tablosunda `onesignal_player_id` kolonu dolu mu kontrol et

**Sorun:** Player ID kaydedilmiyorsa
- `contexts/AuthContext.tsx` iÃ§inde `savePlayerId` fonksiyonu Ã§alÄ±ÅŸÄ±yor mu kontrol et
- Retry mekanizmasÄ± Ã§alÄ±ÅŸÄ±yor mu kontrol et (5 deneme, 1 saniye aralÄ±k)

### 3. OneSignal Dashboard'dan Test Bildirimi

**Kontrol:**
- OneSignal Dashboard â†’ Messages â†’ New Push
- **Target Audience:** 
  - "Send to Specific Users" seÃ§
  - Player ID'yi manuel olarak gir (users tablosundan al)
- **Message:** Test mesajÄ±
- **Send**

**Sorun:** Bildirim gelmiyorsa
- Player ID doÄŸru mu kontrol et
- OneSignal App ID doÄŸru mu kontrol et (`app.json` iÃ§inde)
- OneSignal REST API Key doÄŸru mu kontrol et (Supabase Edge Function environment variable)

### 4. Edge Function'dan Bildirim GÃ¶nderme

**Kontrol:**
- Supabase Edge Function log'larÄ±nÄ± kontrol et:
  - `ğŸ”µ OneSignal API Ã§aÄŸrÄ±sÄ± yapÄ±lÄ±yor: ...`
  - `âœ… OneSignal bildirim gÃ¶nderildi: ...`
- OneSignal API response'u kontrol et:
  - `recipients` sayÄ±sÄ± > 0 olmalÄ±
  - `errors` boÅŸ olmalÄ±

**Sorun:** Edge Function hatasÄ± varsa
- OneSignal REST API Key doÄŸru mu kontrol et
- Player ID'ler doÄŸru mu kontrol et
- OneSignal App ID doÄŸru mu kontrol et

### 5. Notification Permission

**Kontrol:**
- iOS: Settings â†’ Geliom â†’ Notifications â†’ Allow Notifications
- Android: Settings â†’ Apps â†’ Geliom â†’ Notifications â†’ Allow

**Sorun:** Permission verilmemiÅŸse
- Uygulama ilk aÃ§Ä±ldÄ±ÄŸÄ±nda permission isteÄŸi Ã§Ä±kmalÄ±
- EÄŸer Ã§Ä±kmÄ±yorsa, `services/onesignal.ts` iÃ§inde `requestPermission` Ã§aÄŸrÄ±sÄ± kontrol et

### 6. Device Token / Push Subscription

**Kontrol:**
- OneSignal Dashboard â†’ Audience â†’ Devices
- CihazÄ±nÄ±z listede gÃ¶rÃ¼nÃ¼yor mu?
- Push Subscription aktif mi?

**Sorun:** Cihaz listede yoksa
- OneSignal SDK dÃ¼zgÃ¼n initialize edilmiÅŸ mi kontrol et
- Permission verilmiÅŸ mi kontrol et
- Internet baÄŸlantÄ±sÄ± var mÄ± kontrol et

### 7. Debug Log'larÄ±

**Kontrol:**
- Console'da ÅŸu log'lar gÃ¶rÃ¼nmeli:
  - `ğŸ”µ OneSignal initialize ediliyor...`
  - `âœ… OneSignal permission granted: true`
  - `âœ… OneSignal Player ID: ...`
  - `âœ… OneSignal login yapÄ±ldÄ±, external ID: ...`
  - `âœ… OneSignal Player ID kaydedildi: ...`

**Sorun:** Log'lar gÃ¶rÃ¼nmÃ¼yorsa
- Console'u aÃ§Ä±k tut
- UygulamayÄ± yeniden baÅŸlat
- Log'larÄ± kontrol et

## YaygÄ±n Sorunlar ve Ã‡Ã¶zÃ¼mleri

### Sorun 1: Player ID null geliyor

**Ã‡Ã¶zÃ¼m:**
- OneSignal SDK'nÄ±n tam initialize olmasÄ±nÄ± bekle
- Retry mekanizmasÄ± zaten var (5 deneme, 1 saniye aralÄ±k)
- EÄŸer hala null geliyorsa, permission verilmiÅŸ mi kontrol et

### Sorun 2: Bildirim gÃ¶nderiliyor ama gelmiyor

**Ã‡Ã¶zÃ¼m:**
- OneSignal Dashboard â†’ Messages â†’ Delivery Reports kontrol et
- Hata mesajÄ± var mÄ± kontrol et
- Player ID doÄŸru mu kontrol et
- Cihaz internet baÄŸlantÄ±sÄ± var mÄ± kontrol et

### Sorun 3: Edge Function hatasÄ±

**Ã‡Ã¶zÃ¼m:**
- Supabase Edge Function log'larÄ±nÄ± kontrol et
- OneSignal REST API Key doÄŸru mu kontrol et
- Environment variable'lar doÄŸru mu kontrol et

### Sorun 4: iOS'ta bildirim gelmiyor

**Ã‡Ã¶zÃ¼m:**
- iOS entitlements doÄŸru mu kontrol et (`app.json`)
- APNs sertifikasÄ± OneSignal'de yapÄ±landÄ±rÄ±lmÄ±ÅŸ mÄ± kontrol et
- Production build'de test et (development build'de APNs Ã§alÄ±ÅŸmayabilir)

### Sorun 5: Android'de bildirim gelmiyor

**Ã‡Ã¶zÃ¼m:**
- Google Services dosyasÄ± (`google-services.json`) doÄŸru mu kontrol et
- Firebase Cloud Messaging (FCM) yapÄ±landÄ±rÄ±lmÄ±ÅŸ mÄ± kontrol et
- OneSignal Dashboard'da Android platform aktif mi kontrol et

## Test AdÄ±mlarÄ±

1. **UygulamayÄ± aÃ§**
   - Console'da OneSignal initialize log'larÄ±nÄ± kontrol et
   - Permission isteÄŸi Ã§Ä±kmalÄ±

2. **Login ol**
   - Console'da Player ID kaydedildi log'unu kontrol et
   - Supabase users tablosunda `onesignal_player_id` kontrol et

3. **OneSignal Dashboard'dan test bildirimi gÃ¶nder**
   - Player ID'yi kullanarak manuel bildirim gÃ¶nder
   - Bildirim gelmeli

4. **Edge Function'dan test bildirimi gÃ¶nder**
   - `send-notification` Edge Function'Ä±nÄ± Ã§aÄŸÄ±r
   - Log'larÄ± kontrol et
   - Bildirim gelmeli

## Debug KomutlarÄ±

### Player ID'yi Console'da GÃ¶rmek

```typescript
import { getOneSignalPlayerId } from '@/services/onesignal';

getOneSignalPlayerId().then((playerId) => {
  console.log('Player ID:', playerId);
});
```

### OneSignal Subscription Durumunu Kontrol Etmek

```typescript
import { OneSignal } from 'react-native-onesignal';

OneSignal.User.pushSubscription.getOptedInAsync().then((optedIn) => {
  console.log('Opted in:', optedIn);
});

OneSignal.User.pushSubscription.getIdAsync().then((id) => {
  console.log('Subscription ID:', id);
});
```
</file>

<file path="docs/prebuild-checklist.md">
# Prebuild Ã–ncesi Kontrol Listesi

## âœ… YÃ¼klÃ¼ OlmasÄ± Gereken Paketler

### 1. OneSignal (Bildirim Sistemi)
- âœ… `react-native-onesignal` - YÃ¼klÃ¼ (v5.2.14)
- âœ… `onesignal-expo-plugin` - YÃ¼klÃ¼ (v2.0.3)
- âœ… `app.json`'da plugin konfigÃ¼rasyonu mevcut

### 2. Native ModÃ¼ller
- âœ… `@gorhom/bottom-sheet` - YÃ¼klÃ¼ (v5.2.6)
- âœ… `react-native-adapty` - YÃ¼klÃ¼ (v3.11.2)
- âœ… `react-native-reanimated` - YÃ¼klÃ¼ (v4.1.1)
- âœ… `lottie-react-native` - YÃ¼klÃ¼ (v7.3.4)
- âœ… `react-native-gesture-handler` - YÃ¼klÃ¼ (v2.28.0)
- âœ… `react-native-screens` - YÃ¼klÃ¼ (v4.16.0)

### 3. Expo Paketleri
- âœ… `expo` - YÃ¼klÃ¼ (v54.0.23)
- âœ… `expo-router` - YÃ¼klÃ¼ (v6.0.14)
- âœ… `expo-build-properties` - YÃ¼klÃ¼ (v1.0.9)
- âœ… `expo-apple-authentication` - YÃ¼klÃ¼ (v8.0.7)

## ğŸ“‹ Prebuild Ã–ncesi YapÄ±lacaklar

### 1. Paket YÃ¼kleme KontrolÃ¼
```bash
# TÃ¼m paketlerin yÃ¼klÃ¼ olduÄŸundan emin ol
npm install

# Eksik paket var mÄ± kontrol et
npm list --depth=0
```

### 2. app.json KontrolÃ¼
- âœ… `onesignal-expo-plugin` plugin'i mevcut
- âœ… `oneSignalAppId` extra config'de mevcut
- âœ… iOS entitlements yapÄ±landÄ±rÄ±lmÄ±ÅŸ (aps-environment: production)
- âœ… Android google-services.json mevcut
- âœ… iOS GoogleService-Info.plist mevcut

### 3. Native Dosya KontrolÃ¼
- âœ… `google-services.json` - Android iÃ§in mevcut
- âœ… `GoogleService-Info.plist` - iOS iÃ§in mevcut

### 4. Gelecek Ä°Ã§in YÃ¼klenen Paketler
- âœ… `expo-notifications` - Local notifications iÃ§in
- âœ… `expo-sharing` - Dosya paylaÅŸÄ±mÄ± iÃ§in

### 4. Prebuild Komutu
```bash
# Prebuild yap (iOS ve Android native klasÃ¶rlerini oluÅŸturur)
npx expo prebuild

# Veya sadece iOS iÃ§in
npx expo prebuild --platform ios

# Veya sadece Android iÃ§in
npx expo prebuild --platform android
```

## âš ï¸ Dikkat Edilmesi Gerekenler

1. **OneSignal Plugin**: `app.json`'da `onesignal-expo-plugin` zaten konfigÃ¼re edilmiÅŸ. Prebuild sÄ±rasÄ±nda otomatik olarak native kod ekleyecek.

2. **iOS Entitlements**: `aps-environment: production` ayarlanmÄ±ÅŸ. Development iÃ§in `development` olabilir.

3. **Android**: `google-services.json` dosyasÄ± mevcut ve doÄŸru konumda olmalÄ±.

4. **iOS**: `GoogleService-Info.plist` dosyasÄ± mevcut ve doÄŸru konumda olmalÄ±.

## ğŸ” Prebuild SonrasÄ± Kontrol

Prebuild sonrasÄ± ÅŸunlarÄ± kontrol edin:

1. **iOS**:
   - `ios/` klasÃ¶rÃ¼ oluÅŸturuldu mu?
   - `ios/Podfile` mevcut mu?
   - `pod install` Ã§alÄ±ÅŸtÄ±rÄ±lmalÄ± (iOS iÃ§in)

2. **Android**:
   - `android/` klasÃ¶rÃ¼ oluÅŸturuldu mu?
   - `android/app/google-services.json` mevcut mu?

3. **OneSignal**:
   - iOS: `ios/Geliom/Info.plist` iÃ§inde OneSignal ayarlarÄ± var mÄ±?
   - Android: `android/app/build.gradle` iÃ§inde OneSignal plugin'i var mÄ±?

## ğŸ“ Notlar

- Prebuild yapÄ±ldÄ±ktan sonra `ios/` ve `android/` klasÃ¶rleri oluÅŸur
- Bu klasÃ¶rler `.gitignore`'da olmamalÄ± (native kodlar)
- Prebuild sonrasÄ± `npx expo run:ios` veya `npx expo run:android` ile Ã§alÄ±ÅŸtÄ±rabilirsiniz
</file>

<file path="docs/Professional-Auth-System.md">
# Geliom - Profesyonel Authentication Sistemi

Expo'nun resmi authentication paketleri ve Supabase entegrasyonu ile oluÅŸturulmuÅŸ kaliteli auth sistemi.

## ğŸ—ï¸ Mimari YapÄ±

### KullanÄ±lan Paketler
- **expo-apple-authentication**: iOS iÃ§in resmi Apple Sign In
- **expo-auth-session**: OAuth flow yÃ¶netimi
- **expo-crypto**: GÃ¼venli kriptografik iÅŸlemler
- **@supabase/supabase-js**: Backend auth yÃ¶netimi

### Sistem BileÅŸenleri
```
AuthProvider (Context)
â”œâ”€â”€ Session Management
â”œâ”€â”€ User Profile Management
â”œâ”€â”€ Auto Profile Creation
â””â”€â”€ Auth State Listeners

Login Page
â”œâ”€â”€ Google OAuth (Supabase)
â”œâ”€â”€ Apple Sign In (Native)
â”œâ”€â”€ Blur Effects
â””â”€â”€ Error Handling

Auth Flow
â”œâ”€â”€ OAuth Redirect Handling
â”œâ”€â”€ Session Persistence
â””â”€â”€ Auto Navigation
```

## ğŸ” Authentication Flow

### Google Login Flow
1. KullanÄ±cÄ± "Google ile GiriÅŸ Yap" butonuna tÄ±klar
2. Supabase OAuth provider'Ä±na yÃ¶nlendirilir
3. Google auth sayfasÄ± aÃ§Ä±lÄ±r
4. KullanÄ±cÄ± kimlik doÄŸrulamasÄ± yapar
5. Supabase session oluÅŸturur
6. AuthContext listener session'Ä± yakalar
7. User profili otomatik oluÅŸturulur/gÃ¼ncellenir
8. Ana sayfaya yÃ¶nlendirilir

### Apple Login Flow
1. KullanÄ±cÄ± Apple Sign In butonuna tÄ±klar
2. iOS native Apple auth dialog aÃ§Ä±lÄ±r
3. KullanÄ±cÄ± Face ID/Touch ID ile doÄŸrular
4. Apple identity token alÄ±nÄ±r
5. Supabase'e token gÃ¶nderilir
6. Session oluÅŸturulur ve flow devam eder

## ğŸ“± KullanÄ±m

### Login SayfasÄ±
```tsx
// Profesyonel Google Login
<TouchableOpacity onPress={handleGoogleLogin}>
  <Ionicons name="logo-google" size={24} color="#4285F4" />
  <Typography variant="button">Google ile GiriÅŸ Yap</Typography>
</TouchableOpacity>

// Native Apple Login (iOS only)
<AppleAuthentication.AppleAuthenticationButton
  buttonType={AppleAuthentication.AppleAuthenticationButtonType.SIGN_IN}
  buttonStyle={isDark ? 
    AppleAuthentication.AppleAuthenticationButtonStyle.WHITE : 
    AppleAuthentication.AppleAuthenticationButtonStyle.BLACK
  }
  cornerRadius={16}
  onPress={handleAppleLogin}
/>
```

### Auth Context KullanÄ±mÄ±
```tsx
const { session, user, isLoading, signOut } = useAuth();

// GiriÅŸ durumu kontrolÃ¼
if (isLoading) return <LoadingScreen />;
if (!session) return <LoginScreen />;

// KullanÄ±cÄ± bilgileri
console.log(user.email, user.display_name);

// Ã‡Ä±kÄ±ÅŸ yapma
await signOut();
```

## ğŸ› ï¸ KonfigÃ¼rasyon

### Environment Variables
```bash
# .env
EXPO_PUBLIC_SUPABASE_URL=your_supabase_url
EXPO_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
```

### Supabase Auth Settings
```sql
-- Users tablosu (otomatik oluÅŸturulur)
CREATE TABLE users (
  id UUID PRIMARY KEY REFERENCES auth.users(id),
  email TEXT,
  display_name TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- RLS Policies
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own profile" ON users
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update own profile" ON users
  FOR UPDATE USING (auth.uid() = id);
```

### OAuth Providers (Supabase Dashboard)
```
Google OAuth:
- Client ID: your_google_client_id
- Client Secret: your_google_client_secret
- Redirect URL: your_app_scheme://auth/callback

Apple OAuth:
- Service ID: your_apple_service_id
- Team ID: your_apple_team_id
- Key ID: your_apple_key_id
- Private Key: your_apple_private_key
```

## ğŸ¨ UI/UX Ã–zellikleri

### DoÄŸa TemalÄ± TasarÄ±m
```tsx
// Gradient background
<LinearGradient colors={[primary, secondary, tertiary]}>
  {/* Decorative circles */}
  <View style={styles.decorativeCircle} />
</LinearGradient>

// Blur login container
<BlurView intensity={20} tint={isDark ? 'dark' : 'light'}>
  {/* Login content */}
</BlurView>
```

### Responsive Design
- Full screen experience
- Safe area handling
- Platform-specific components
- Theme-aware styling

## ğŸ”’ GÃ¼venlik Ã–zellikleri

### Session Management
- Automatic token refresh
- Secure storage (AsyncStorage)
- Session persistence
- Logout functionality

### Error Handling
```tsx
try {
  const { data, error } = await supabase.auth.signInWithOAuth({
    provider: 'google',
  });
  
  if (error) {
    Alert.alert('Hata', error.message);
    return;
  }
} catch (error) {
  Alert.alert('Hata', 'Beklenmeyen bir hata oluÅŸtu');
  console.error('Auth error:', error);
}
```

### User Cancellation Handling
```tsx
// Apple login cancellation
if (error.code === 'ERR_REQUEST_CANCELED') {
  // KullanÄ±cÄ± iptal etti, hata gÃ¶sterme
  return;
}
```

## ğŸ“Š State Management

### AuthContext Structure
```typescript
interface AuthContextType {
  session: Session | null;
  user: User | null;
  isLoading: boolean;
  initializeAuth: () => Promise<void>;
  signOut: () => Promise<void>;
}
```

### Auto Profile Creation
```typescript
// Yeni kullanÄ±cÄ± iÃ§in otomatik profil oluÅŸturma
if (error && error.code === 'PGRST116') {
  const { data: newUser } = await supabase
    .from('users')
    .insert([{
      id: session.user.id,
      email: session.user.email,
      display_name: session.user.user_metadata?.full_name || 
                   session.user.email?.split('@')[0],
      created_at: new Date().toISOString(),
    }])
    .select()
    .single();
}
```

## ğŸš€ Performance Optimizations

### Lazy Loading
- Auth state sadece gerektiÄŸinde yÃ¼klenir
- User profile async olarak fetch edilir
- Error boundaries ile crash prevention

### Memory Management
- Auth listeners otomatik cleanup
- Session state optimized updates
- Minimal re-renders

## ğŸ§ª Testing & Debugging

### Debug Logs
```typescript
console.log('Auth state changed:', event, session?.user?.email);
```

### Error Monitoring
- Comprehensive error logging
- User-friendly error messages
- Fallback mechanisms

## ğŸ“± Platform Support

### iOS
- Native Apple Sign In button
- Face ID/Touch ID integration
- iOS-specific styling

### Android
- Google OAuth integration
- Material Design compliance
- Android-specific handling

### Web
- OAuth popup flow
- Responsive design
- Cross-browser compatibility

## ğŸ¯ Best Practices

1. **Security First**: Hassas bilgileri environment variables'da saklayÄ±n
2. **User Experience**: Loading states ve error handling
3. **Performance**: Minimal re-renders ve efficient state management
4. **Accessibility**: Screen reader uyumluluÄŸu
5. **Testing**: Comprehensive error scenarios

Bu profesyonel auth sistemi Geliom'un gÃ¼venlik ve kullanÄ±cÄ± deneyimi standartlarÄ±nÄ± karÅŸÄ±lamak iÃ§in Ã¶zel olarak tasarlanmÄ±ÅŸtÄ±r. ğŸŒ¿ğŸ”
</file>

<file path="docs/project-mermaid.md">
```mermaid
erDiagram
    users {
        UUID id PK "auth.users'dan referans"
        TEXT custom_user_id UK
        TEXT display_name
        TEXT photo_url
        INT mood_id FK "moods tablosuna referans"
        BOOLEAN show_mood
        TEXT onesignal_player_id
        TIMESTAMPTZ updated_at
    }

    moods {
        INT id PK
        TEXT text UK
        TEXT emoji
    }

    groups {
        UUID id PK
        UUID owner_id FK
        TEXT type
        TEXT name
        TEXT invite_code UK
        INT member_limit
        TIMESTAMPTZ created_at
    }

    group_members {
        UUID group_id PK, FK
        UUID user_id PK, FK
        TIMESTAMPTZ joined_at
    }

    nicknames {
        UUID group_id PK, FK
        UUID setter_user_id PK, FK
        UUID target_user_id PK, FK
        TEXT nickname
    }

    statuses {
        INT id PK
        TEXT text
        BOOLEAN notifies
        BOOLEAN is_custom
        UUID owner_id FK "EÄŸer custom ise sahibi"
    }

    user_statuses {
        UUID user_id PK, FK
        INT status_id FK
        TIMESTAMPTZ updated_at
    }

    muted_notifications {
        UUID muter_user_id PK, FK
        UUID muted_user_id PK, FK
    }

    subscriptions {
        UUID user_id PK, FK
        TEXT status
        TIMESTAMPTZ expires_at
    }

    scheduled_events {
        UUID id PK
        UUID group_id FK
        UUID creator_id FK
        TEXT title
        TIMESTAMPTZ event_time
        TIMESTAMPTZ notification_time
        TIMESTAMPTZ created_at
    }

    users ||--|{ moods : "feels"
    users ||--o{ groups : "owns"
    users ||--o{ group_members : "participates in"
    groups ||--|{ group_members : "has"
    users ||--o{ nicknames : "sets nickname for"
    groups ||--|{ nicknames : "are set in"
    users ||--o{ user_statuses : "has status"
    statuses ||--o{ user_statuses : "is status type of"
    users ||--o{ muted_notifications : "mutes"
    users ||--o{ subscriptions : "has subscription"
    users ||--o{ scheduled_events : "creates"
    groups ||--|{ scheduled_events : "are scheduled in"


```
</file>

<file path="docs/rate-limiting-implementation.md">
# Rate Limiting Implementasyonu - TamamlandÄ± âœ…

## ğŸ“‹ YapÄ±lanlar

### 1. VeritabanÄ±
- âœ… `notification_rate_limits` tablosu SQL migration dosyasÄ± oluÅŸturuldu
- âœ… `check_rate_limit` database function oluÅŸturuldu
- âœ… `cleanup_old_rate_limits` temizleme function'Ä± oluÅŸturuldu
- âœ… Index'ler eklendi (performans iÃ§in)

**Dosya:** `docs/database-rate-limiting-migration.sql`

### 2. Edge Function
- âœ… `send-notification` Edge Function'a rate limiting eklendi
- âœ… Supabase client entegrasyonu
- âœ… Rate limit kontrolÃ¼ (her alÄ±cÄ± iÃ§in)
- âœ… HTTP 429 (Too Many Requests) response
- âœ… Bekleme sÃ¼resi bilgisi dÃ¶ndÃ¼rÃ¼lÃ¼yor

**Dosya:** `supabase/functions/send-notification/index.ts`

### 3. API Layer
- âœ… `api/notifications.ts` gÃ¼ncellendi
- âœ… `sender_id` ve `receiver_ids` parametreleri eklendi
- âœ… Rate limit hatasÄ± handling eklendi
- âœ… `api/groups.ts`'deki bildirim Ã§aÄŸrÄ±larÄ± gÃ¼ncellendi

**Dosyalar:**
- `api/notifications.ts`
- `api/groups.ts`

## ğŸš€ Kurulum AdÄ±mlarÄ±

### 1. VeritabanÄ± Migration'Ä± Ã‡alÄ±ÅŸtÄ±r
Supabase SQL Editor'de `docs/database-rate-limiting-migration.sql` dosyasÄ±nÄ± Ã§alÄ±ÅŸtÄ±r:

```sql
-- Tablo oluÅŸtur
-- Function'lar oluÅŸtur
-- Index'ler oluÅŸtur
```

### 2. Edge Function Environment Variables
Supabase Dashboard'da Edge Function environment variables ekle:

```
SUPABASE_URL=your-supabase-url
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
```

(Bu deÄŸiÅŸkenler genellikle otomatik olarak mevcuttur)

### 3. Edge Function Deploy
```bash
supabase functions deploy send-notification
```

## â±ï¸ Rate Limit KurallarÄ±

| Bildirim Tipi | Limit | SÃ¼re |
|--------------|-------|------|
| `join_request` | 1 istek | 5 dakika |
| `join_request_status` | 1 bildirim | 1 dakika |
| `direct_invite` | 1 davet | 10 dakika |
| `status_update` | 1 bildirim | 1 dakika |
| `mood_update` | 1 bildirim | 1 dakika |
| `event_reminder` | 1 bildirim | 60 dakika |

## ğŸ”§ NasÄ±l Ã‡alÄ±ÅŸÄ±r?

1. **Bildirim GÃ¶nderme Ä°steÄŸi:**
   - Client `sendNotification` fonksiyonunu Ã§aÄŸÄ±rÄ±r
   - `sender_id` ve `receiver_ids` parametreleri gÃ¶nderilir

2. **Edge Function KontrolÃ¼:**
   - `check_rate_limit` database function'Ä± Ã§aÄŸrÄ±lÄ±r
   - Son gÃ¶nderim zamanÄ± kontrol edilir
   - Limit aÅŸÄ±ldÄ±ysa HTTP 429 dÃ¶ndÃ¼rÃ¼lÃ¼r

3. **Rate Limit AÅŸÄ±ldÄ±ÄŸÄ±nda:**
   - HTTP 429 (Too Many Requests) response
   - `wait_until` ve `wait_seconds` bilgisi dÃ¶ndÃ¼rÃ¼lÃ¼r
   - Client'da hata mesajÄ± gÃ¶sterilir

4. **Rate Limit AÅŸÄ±lmadÄ±ÄŸÄ±nda:**
   - Bildirim gÃ¶nderilir
   - `notification_rate_limits` tablosu gÃ¼ncellenir
   - BaÅŸarÄ±lÄ± response dÃ¶ndÃ¼rÃ¼lÃ¼r

## ğŸ“ Notlar

- Rate limiting sadece `sender_id` ve `receiver_ids` gÃ¶nderildiÄŸinde aktif
- Sistem bildirimleri (event_reminder) iÃ§in rate limiting daha uzun (60 dakika)
- Eski kayÄ±tlar 24 saat sonra otomatik temizlenir
- Rate limit kontrolÃ¼ non-blocking (hata olsa bile bildirim gÃ¶nderilmeye Ã§alÄ±ÅŸÄ±lÄ±r)

## ğŸ§ª Test

1. AynÄ± kullanÄ±cÄ±ya 2 kez hÄ±zlÄ±ca bildirim gÃ¶nder
2. Ä°kinci istekte HTTP 429 hatasÄ± alÄ±nmalÄ±
3. Bekleme sÃ¼resi sonrasÄ± tekrar denemeli

## ğŸ”„ Sonraki AdÄ±mlar

- [ ] Realtime gÃ¼ncellemeleri ekle
- [ ] Client-side'da rate limit hatasÄ± iÃ§in UI iyileÅŸtirmesi
- [ ] Rate limit aÅŸÄ±mÄ± iÃ§in analytics/logging
</file>

<file path="docs/rate-limiting-plan.md">
# Rate Limiting PlanÄ± - Bildirim Spam Ã–nleme

## ğŸ¯ AmaÃ§
KullanÄ±cÄ±larÄ±n sÃ¼rekli bildirim gÃ¶ndermesini Ã¶nlemek ve sistem kaynaklarÄ±nÄ± korumak.

## ğŸ“‹ Rate Limit KurallarÄ±

### 1. KatÄ±lma Ä°steÄŸi GÃ¶nderme
- **Limit:** AynÄ± kullanÄ±cÄ± aynÄ± gruba **5 dakikada bir** istek gÃ¶nderebilir
- **Kontrol Yeri:** 
  - Client-side: `useCreateJoinRequest` hook'unda
  - Server-side: Database constraint (zaten var - UNIQUE constraint)
- **Hata MesajÄ±:** "Bu gruba yeni bir istek gÃ¶ndermek iÃ§in 5 dakika beklemeniz gerekiyor"

### 2. Bildirim GÃ¶nderme (OneSignal)
- **Limit:** AynÄ± gÃ¶nderen aynÄ± alÄ±cÄ±ya **1 dakikada bir** bildirim gÃ¶nderebilir
- **Kontrol Yeri:** Edge Function (`send-notification`)
- **Hata MesajÄ±:** "Ã‡ok sÄ±k bildirim gÃ¶nderiyorsunuz. LÃ¼tfen 1 dakika bekleyin"

### 3. KullanÄ±cÄ± Arama ve Direkt Davet
- **Limit:** AynÄ± gÃ¶nderen aynÄ± alÄ±cÄ±ya **10 dakikada bir** davet gÃ¶nderebilir
- **Kontrol Yeri:** 
  - Client-side: `useCreateJoinRequest` hook'unda (davet gÃ¶nderirken)
  - Server-side: Database'de rate limit kontrolÃ¼
- **Hata MesajÄ±:** "Bu kullanÄ±cÄ±ya yeni bir davet gÃ¶ndermek iÃ§in 10 dakika beklemeniz gerekiyor"

## ğŸ—„ï¸ VeritabanÄ± YapÄ±sÄ±

### `notification_rate_limits` Tablosu
```sql
CREATE TABLE public.notification_rate_limits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sender_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  receiver_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  group_id UUID REFERENCES groups(id) ON DELETE CASCADE,
  notification_type TEXT NOT NULL CHECK (notification_type IN (
    'join_request',
    'join_request_status',
    'direct_invite',
    'status_update',
    'mood_update',
    'event_reminder'
  )),
  last_sent_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(sender_id, receiver_id, group_id, notification_type)
);

-- Index'ler
CREATE INDEX idx_rate_limits_sender_receiver ON notification_rate_limits(sender_id, receiver_id);
CREATE INDEX idx_rate_limits_group ON notification_rate_limits(group_id);
CREATE INDEX idx_rate_limits_type ON notification_rate_limits(notification_type);
CREATE INDEX idx_rate_limits_last_sent ON notification_rate_limits(last_sent_at);
```

## ğŸ”§ Implementasyon Stratejisi

### 1. Edge Function'da Rate Limiting
- `send-notification` Edge Function'Ä±nda kontrol
- Database'den son gÃ¶nderim zamanÄ±nÄ± kontrol et
- Limit aÅŸÄ±ldÄ±ysa hata dÃ¶ndÃ¼r
- Limit aÅŸÄ±lmadÄ±ysa kayÄ±t gÃ¼ncelle/oluÅŸtur

### 2. Client-Side Kontrol (UX iÃ§in)
- HÄ±zlÄ± geri bildirim iÃ§in
- Server-side kontrolÃ¼ geÃ§emez (gÃ¼venlik iÃ§in)

### 3. Database Function (Opsiyonel)
- Rate limit kontrolÃ¼ iÃ§in helper function
- Otomatik temizleme (eski kayÄ±tlarÄ± sil)

## â±ï¸ Zaman Limitleri

| Ä°ÅŸlem | Limit | SÃ¼re |
|-------|-------|------|
| KatÄ±lma Ä°steÄŸi | 1 istek | 5 dakika |
| Bildirim GÃ¶nderme | 1 bildirim | 1 dakika |
| Direkt Davet | 1 davet | 10 dakika |

## ğŸš¨ Hata YÃ¶netimi

### Rate Limit AÅŸÄ±ldÄ±ÄŸÄ±nda
1. **Edge Function:** HTTP 429 (Too Many Requests) dÃ¶ndÃ¼r
2. **Client:** KullanÄ±cÄ±ya anlaÅŸÄ±lÄ±r mesaj gÃ¶ster
3. **Log:** Rate limit aÅŸÄ±mÄ±nÄ± logla (analytics iÃ§in)

### KullanÄ±cÄ± Deneyimi
- Kalan sÃ¼reyi gÃ¶ster (Ã¶rn: "3 dakika 45 saniye sonra tekrar deneyebilirsiniz")
- Toast mesajÄ± ile bilgilendir
- Buton'u disable et (kalan sÃ¼re boyunca)

## ğŸ”„ Temizleme Stratejisi

### Otomatik Temizleme
- 24 saatten eski kayÄ±tlarÄ± otomatik sil
- Cron job veya database function ile
- Performans iÃ§in gerekli

## ğŸ“ Notlar

- Rate limiting sadece bildirim gÃ¶nderme iÃ§in deÄŸil, spam Ã¶nleme iÃ§in de kullanÄ±lÄ±r
- FarklÄ± bildirim tipleri iÃ§in farklÄ± limitler olabilir
- Premium kullanÄ±cÄ±lar iÃ§in daha yÃ¼ksek limitler dÃ¼ÅŸÃ¼nÃ¼lebilir (gelecekte)
</file>

<file path="docs/realtime-implementation-summary.md">
# Realtime Implementation Summary

## âœ… YapÄ±lan DeÄŸiÅŸiklikler

### 1. Database Fixes (SQL Migration)

**Dosya:** `docs/database-realtime-fix.sql`

- âœ… `REPLICA IDENTITY FULL` ayarÄ± eklendi (composite key'li tablolar iÃ§in kritik)
- âœ… `supabase_realtime` publication'a tablolar eklendi
- âœ… Kontrol sorgularÄ± eklendi

**Ã‡alÄ±ÅŸtÄ±rÄ±lmasÄ± Gereken SQL:**
```sql
-- docs/database-realtime-fix.sql dosyasÄ±ndaki tÃ¼m komutlarÄ± Ã§alÄ±ÅŸtÄ±rÄ±n
```

### 2. Optimistic Updates

**Dosyalar:** `api/statuses.ts`, `api/moods.ts`

- âœ… `useSetUserStatus` ve `useSetUserGroupMood` mutation'larÄ±na `onMutate` eklendi
- âœ… KullanÄ±cÄ± butona basar basmaz UI gÃ¼ncelleniyor (sunucu cevabÄ±nÄ± beklemeden)
- âœ… `onError` ile rollback mekanizmasÄ± eklendi
- âœ… `onSettled` ile son durum kontrolÃ¼ eklendi

### 3. Realtime Hooks Refactoring

**Dosyalar:** `api/statuses.ts`, `api/moods.ts`

- âœ… **Client-side filtering:** Server-side filter kaldÄ±rÄ±ldÄ±, client-side filtering eklendi
- âœ… **Direct cache updates:** `queryClient.setQueryData` ile direkt cache gÃ¼ncelleme
- âœ… **Improved error handling:** Daha detaylÄ± log'lar ve hata yÃ¶netimi
- âœ… **Channel cleanup:** Proper cleanup fonksiyonlarÄ±

### 4. Supabase Client Configuration

**Dosya:** `api/supabase.ts`

- âœ… Realtime config eklendi (`eventsPerSecond: 10`)

## ğŸ“‹ YapÄ±lmasÄ± Gerekenler

### 1. SQL Migration Ã‡alÄ±ÅŸtÄ±rma (KRÄ°TÄ°K)

Supabase SQL Editor'de `docs/database-realtime-fix.sql` dosyasÄ±ndaki komutlarÄ± Ã§alÄ±ÅŸtÄ±rÄ±n:

```sql
-- REPLICA IDENTITY FULL ayarlarÄ±
ALTER TABLE public.user_statuses REPLICA IDENTITY FULL;
ALTER TABLE public.user_group_moods REPLICA IDENTITY FULL;
ALTER TABLE public.group_members REPLICA IDENTITY FULL;
ALTER TABLE public.group_join_requests REPLICA IDENTITY FULL;
ALTER TABLE public.groups REPLICA IDENTITY FULL;
ALTER TABLE public.users REPLICA IDENTITY FULL;

-- Publication'a tablolarÄ± ekle (eÄŸer yoksa)
ALTER PUBLICATION supabase_realtime ADD TABLE public.user_statuses;
ALTER PUBLICATION supabase_realtime ADD TABLE public.user_group_moods;
-- ... (diÄŸer tablolar)
```

### 2. Test SenaryolarÄ±

1. **Optimistic Update Test:**
   - Bir kullanÄ±cÄ± status deÄŸiÅŸtirsin
   - UI hemen gÃ¼ncellenmeli (sunucu cevabÄ±nÄ± beklemeden)
   - Sunucu cevabÄ± geldiÄŸinde gerÃ§ek data ile senkronize olmalÄ±

2. **Realtime Update Test:**
   - Ä°ki kullanÄ±cÄ± aynÄ± grupta olsun
   - Bir kullanÄ±cÄ± status deÄŸiÅŸtirsin
   - DiÄŸer kullanÄ±cÄ±nÄ±n ekranÄ±nda anÄ±nda gÃ¼ncellenmeli
   - Console'da `ğŸ”„ Realtime status update` log'u gÃ¶rÃ¼nmeli

3. **Error Handling Test:**
   - Network kesilirse, optimistic update rollback olmalÄ±
   - Realtime subscription kapanÄ±rsa, log'da uyarÄ± gÃ¶rÃ¼nmeli

## ğŸ” Debug Checklist

- [ ] SQL migration Ã§alÄ±ÅŸtÄ±rÄ±ldÄ± mÄ±?
- [ ] `REPLICA IDENTITY FULL` ayarlarÄ± doÄŸru mu? (Kontrol sorgusu ile)
- [ ] Tablolar `supabase_realtime` publication'da mÄ±? (Kontrol sorgusu ile)
- [ ] Realtime subscription `SUBSCRIBED` durumunda mÄ±?
- [ ] `ğŸ”„ Realtime status update` log'u gÃ¶rÃ¼nÃ¼yor mu?
- [ ] Optimistic update Ã§alÄ±ÅŸÄ±yor mu? (UI hemen gÃ¼ncelleniyor mu?)

## ğŸ“ Notlar

- **REPLICA IDENTITY FULL:** Composite key'li tablolarda UPDATE/DELETE iÅŸlemlerinin Realtime'da Ã§alÄ±ÅŸmasÄ± iÃ§in **kritik**
- **Client-side filtering:** NULL deÄŸerler ve karmaÅŸÄ±k filtreler iÃ§in daha gÃ¼venilir
- **Direct cache updates:** `invalidateQueries` yerine `setQueryData` kullanarak daha hÄ±zlÄ± UI update
- **Optimistic updates:** KullanÄ±cÄ± deneyimini Ã¶nemli Ã¶lÃ§Ã¼de iyileÅŸtirir

## ğŸ› Bilinen Sorunlar

- Åu an yok (test edildikten sonra gÃ¼ncellenecek)
</file>

<file path="docs/realtime-join-requests.md">
# Realtime Join Requests - Implementasyon

## âœ… Tamamlanan Ä°ÅŸler

### 1. Realtime Hook'larÄ±
- âœ… `useGroupJoinRequestsRealtime` - Grup iÃ§in katÄ±lma isteklerini dinler
- âœ… `useMyJoinRequestsRealtime` - KullanÄ±cÄ±nÄ±n kendi isteklerini dinler

### 2. Entegrasyon
- âœ… `join-requests.tsx` ekranÄ±na realtime hook eklendi
- âœ… `DashboardView.tsx`'e realtime hook eklendi (badge sayÄ±sÄ± anlÄ±k gÃ¼ncellenir)
- âœ… Export'lar `api/index.ts`'e eklendi

## ğŸ”§ NasÄ±l Ã‡alÄ±ÅŸÄ±r?

### Grup Kurucusu Ä°Ã§in
1. `useGroupJoinRequestsRealtime(groupId)` hook'u Ã§aÄŸrÄ±lÄ±r
2. Supabase Realtime `group_join_requests` tablosunu dinler
3. Yeni istek geldiÄŸinde veya istek durumu deÄŸiÅŸtiÄŸinde:
   - Query cache invalidate edilir
   - UI otomatik gÃ¼ncellenir
   - Badge sayÄ±sÄ± anlÄ±k gÃ¼ncellenir

### Ä°stek Sahibi Ä°Ã§in
1. `useMyJoinRequestsRealtime(userId)` hook'u Ã§aÄŸrÄ±lÄ±r
2. Supabase Realtime kullanÄ±cÄ±nÄ±n isteklerini dinler
3. Ä°stek onaylandÄ±ÄŸÄ±nda/reddedildiÄŸinde:
   - Query cache invalidate edilir
   - UI otomatik gÃ¼ncellenir

## ğŸ“ KullanÄ±m Yerleri

### 1. KatÄ±lma Ä°stekleri EkranÄ± (`join-requests.tsx`)
```typescript
useGroupJoinRequestsRealtime(groupId);
```
- Grup kurucusu yeni istekleri anÄ±nda gÃ¶rÃ¼r
- Ä°stek durumu deÄŸiÅŸikliklerini anÄ±nda gÃ¶rÃ¼r

### 2. Dashboard View (`DashboardView.tsx`)
```typescript
useGroupJoinRequestsRealtime(group.id);
```
- Badge sayÄ±sÄ± anlÄ±k gÃ¼ncellenir
- Yeni istek geldiÄŸinde sayÄ± artar

## ğŸ¯ Faydalar

1. **AnlÄ±k GÃ¼ncelleme:** Sayfa yenilemeye gerek yok
2. **Daha Ä°yi UX:** KullanÄ±cÄ± deÄŸiÅŸiklikleri hemen gÃ¶rÃ¼r
3. **Performans:** Sadece deÄŸiÅŸen veriler gÃ¼ncellenir
4. **Otomatik:** Manuel refresh'e gerek yok

## ğŸ“ Notlar

- Realtime subscription'lar otomatik olarak cleanup edilir (component unmount olduÄŸunda)
- Query cache invalidate edildiÄŸinde React Query otomatik refetch yapar
- Rate limiting ile birlikte Ã§alÄ±ÅŸÄ±r (spam Ã¶nleme)
</file>

<file path="docs/realtime-tables-list.md">
# Realtime Ã–zelliÄŸi AÃ§Ä±k OlmasÄ± Gereken Tablolar

Bu dokÃ¼mantasyon, Supabase'de Realtime Ã¶zelliÄŸinin aÃ§Ä±k olmasÄ± gereken tablolarÄ± listeler. Bu tablolar, uygulama iÃ§inde anlÄ±k gÃ¼ncellemeler iÃ§in kullanÄ±lmaktadÄ±r.

## Supabase Dashboard'da Realtime AÃ§ma

1. **Supabase Dashboard** â†’ **Database** â†’ **Replication** bÃ¶lÃ¼mÃ¼ne gidin
2. Her tablo iÃ§in **Realtime** toggle'Ä±nÄ± **AÃ‡IK** yapÄ±n
3. Veya SQL ile:
   ```sql
   ALTER PUBLICATION supabase_realtime ADD TABLE table_name;
   ```

## Realtime AÃ§Ä±k OlmasÄ± Gereken Tablolar

### 1. **groups** âœ…
- **KullanÄ±m:** Grup bilgileri gÃ¼ncellemeleri
- **Hook:** `useGroupsRealtime`
- **Dosya:** `api/groups.ts`
- **AÃ§Ä±klama:** Grup bilgileri (name, owner_id, vb.) deÄŸiÅŸtiÄŸinde anlÄ±k gÃ¼ncelleme

### 2. **group_members** âœ…
- **KullanÄ±m:** Grup Ã¼yelik deÄŸiÅŸiklikleri
- **Hook:** `useGroupMembersRealtime`
- **Dosya:** `api/groups.ts`
- **AÃ§Ä±klama:** KullanÄ±cÄ± gruba katÄ±ldÄ±ÄŸÄ±nda/ayrÄ±ldÄ±ÄŸÄ±nda anlÄ±k gÃ¼ncelleme

### 3. **group_join_requests** âœ…
- **KullanÄ±m:** Grup katÄ±lma istekleri
- **Hook:** `useGroupJoinRequestsRealtime`, `useMyJoinRequestsRealtime`
- **Dosya:** `api/groups.ts`
- **AÃ§Ä±klama:** KatÄ±lma istekleri oluÅŸturulduÄŸunda/onaylandÄ±ÄŸÄ±nda/reddedildiÄŸinde anlÄ±k gÃ¼ncelleme

### 4. **statuses** âœ…
- **KullanÄ±m:** Status tanÄ±mlarÄ± (default ve custom)
- **Hook:** `useStatusesRealtime`
- **Dosya:** `api/statuses.ts`
- **AÃ§Ä±klama:** Status tanÄ±mlarÄ± deÄŸiÅŸtiÄŸinde anlÄ±k gÃ¼ncelleme (custom status oluÅŸturma/gÃ¼ncelleme)

### 5. **user_statuses** âœ…
- **KullanÄ±m:** KullanÄ±cÄ± status'larÄ± (grup bazlÄ±)
- **Hook:** `useGroupStatusesRealtime`, `useUserStatusesRealtime`
- **Dosya:** `api/statuses.ts`
- **AÃ§Ä±klama:** KullanÄ±cÄ± status'u deÄŸiÅŸtiÄŸinde anlÄ±k gÃ¼ncelleme (en Ã¶nemli realtime Ã¶zelliÄŸi)

### 6. **moods** âœ…
- **KullanÄ±m:** Mood tanÄ±mlarÄ± (default ve custom)
- **Hook:** `useMoodsRealtime`
- **Dosya:** `api/moods.ts`
- **AÃ§Ä±klama:** Mood tanÄ±mlarÄ± deÄŸiÅŸtiÄŸinde anlÄ±k gÃ¼ncelleme (custom mood oluÅŸturma/gÃ¼ncelleme)

### 7. **user_group_moods** âœ…
- **KullanÄ±m:** KullanÄ±cÄ± mood'larÄ± (grup bazlÄ±)
- **Hook:** `useGroupMoodsRealtime`
- **Dosya:** `api/moods.ts`
- **AÃ§Ä±klama:** KullanÄ±cÄ± mood'u deÄŸiÅŸtiÄŸinde anlÄ±k gÃ¼ncelleme (en Ã¶nemli realtime Ã¶zelliÄŸi)

### 8. **nicknames** âœ…
- **KullanÄ±m:** KullanÄ±cÄ± takma adlarÄ± (grup bazlÄ±)
- **Hook:** `useNicknamesRealtime`
- **Dosya:** `api/nicknames.ts`
- **AÃ§Ä±klama:** Takma ad oluÅŸturulduÄŸunda/gÃ¼ncellendiÄŸinde/silindiÄŸinde anlÄ±k gÃ¼ncelleme

### 9. **scheduled_events** âœ…
- **KullanÄ±m:** PlanlanmÄ±ÅŸ etkinlikler
- **Hook:** `useGroupEventsRealtime`, `useEventsRealtime`
- **Dosya:** `api/events.ts`
- **AÃ§Ä±klama:** Etkinlik oluÅŸturulduÄŸunda/gÃ¼ncellendiÄŸinde/silindiÄŸinde anlÄ±k gÃ¼ncelleme

### 10. **subscriptions** âœ…
- **KullanÄ±m:** KullanÄ±cÄ± abonelikleri
- **Hook:** `useSubscriptionRealtime`
- **Dosya:** `api/subscriptions.ts`
- **AÃ§Ä±klama:** Abonelik durumu deÄŸiÅŸtiÄŸinde anlÄ±k gÃ¼ncelleme (premium Ã¶zellikler iÃ§in)

### 11. **muted_notifications** âš ï¸
- **KullanÄ±m:** Sessize alÄ±nmÄ±ÅŸ bildirimler
- **Hook:** Åu an realtime hook yok (gelecekte eklenebilir)
- **Dosya:** `api/muted.ts`
- **AÃ§Ä±klama:** Åu an realtime kullanÄ±lmÄ±yor ama gelecekte eklenebilir

### âŒ **users** (KaldÄ±rÄ±ldÄ±)
- **Neden KaldÄ±rÄ±ldÄ±:** KullanÄ±cÄ± profil gÃ¼ncellemeleri (display_name, photo_url) nadiren olur ve kritik deÄŸil
- **Hook:** `useUsersRealtime` tanÄ±mlÄ± ama hiÃ§bir yerde kullanÄ±lmÄ±yor
- **Not:** Ä°leride gerekirse eklenebilir, ÅŸu an gereksiz

## Ã–ncelik SÄ±rasÄ±

### YÃ¼ksek Ã–ncelik (Kritik)
1. **user_statuses** - Status deÄŸiÅŸiklikleri anlÄ±k yansÄ±malÄ±
2. **user_group_moods** - Mood deÄŸiÅŸiklikleri anlÄ±k yansÄ±malÄ±
3. **group_members** - Ãœyelik deÄŸiÅŸiklikleri anlÄ±k yansÄ±malÄ±
4. **group_join_requests** - KatÄ±lma istekleri anlÄ±k yansÄ±malÄ±

### Orta Ã–ncelik
5. **groups** - Grup bilgileri deÄŸiÅŸiklikleri
6. **nicknames** - Takma ad deÄŸiÅŸiklikleri

### DÃ¼ÅŸÃ¼k Ã–ncelik
8. **statuses** - Status tanÄ±mlarÄ± (nadiren deÄŸiÅŸir)
9. **moods** - Mood tanÄ±mlarÄ± (nadiren deÄŸiÅŸir)
10. **scheduled_events** - Etkinlik deÄŸiÅŸiklikleri
11. **subscriptions** - Abonelik durumu (nadiren deÄŸiÅŸir)

## SQL KomutlarÄ± (Toplu AÃ§ma)

TÃ¼m tablolarÄ± tek seferde aÃ§mak iÃ§in:

```sql
-- Realtime Ã¶zelliÄŸini tÃ¼m tablolara ekle
ALTER PUBLICATION supabase_realtime ADD TABLE groups;
ALTER PUBLICATION supabase_realtime ADD TABLE group_members;
ALTER PUBLICATION supabase_realtime ADD TABLE group_join_requests;
ALTER PUBLICATION supabase_realtime ADD TABLE statuses;
ALTER PUBLICATION supabase_realtime ADD TABLE user_statuses;
ALTER PUBLICATION supabase_realtime ADD TABLE moods;
ALTER PUBLICATION supabase_realtime ADD TABLE user_group_moods;
ALTER PUBLICATION supabase_realtime ADD TABLE nicknames;
ALTER PUBLICATION supabase_realtime ADD TABLE scheduled_events;
ALTER PUBLICATION supabase_realtime ADD TABLE subscriptions;
ALTER PUBLICATION supabase_realtime ADD TABLE muted_notifications;
-- Not: users tablosu kaldÄ±rÄ±ldÄ± (gereksiz, useUsersRealtime hiÃ§bir yerde kullanÄ±lmÄ±yor)
```

## Kontrol Etme

Realtime'Ä±n aÃ§Ä±k olup olmadÄ±ÄŸÄ±nÄ± kontrol etmek iÃ§in:

```sql
-- TÃ¼m realtime tablolarÄ±nÄ± listele
SELECT 
  schemaname,
  tablename
FROM pg_publication_tables
WHERE pubname = 'supabase_realtime'
ORDER BY tablename;
```

## Notlar

- **RLS (Row Level Security):** Realtime Ã¶zelliÄŸi RLS ile uyumlu Ã§alÄ±ÅŸÄ±r
- **Performans:** Realtime subscription'lar performansÄ± etkileyebilir, sadece gerekli tablolarda aÃ§Ä±n
- **GÃ¼venlik:** Realtime aÃ§Ä±k olan tablolar, client-side'dan dinlenebilir (RLS ile korunmalÄ±)
- **Muted Notifications:** Åu an realtime kullanÄ±lmÄ±yor ama gelecekte eklenebilir
</file>

<file path="docs/realtime-troubleshooting.md">
# Realtime Troubleshooting

## Sorun: Realtime Subscription Kuruluyor Ama Payload Gelmiyor

### Belirtiler
- âœ… `ğŸ“¡ Realtime subscription status: SUBSCRIBED` gÃ¶rÃ¼nÃ¼yor
- âœ… `âœ… Realtime subscription baÅŸarÄ±yla kuruldu` gÃ¶rÃ¼nÃ¼yor
- âŒ `ğŸ”„ Realtime status update` log'u gÃ¶rÃ¼nmÃ¼yor
- âŒ Database'de deÄŸiÅŸiklik yapÄ±ldÄ±ÄŸÄ±nda realtime payload gelmiyor

### OlasÄ± Nedenler

#### 1. Tablo Realtime Publication'da DeÄŸil (EN YAYGIN)

Supabase'de bir tablonun realtime Ã§alÄ±ÅŸmasÄ± iÃ§in `supabase_realtime` publication'Ä±na eklenmesi gerekir.

**Kontrol:**
```sql
-- Hangi tablolar realtime'da?
SELECT 
  schemaname,
  tablename
FROM pg_publication_tables
WHERE pubname = 'supabase_realtime'
ORDER BY tablename;
```

**Ã‡Ã¶zÃ¼m:**
```sql
-- user_statuses tablosunu realtime'a ekle
ALTER PUBLICATION supabase_realtime ADD TABLE user_statuses;

-- user_group_moods tablosunu realtime'a ekle
ALTER PUBLICATION supabase_realtime ADD TABLE user_group_moods;
```

#### 2. Supabase Dashboard'da Realtime KapalÄ±

**Kontrol:**
1. Supabase Dashboard â†’ Database â†’ Replication
2. `user_statuses` ve `user_group_moods` tablolarÄ±nda Realtime toggle'Ä± **AÃ‡IK** olmalÄ±

**Ã‡Ã¶zÃ¼m:**
- Dashboard'dan toggle'Ä± aÃ§Ä±n
- Veya yukarÄ±daki SQL komutlarÄ±nÄ± Ã§alÄ±ÅŸtÄ±rÄ±n

#### 3. Filter Problemi

Realtime filter'larÄ± bazen Ã§alÄ±ÅŸmayabilir. Test iÃ§in filter'Ä± kaldÄ±rÄ±p tÃ¼m deÄŸiÅŸiklikleri dinleyin:

```typescript
// Test iÃ§in filter olmadan
.on(
  'postgres_changes',
  {
    event: '*',
    schema: 'public',
    table: 'user_statuses',
    // filter: `group_id=eq.${groupId}`, // GeÃ§ici olarak kaldÄ±r
  },
  (payload) => {
    console.log('ğŸ”„ Realtime status update (ALL):', payload);
  }
)
```

#### 4. RLS (Row Level Security) Problemi

RLS aÃ§Ä±ksa, kullanÄ±cÄ±larÄ±n realtime event'lerini gÃ¶rebilmesi iÃ§in policy'ler gerekir.

**Kontrol:**
```sql
-- RLS aÃ§Ä±k mÄ±?
SELECT tablename, rowsecurity 
FROM pg_tables 
WHERE schemaname = 'public' 
  AND tablename IN ('user_statuses', 'user_group_moods');
```

**Not:** Åu an RLS kapalÄ±, bu sorun deÄŸil.

### Test AdÄ±mlarÄ±

1. **Publication KontrolÃ¼:**
   ```sql
   SELECT tablename 
   FROM pg_publication_tables 
   WHERE pubname = 'supabase_realtime' 
     AND tablename IN ('user_statuses', 'user_group_moods');
   ```

2. **Manuel Test:**
   - Supabase Dashboard â†’ Table Editor â†’ `user_statuses`
   - Bir kaydÄ± gÃ¼ncelleyin
   - Console'da `ğŸ”„ Realtime status update` log'u gÃ¶rÃ¼nmeli

3. **Subscription Durumu:**
   - Console'da `ğŸ“¡ Realtime subscription status: SUBSCRIBED` gÃ¶rÃ¼nmeli
   - EÄŸer `CHANNEL_ERROR`, `TIMED_OUT` veya `CLOSED` gÃ¶rÃ¼yorsanÄ±z, baÄŸlantÄ± sorunu var

### Ã‡Ã¶zÃ¼m Ã–nceliÄŸi

1. **Ã–NCE:** `ALTER PUBLICATION supabase_realtime ADD TABLE user_statuses;` Ã§alÄ±ÅŸtÄ±rÄ±n
2. **SONRA:** `ALTER PUBLICATION supabase_realtime ADD TABLE user_group_moods;` Ã§alÄ±ÅŸtÄ±rÄ±n
3. **TEST:** Bir status deÄŸiÅŸtirin ve `ğŸ”„ Realtime status update` log'unu kontrol edin

### Notlar

- Realtime subscription kurulduktan sonra (`SUBSCRIBED`), database'deki deÄŸiÅŸiklikler otomatik olarak payload olarak gelmelidir
- EÄŸer payload gelmiyorsa, tablo publication'da deÄŸildir veya Supabase Realtime servisi Ã§alÄ±ÅŸmÄ±yordur
- Filter'lar (`group_id=eq.${groupId}`) sadece payload'Ä± filtreler, subscription'Ä± engellemez
</file>

<file path="docs/status-notification-system.md">
# Status Bildirim Sistemi

## Genel BakÄ±ÅŸ

Status deÄŸiÅŸikliÄŸinde grup Ã¼yelerine bildirim gÃ¶nderilir. Bildirimler kuyruÄŸa alÄ±nÄ±r ve minimum 1 dakika sonra gÃ¶nderilir.

## Ã–zellikler

1. **Kuyruk Sistemi:** Status deÄŸiÅŸikliÄŸinde bildirim hemen gÃ¶nderilmez, kuyruÄŸa alÄ±nÄ±r
2. **Debounce Pattern:** KullanÄ±cÄ± sÃ¼rekli status deÄŸiÅŸtirirse, sadece son status iÃ§in bildirim gÃ¶nderilir
3. **Mesaj Sistemi:** Her status iÃ§in Ã¶zelleÅŸtirilebilir mesajlar (messages array)
4. **Placeholder DesteÄŸi:** `{name}` ve `{group}` placeholder'larÄ± desteklenir
5. **Rate Limiting:** 1 dakika iÃ§inde aynÄ± alÄ±cÄ±ya tekrar bildirim gÃ¶nderilmez

## VeritabanÄ± YapÄ±sÄ±

### statuses Tablosu
- `messages TEXT[]` - Bildirim mesajlarÄ± (rastgele seÃ§ilecek)

### pending_notifications Tablosu
- `id UUID PK`
- `sender_id UUID FK` - Status deÄŸiÅŸtiren kullanÄ±cÄ±
- `receiver_ids UUID[]` - Grup Ã¼yeleri (kendisi hariÃ§)
- `group_id UUID FK`
- `status_id INT FK`
- `scheduled_at TIMESTAMPTZ` - GÃ¶nderilecek zaman (created_at + 1 dakika)
- `created_at TIMESTAMPTZ`
- `updated_at TIMESTAMPTZ`
- Unique constraint: `(sender_id, group_id)` - Bir kullanÄ±cÄ±nÄ±n aynÄ± grup iÃ§in sadece 1 pending bildirimi

## AkÄ±ÅŸ

1. **Status DeÄŸiÅŸikliÄŸi:**
   - KullanÄ±cÄ± status'unu deÄŸiÅŸtirir
   - `useSetUserStatus` hook'u Ã§alÄ±ÅŸÄ±r
   - Status gÃ¼ncellenir
   - EÄŸer `notifies: true` ise:
     - Grup Ã¼yeleri bulunur (kendisi hariÃ§)
     - `pending_notifications` tablosuna kayÄ±t eklenir/gÃ¼ncellenir
     - `scheduled_at = NOW() + 1 dakika`

2. **Bildirim GÃ¶nderme (Cron Job):**
   - Her dakika `process-pending-notifications` Edge Function Ã§alÄ±ÅŸÄ±r
   - `scheduled_at <= NOW()` olan kayÄ±tlar bulunur
   - Her kayÄ±t iÃ§in:
     - Status mesajlarÄ±ndan rastgele bir mesaj seÃ§ilir
     - Placeholder'lar deÄŸiÅŸtirilir (`{name}`, `{group}`)
     - `send-notification` Edge Function'Ä± Ã§aÄŸrÄ±lÄ±r
     - Rate limiting kontrolÃ¼ yapÄ±lÄ±r
     - Bildirim gÃ¶nderilir
     - KayÄ±t silinir

## Mesaj FormatÄ±

### Placeholder'lar
- `{name}` â†’ KullanÄ±cÄ± adÄ± (display_name veya custom_user_id)
- `{group}` â†’ Grup adÄ±

### Ã–rnek Mesajlar
```json
[
  "{name} artÄ±k mÃ¼sait!",
  "{name} ÅŸimdi mÃ¼sait durumda",
  "{name} {group} grubunda mÃ¼sait oldu"
]
```

### Default Mesaj
EÄŸer `messages` array'i boÅŸsa veya yoksa:
```
"{name} durumunu gÃ¼ncelledi"
```

## Debounce MantÄ±ÄŸÄ±

- KullanÄ±cÄ± status deÄŸiÅŸtirdiÄŸinde:
  - EÄŸer mevcut bir `pending_notification` varsa â†’ UPDATE (scheduled_at gÃ¼ncellenir)
  - Yoksa â†’ INSERT
- Unique constraint sayesinde bir kullanÄ±cÄ±nÄ±n aynÄ± grup iÃ§in sadece 1 pending bildirimi olabilir
- SÃ¼rekli status deÄŸiÅŸtirirse, sadece son status iÃ§in bildirim gÃ¶nderilir

## Rate Limiting

- `send-notification` Edge Function'Ä±nda rate limiting kontrolÃ¼ yapÄ±lÄ±r
- Status update iÃ§in 1 dakika limit
- EÄŸer rate limit aÅŸÄ±ldÄ±ysa:
  - `scheduled_at` 1 dakika sonraya gÃ¼ncellenir
  - Bir sonraki cron job'da tekrar denenecek

## Dosyalar

- `docs/database-migration-status-notifications.sql` - Database migration
- `api/statuses.ts` - Status gÃ¼ncelleme ve pending notification oluÅŸturma
- `supabase/functions/process-pending-notifications/index.ts` - Cron job Edge Function
- `supabase/functions/send-notification/index.ts` - Bildirim gÃ¶nderme (mevcut)
- `types/database.ts` - TypeScript type tanÄ±mlarÄ±
- `docs/cron-job-setup.md` - Cron job kurulum rehberi

## Test SenaryolarÄ±

1. âœ… Status deÄŸiÅŸtir â†’ 1 dakika sonra bildirim gÃ¶nder
2. âœ… Status deÄŸiÅŸtir â†’ 30 saniye sonra tekrar deÄŸiÅŸtir â†’ Sadece son status iÃ§in bildirim gÃ¶nder
3. âœ… SÃ¼rekli tÄ±klama â†’ Sadece son status iÃ§in bildirim gÃ¶nder
4. âœ… Mesaj placeholder'larÄ± doÄŸru deÄŸiÅŸtirilsin
5. âœ… `notifies: false` olan status'ler iÃ§in bildirim gÃ¶nderilmesin
6. âœ… FarklÄ± gruplarda status deÄŸiÅŸtir â†’ Her grup iÃ§in ayrÄ± bildirim
</file>

<file path="docs/supabase-oauth-setup.md">
# Supabase Google OAuth YapÄ±landÄ±rma KÄ±lavuzu

## Hata: "invalid_client" veya "the OAuth client was not found"

Bu hata, Google Cloud Console'da OAuth client'Ä±n dÃ¼zgÃ¼n yapÄ±landÄ±rÄ±lmadÄ±ÄŸÄ±nÄ± veya Supabase'de yanlÄ±ÅŸ credentials kullanÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶sterir.

## Ã–nemli: Firebase vs Supabase OAuth

Firebase'de oluÅŸturduÄŸunuz OAuth credentials'larÄ± Supabase'de de kullanabilirsiniz, Ã§Ã¼nkÃ¼ ikisi de Google Cloud Console'u kullanÄ±r. 

**Firebase'in oluÅŸturduÄŸu OAuth client'larÄ±:**
- `google-services.json` dosyasÄ±nda `client_type: 3` olan client = **Web application** (Supabase iÃ§in kullanÄ±labilir)
- Bu client'Ä±n **Client ID**'si zaten var
- **Client Secret**'Ä± Google Cloud Console'dan gÃ¶rebilir veya reset edebilirsiniz

**Neden Client Secret gerekli?**
- Firebase native SDK kullanÄ±r â†’ Secret gerektirmez (SHA-1 ile doÄŸrulanÄ±r)
- Supabase web-based OAuth kullanÄ±r â†’ Server-side doÄŸrulama iÃ§in secret gerektirir
- AynÄ± OAuth client'Ä± kullanabilirsiniz, sadece secret'Ä± eklemeniz gerekir

## AdÄ±m AdÄ±m YapÄ±landÄ±rma

### 1. Mevcut Firebase OAuth Client'Ä±nÄ± Kullanma (Ã–nerilen)

Firebase'in oluÅŸturduÄŸu OAuth client'Ä± kullanabilirsiniz! `google-services.json` dosyanÄ±zda `client_type: 3` olan Web client var.

**SeÃ§enek A: Mevcut Web Client'Ä±n Secret'Ä±nÄ± GÃ¶rme/Reset Etme**

1. [Google Cloud Console](https://console.cloud.google.com/) â†’ `geliom-8d06f` projesini seÃ§in
2. **APIs & Services** â†’ **Credentials**
3. OAuth 2.0 Client IDs listesinde **Web client** bulun (Client ID: `53336710716-ocrnuvqlpq02lvss0hvjgeqc08539sqm.apps.googleusercontent.com`)
4. Client'Ä± tÄ±klayÄ±n
5. **Authorized redirect URIs** bÃ¶lÃ¼mÃ¼ne ÅŸunu ekleyin:
   ```
   https://jtqmntczxkdmftoqspdx.supabase.co/auth/v1/callback
   ```
6. **SAVE** butonuna tÄ±klayÄ±n
7. **Client Secret**'Ä± gÃ¶rmek iÃ§in:
   - EÄŸer secret gÃ¶sterilmiyorsa â†’ **RESET SECRET** butonuna tÄ±klayÄ±n
   - Yeni secret'Ä± kopyalayÄ±n (sadece bir kez gÃ¶sterilir!)
   - **DÄ°KKAT**: Secret'Ä± reset ederseniz, Firebase'deki mevcut kullanÄ±mlar etkilenmez (Firebase native SDK secret kullanmaz)

**SeÃ§enek B: Yeni OAuth Client OluÅŸturma (Ä°sterseniz)**

1. [Google Cloud Console](https://console.cloud.google.com/) â†’ `geliom-8d06f` projesini seÃ§in
2. **APIs & Services** â†’ **Credentials**
3. **Create Credentials** â†’ **OAuth client ID**
4. Application type: **Web application**
5. **Name**: "Supabase OAuth" (veya istediÄŸiniz bir isim)
6. **Authorized redirect URIs** ekleyin:
   ```
   https://jtqmntczxkdmftoqspdx.supabase.co/auth/v1/callback
   ```
   **NOT**: `geliom://auth/callback` eklemeyin! Google Cloud Console Web application type'Ä±nda sadece HTTPS URL'leri kabul eder.
7. **Create** butonuna tÄ±klayÄ±n
8. **Ã–NEMLÄ°**: AÃ§Ä±lan popup'ta **Client ID** ve **Client Secret**'Ä± hemen kopyalayÄ±n

### 2. Supabase Dashboard'da Google OAuth Ayarlama

1. [Supabase Dashboard](https://app.supabase.com/) â†’ Projenizi seÃ§in
2. **Authentication** â†’ **Providers** â†’ **Google**
3. **Enable Google** toggle'Ä±nÄ± aÃ§Ä±n
4. **Client ID (for OAuth)** alanÄ±na Google'dan aldÄ±ÄŸÄ±nÄ±z Client ID'yi yapÄ±ÅŸtÄ±rÄ±n
5. **Client Secret (for OAuth)** alanÄ±na Google'dan aldÄ±ÄŸÄ±nÄ±z Client Secret'Ä± yapÄ±ÅŸtÄ±rÄ±n
6. **Save** butonuna tÄ±klayÄ±n

### 3. Redirect URL'leri Kontrol Etme

Supabase Dashboard'da **Authentication** â†’ **URL Configuration** bÃ¶lÃ¼mÃ¼nde:

**Redirect URLs** listesine ÅŸunlarÄ± ekleyin:
```
geliom://auth/callback
exp://127.0.0.1:8081/--/auth/callback
exp://localhost:8081/--/auth/callback
```

**Site URL** alanÄ±nÄ± da kontrol edin (genelde otomatik doldurulur).

### 4. Firebase Client ID'sini Kullanma

`google-services.json` dosyanÄ±zdaki mevcut Web client:
- **Client ID**: `53336710716-ocrnuvqlpq02lvss0hvjgeqc08539sqm.apps.googleusercontent.com`
- **Client Type**: 3 (Web application)
- Bu client'Ä± Supabase'de kullanabilirsiniz!

**YapmanÄ±z gerekenler:**
1. Google Cloud Console'da bu client'Ä± bulun
2. Redirect URI ekleyin: `https://jtqmntczxkdmftoqspdx.supabase.co/auth/v1/callback`
3. Client Secret'Ä± reset edin (eÄŸer gÃ¶remiyorsanÄ±z)
4. Supabase Dashboard'a Client ID ve yeni Secret'Ä± ekleyin

**Ã–nemli:** Secret'Ä± reset etmek Firebase'i etkilemez Ã§Ã¼nkÃ¼ Firebase native SDK kullanÄ±r ve secret gerektirmez.

### 4. Test Etme

1. UygulamayÄ± yeniden baÅŸlatÄ±n
2. Google ile giriÅŸ yapmayÄ± deneyin
3. ArtÄ±k Google OAuth sayfasÄ± aÃ§Ä±lmalÄ±

## Ã–nemli Notlar

- **Client Secret** mutlaka doÄŸru girilmelidir
- **Redirect URI** Google Cloud Console'da tam olarak eÅŸleÅŸmelidir
- Supabase'deki redirect URL'ler uygulama scheme'inizi iÃ§ermelidir (`geliom://`)

## Sorun Giderme

### "invalid_client" veya "the OAuth client was not found" hatasÄ±:
1. **Google Cloud Console'da OAuth client'Ä±n aktif olduÄŸundan emin olun**
2. **Client ID'nin doÄŸru kopyalandÄ±ÄŸÄ±ndan emin olun** (boÅŸluk olmamalÄ±)
3. **Client Secret'Ä±n doÄŸru kopyalandÄ±ÄŸÄ±ndan emin olun** (boÅŸluk olmamalÄ±)
4. **Redirect URI'nin Google Cloud Console'da ekli olduÄŸundan emin olun:**
   ```
   https://jtqmntczxkdmftoqspdx.supabase.co/auth/v1/callback
   ```
5. Supabase Dashboard'da Google provider ayarlarÄ±nÄ± kontrol edin
6. SayfayÄ± yenileyin ve tekrar deneyin

### "missing OAuth secret" hatasÄ±:
1. Supabase Dashboard'da Google provider ayarlarÄ±nÄ± kontrol edin
2. Client Secret alanÄ±nÄ±n dolu olduÄŸundan emin olun
3. EÄŸer boÅŸsa, yeni bir OAuth client oluÅŸturun ve secret'Ä± kopyalayÄ±n

### Redirect hatasÄ± alÄ±yorsanÄ±z:
1. Google Cloud Console'da redirect URI'nin **tam olarak** eÅŸleÅŸtiÄŸinden emin olun:
   - `https://jtqmntczxkdmftoqspdx.supabase.co/auth/v1/callback` (tam olarak bu ÅŸekilde)
2. Supabase Dashboard'da redirect URL'lerin eklendiÄŸinden emin olun
3. URL'lerde trailing slash olmamalÄ±

### Firebase ile Supabase ArasÄ±nda PaylaÅŸÄ±m:
- AynÄ± Google Cloud projesini kullanÄ±yorsanÄ±z, aynÄ± OAuth credentials'larÄ± kullanabilirsiniz
- Ancak her ikisi iÃ§in de redirect URI'larÄ± eklemeniz gerekir
- Firebase iÃ§in: `https://YOUR_PROJECT.firebaseapp.com/__/auth/handler`
- Supabase iÃ§in: `https://YOUR_PROJECT.supabase.co/auth/v1/callback`
</file>

<file path="docs/Theme-Typography-usage.md">
# Geliom - Theme & Typography KullanÄ±m KÄ±lavuzu

Geliom uygulamasÄ± iÃ§in Ã¶zel olarak tasarlanmÄ±ÅŸ doÄŸa temalÄ± renk paleti ve Comfortaa font ailesi ile typography sistemi.

## ğŸ¨ Renk Paleti

### DoÄŸa TemalÄ± YeÅŸil Tonlar

#### Light Theme
- **Primary**: `#2E7D32` (Orman yeÅŸili)
- **Secondary**: `#4CAF50` (Ã‡imen yeÅŸili)  
- **Tertiary**: `#81C784` (AÃ§Ä±k yeÅŸil)
- **Background**: `#F1F8E9` (Ã‡ok aÃ§Ä±k yeÅŸil arkaplan)
- **Text**: `#1B5E20` (Koyu yeÅŸil metin)

#### Dark Theme
- **Primary**: `#4CAF50` (Parlak yeÅŸil)
- **Secondary**: `#66BB6A` (Orta yeÅŸil)
- **Background**: `#0D1B0F` (Ã‡ok koyu yeÅŸil arkaplan)
- **Text**: `#E8F5E8` (AÃ§Ä±k yeÅŸil metin)

### KullanÄ±m
```tsx
import { useTheme } from '@/contexts/ThemeContext';

const { colors } = useTheme();

// Renkleri kullan
<View style={{ backgroundColor: colors.primary }}>
  <Text style={{ color: colors.text }}>Metin</Text>
</View>
```

## ğŸ”¤ Typography Sistemi

### Comfortaa Font Ailesi
- **Light**: Comfortaa-Light
- **Regular**: Comfortaa-Regular  
- **Medium**: Comfortaa-Medium
- **SemiBold**: Comfortaa-SemiBold
- **Bold**: Comfortaa-Bold

### Typography Variants

#### BaÅŸlÄ±k Seviyeleri
- **h1**: 32px, Bold - Ana baÅŸlÄ±k (Geliom logo)
- **h2**: 28px, SemiBold - Sayfa baÅŸlÄ±klarÄ±
- **h3**: 24px, SemiBold - BÃ¶lÃ¼m baÅŸlÄ±klarÄ±
- **h4**: 20px, Medium - Alt baÅŸlÄ±klar
- **h5**: 18px, Medium - KÃ¼Ã§Ã¼k baÅŸlÄ±klar
- **h6**: 16px, Medium - Mini baÅŸlÄ±klar

#### GÃ¶vde Metinleri
- **body**: 16px, Regular - Ana metin
- **bodyLarge**: 18px, Regular - BÃ¼yÃ¼k gÃ¶vde metni
- **bodySmall**: 14px, Regular - KÃ¼Ã§Ã¼k gÃ¶vde metni

#### Ã–zel KullanÄ±mlar
- **button**: 16px, SemiBold - Buton metinleri
- **status**: 15px, Medium - Durum metinleri
- **nickname**: 16px, Medium - Takma isimler
- **groupName**: 18px, SemiBold - Grup isimleri
- **caption**: 12px, Regular - KÃ¼Ã§Ã¼k aÃ§Ä±klamalar
- **label**: 14px, Medium - Form etiketleri

## ğŸ“± Typography Component KullanÄ±mÄ±

### Basit KullanÄ±m
```tsx
import { Typography } from '@/components/shared';

<Typography variant="h1">Ana BaÅŸlÄ±k</Typography>
<Typography variant="body">Normal metin</Typography>
<Typography variant="caption">KÃ¼Ã§Ã¼k aÃ§Ä±klama</Typography>
```

### Renk ile KullanÄ±m
```tsx
import { useTheme } from '@/contexts/ThemeContext';

const { colors } = useTheme();

<Typography variant="h2" color={colors.primary}>
  YeÅŸil BaÅŸlÄ±k
</Typography>

<Typography variant="body" color={colors.secondaryText}>
  Ä°kincil metin
</Typography>
```

### Font Weight Override
```tsx
<Typography variant="body" fontWeight="bold">
  KalÄ±n metin
</Typography>

<Typography variant="h3" fontWeight="light">
  Ä°nce baÅŸlÄ±k
</Typography>
```

### Style Override
```tsx
<Typography 
  variant="body" 
  style={{ textAlign: 'center', marginBottom: 16 }}
>
  OrtalanmÄ±ÅŸ metin
</Typography>
```

## ğŸ¯ Geliom Ã–zel KullanÄ±mlarÄ±

### Ana Sayfa BaÅŸlÄ±ÄŸÄ±
```tsx
<Typography variant="h1" color={colors.primary}>
  Geliom ğŸŒ¿
</Typography>
```

### Durum GÃ¶stergesi
```tsx
<Typography variant="status" color={colors.success}>
  ğŸŸ¢ Ã‡evrimiÃ§i
</Typography>
```

### Grup Ä°simleri
```tsx
<Typography variant="groupName" color={colors.text}>
  ArkadaÅŸlar ğŸ‘¥
</Typography>
```

### Butonlar
```tsx
<TouchableOpacity style={{ backgroundColor: colors.primary }}>
  <Typography variant="button" color={colors.white}>
    GruplarÄ±m
  </Typography>
</TouchableOpacity>
```

### Takma Ä°simler
```tsx
<Typography variant="nickname" color={colors.secondaryText}>
  @ahmet_dostum
</Typography>
```

## ğŸ¨ Tema DeÄŸiÅŸtirme

```tsx
import { useTheme } from '@/contexts/ThemeContext';

const { isDark, toggleTheme } = useTheme();

<TouchableOpacity onPress={toggleTheme}>
  <Ionicons 
    name={isDark ? "sunny" : "moon"} 
    size={24} 
    color={colors.text} 
  />
</TouchableOpacity>
```

## ğŸ“ Spacing ve Layout

### Ã–nerilen Spacing DeÄŸerleri
```tsx
const spacing = {
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32,
  xxl: 48,
};
```

### Ã–nerilen Border Radius
```tsx
const borderRadius = {
  sm: 8,
  md: 12,
  lg: 16,
  xl: 20,
  full: 9999,
};
```

## ğŸŒŸ Best Practices

1. **TutarlÄ±lÄ±k**: Her zaman Typography component'ini kullanÄ±n
2. **Renk Uyumu**: Theme colors'Ä± kullanarak tutarlÄ± renk paleti saÄŸlayÄ±n
3. **Okunabilirlik**: Uygun contrast oranlarÄ±na dikkat edin
4. **Responsive**: FarklÄ± ekran boyutlarÄ± iÃ§in test edin
5. **Accessibility**: Screen reader uyumluluÄŸunu saÄŸlayÄ±n

## ğŸ”§ Ã–zelleÅŸtirme

### Yeni Variant Ekleme
```tsx
// theme/typography.ts
export type TypographyKeys = {
  // ... mevcut variants
  customVariant: TypographyVariant;
};

export const typography: TypographyKeys = {
  // ... mevcut variants
  customVariant: {
    fontSize: 20,
    lineHeight: 28,
    defaultFontWeight: 'medium',
    letterSpacing: 0,
  },
};
```

### Yeni Renk Ekleme
```tsx
// theme/colors.ts
export const lightColors = {
  // ... mevcut renkler
  customColor: '#YOUR_COLOR',
};
```

Bu sistem Geliom'un doÄŸal, samimi ve kullanÄ±cÄ± dostu hissini desteklemek iÃ§in Ã¶zel olarak tasarlanmÄ±ÅŸtÄ±r. ğŸŒ¿
</file>

<file path="hooks/useAppInitialization.ts">
import { useUserGroups } from '@/api/groups';
import { useAuth } from '@/contexts/AuthContext';
import { Session } from '@supabase/supabase-js';

export interface AppInitializationState {
  isInitialized: boolean;
  isLoading: boolean;
  session: Session | null;
  hasGroups: boolean;
  error: Error | null;
}

/**
 * App'in baÅŸlangÄ±cÄ±nda tÃ¼m kritik verileri yÃ¼kler.
 * AuthContext'ten session ve user bilgilerini alÄ±r,
 * groups gibi ek verileri de yÃ¼kler.
 * 
 * @returns {AppInitializationState} Initialization durumu
 */
export const useAppInitialization = (): AppInitializationState => {
  // AuthContext'ten session ve user bilgilerini al
  const { session, user, isLoading: authLoading } = useAuth();

  // KullanÄ±cÄ±nÄ±n gruplarÄ±nÄ± yÃ¼kle (user varsa)
  // Not: useUserGroups iÃ§inde zaten enabled kontrolÃ¼ var (userId varsa)
  const { 
    data: groups = [], 
    isLoading: isGroupsLoading, 
    error: groupsError 
  } = useUserGroups(user?.id || '');

  // Genel loading durumu
  // 1. Auth loading bitmeli
  // 2. Session varsa user yÃ¼klenmeli (session var ama user yok ise bekle)
  // 3. Session ve user varsa gruplar yÃ¼klenmeli
  const isLoading = authLoading || (session && !user) || (session && user ? isGroupsLoading : false);

  // Genel hata durumu
  const error = groupsError || null;

  // Initialization tamamlandÄ± mÄ±?
  // Loading bitmeli ve hata olmamalÄ±
  const isInitialized = !isLoading && !error;

  return {
    isInitialized,
    isLoading,
    session,
    hasGroups: groups.length > 0,
    error: error as Error | null,
  };
};
</file>

<file path="hooks/useNetworkStatus.ts">
import NetInfo, { NetInfoState } from '@react-native-community/netinfo';
import { useEffect, useState } from 'react';

export type NetworkStatus = 'online' | 'offline' | 'weak';

export interface NetworkState {
  isConnected: boolean | null;
  isInternetReachable: boolean | null;
  status: NetworkStatus;
  type: string | null;
}

export interface NetworkStatusHook {
  isOnline: boolean;
  isOffline: boolean;
  isWeak: boolean;
  status: NetworkStatus;
  checkConnection: () => Promise<NetworkStatus>;
  networkState: NetworkState;
}

const WEAK_CONNECTION_THRESHOLD = 2; // Mbps

export const useNetworkStatus = (): NetworkStatusHook => {
  const [networkState, setNetworkState] = useState<NetworkState>({
    isConnected: null,
    isInternetReachable: null,
    status: 'online',
    type: null,
  });

  const determineNetworkStatus = (state: NetInfoState): NetworkStatus => {
    // BaÄŸlantÄ± yoksa
    if (!state.isConnected || state.isInternetReachable === false) {
      return 'offline';
    }

    // BaÄŸlantÄ± var - hÄ±z kontrolÃ¼
    if (state.details) {
      const details = state.details as any;
      
      // Cellular iÃ§in
      if (state.type === 'cellular' && details.cellularGeneration) {
        // 2G zayÄ±f kabul edilir
        if (details.cellularGeneration === '2g') {
          return 'weak';
        }
      }

      // WiFi iÃ§in (eÄŸer effectiveConnectionType varsa)
      if (details.effectiveConnectionType) {
        const effectiveType = details.effectiveConnectionType;
        // slow-2g veya 2g zayÄ±f kabul edilir
        if (effectiveType === 'slow-2g' || effectiveType === '2g') {
          return 'weak';
        }
      }
    }

    return 'online';
  };

  const checkConnection = async (): Promise<NetworkStatus> => {
    try {
      const state = await NetInfo.fetch();
      const status = determineNetworkStatus(state);

      setNetworkState({
        isConnected: state.isConnected,
        isInternetReachable: state.isInternetReachable,
        status,
        type: state.type,
      });

      return status;
    } catch (error) {
      console.error('Network check failed:', error);
      return 'offline';
    }
  };

  useEffect(() => {
    // Ä°lk durumu kontrol et
    checkConnection();

    // Network deÄŸiÅŸikliklerini dinle
    const unsubscribe = NetInfo.addEventListener((state) => {
      const status = determineNetworkStatus(state);

      setNetworkState({
        isConnected: state.isConnected,
        isInternetReachable: state.isInternetReachable,
        status,
        type: state.type,
      });
    });

    return () => {
      unsubscribe();
    };
  }, []);

  return {
    isOnline: networkState.status === 'online',
    isOffline: networkState.status === 'offline',
    isWeak: networkState.status === 'weak',
    status: networkState.status,
    checkConnection,
    networkState,
  };
};
</file>

<file path="services/notification-handler.ts">
import { OneSignal } from 'react-native-onesignal';

// Notification click handler'Ä± setup et
// Bu fonksiyon Provider.tsx'te Ã§aÄŸrÄ±lacak
export const setupNotificationHandler = () => {
  // Notification aÃ§Ä±ldÄ±ÄŸÄ±nda (kullanÄ±cÄ± bildirime tÄ±kladÄ±ÄŸÄ±nda)
  OneSignal.Notifications.addEventListener('click', async (event) => {
    console.log('ğŸ”” OneSignal notification clicked:', event);
    
    // additionalData'dan grup bilgisini al
    const additionalData = event.notification.additionalData;
    const groupId = additionalData?.group_id as string | undefined;
    const groupName = additionalData?.group_name as string | undefined;

    if (!groupId) {
      console.warn('âš ï¸ Bildirimde group_id bulunamadÄ±');
      return;
    }

    console.log('âœ… Grup bilgisi alÄ±ndÄ±:', { groupId, groupName });

    // Navigation iÃ§in router ve group context'e ihtiyacÄ±mÄ±z var
    // Bu handler'Ä± bir component iÃ§inde setup etmeliyiz
    // Åimdilik sadece log, gerÃ§ek navigation'Ä± NotificationHandler component'inde yapacaÄŸÄ±z
  });
};
</file>

<file path="services/onesignal.ts">
import Constants from 'expo-constants';
import { OneSignal } from 'react-native-onesignal';

// OneSignal App ID - app.json'dan al
const ONESIGNAL_APP_ID = Constants.expoConfig?.extra?.oneSignalAppId;

// OneSignal initialization state
let isOneSignalInitialized = false;
let isOneSignalSDKInitialized = false; // SDK initialize edildi mi (synchronous)
let pendingExternalId: string | null = null; // Subscription oluÅŸunca login yapmak iÃ§in bekleyen external ID
let initializationPromise: Promise<void> | null = null;

// OneSignal SDK'yÄ± synchronous olarak initialize et (Permission istenmeden Ã¶nce)
export const initializeOneSignalSDK = (): void => {
  if (isOneSignalSDKInitialized) {
    console.log('ğŸ”µ OneSignal SDK zaten initialize edilmiÅŸ');
    return;
  }

  try {
    console.log('ğŸ”µ OneSignal SDK initialize ediliyor, App ID:', ONESIGNAL_APP_ID);
    if (!ONESIGNAL_APP_ID) {
      console.warn('âš ï¸ OneSignal App ID bulunamadÄ±!');
      return;
    }
    
    // OneSignal SDK'yÄ± initialize et (synchronous)
    OneSignal.initialize(ONESIGNAL_APP_ID);
    isOneSignalSDKInitialized = true;
    console.log('âœ… OneSignal SDK initialize edildi (synchronous)');
  } catch (error) {
    console.error('âŒ OneSignal SDK initialize hatasÄ±:', error);
  }
};

// OneSignal'i tam olarak initialize et (Permission + Event listeners)
export const initializeOneSignal = async (): Promise<void> => {
  // SDK'yÄ± Ã¶nce initialize et
  initializeOneSignalSDK();
  
  // EÄŸer zaten tam initialization yapÄ±ldÄ±ysa, mevcut promise'i dÃ¶ndÃ¼r
  if (isOneSignalInitialized && initializationPromise) {
    return initializationPromise;
  }

  // Yeni initialization promise'i oluÅŸtur
  initializationPromise = (async () => {
    try {
      console.log('ğŸ”µ OneSignal tam initialization baÅŸlÄ±yor (permission + listeners)...');

      // Notification permission iste
      const granted = await OneSignal.Notifications.requestPermission(false);
      console.log('âœ… OneSignal permission granted:', granted);
      
      if (granted) {
        // Permission verildiyse Player ID'yi kontrol et
        // Biraz bekle, subscription oluÅŸmasÄ± iÃ§in (iOS'ta Ã¶zellikle gerekli)
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        const playerId = await getOneSignalPlayerId();
        if (playerId) {
          console.log('âœ… OneSignal Player ID hazÄ±r:', playerId);
          
          // Push subscription bilgilerini log'la
          try {
            const subscriptionId = await OneSignal.User.pushSubscription.getIdAsync();
            const pushToken = await OneSignal.User.pushSubscription.getTokenAsync();
            console.log('âœ… OneSignal Push Subscription ID:', subscriptionId);
            console.log('âœ… OneSignal Push Token:', pushToken ? 'Mevcut' : 'Yok');
            
            // EÄŸer bekleyen bir external ID varsa, hemen login yap
            if (pendingExternalId) {
              console.log('ğŸ”µ Permission verildi, bekleyen external ID ile login yapÄ±lÄ±yor:', pendingExternalId);
              const externalId = pendingExternalId;
              pendingExternalId = null; // Temizle
              try {
                await performOneSignalLogin(externalId, playerId, 3, 1000);
              } catch (error) {
                console.error('âŒ Otomatik login hatasÄ± (permission sonrasÄ±):', error);
                // Hata olsa bile pendingExternalId'yi tekrar set et, subscription change listener tekrar denesin
                pendingExternalId = externalId;
              }
            }
          } catch (subError) {
            console.warn('âš ï¸ OneSignal subscription bilgileri alÄ±namadÄ±:', subError);
          }
        } else {
          console.log('â³ OneSignal Player ID henÃ¼z hazÄ±r deÄŸil, subscription oluÅŸmasÄ± bekleniyor...');
        }
      } else {
        console.warn('âš ï¸ OneSignal permission reddedildi - bildirimler Ã§alÄ±ÅŸmayacak');
      }

      // NOT: Notification click listener NotificationHandler component'inde yÃ¶netiliyor
      // Burada duplicate listener eklemiyoruz

      // Notification alÄ±ndÄ±ÄŸÄ±nda (foreground'da)
      OneSignal.Notifications.addEventListener('foregroundWillDisplay', (event) => {
        console.log('ğŸ”” OneSignal notification received in foreground:', event);
        // Bildirimi gÃ¶ster (otomatik gÃ¶sterilir, burada sadece log)
      });

      // Push subscription deÄŸiÅŸikliklerini dinle
      OneSignal.User.pushSubscription.addEventListener('change', async (subscription) => {
        console.log('ğŸ”” OneSignal push subscription changed');
        const playerId = await getOneSignalPlayerId();
        if (playerId) {
          console.log('âœ… Yeni Player ID:', playerId);
          
          // EÄŸer bekleyen bir external ID varsa (kullanÄ±cÄ± login ama subscription henÃ¼z oluÅŸmamÄ±ÅŸsa), login yap
          if (pendingExternalId) {
            console.log('ğŸ”µ Bekleyen external ID var, otomatik login yapÄ±lÄ±yor:', pendingExternalId);
            const externalId = pendingExternalId;
            pendingExternalId = null; // Temizle
            try {
              await performOneSignalLogin(externalId, playerId, 3, 1000);
            } catch (error) {
              console.error('âŒ Otomatik login hatasÄ± (subscription change):', error);
              // Hata olsa bile pendingExternalId'yi tekrar set et, bir sonraki subscription change'de tekrar denesin
              pendingExternalId = externalId;
            }
          }
        }
      });

      console.log('âœ… OneSignal initialize tamamlandÄ±');
    } catch (error) {
      console.error('âŒ OneSignal initialize hatasÄ±:', error);
      isOneSignalInitialized = false;
      initializationPromise = null;
      throw error;
    }
  })();

  return initializationPromise;
};

// KullanÄ±cÄ±nÄ±n OneSignal Player ID'sini al (Push Subscription ID)
export const getOneSignalPlayerId = async (): Promise<string | null> => {
  try {
    const subscriptionId = await OneSignal.User.pushSubscription.getIdAsync();
    return subscriptionId;
  } catch (error) {
    console.error('Error getting OneSignal player ID:', error);
    return null;
  }
};

// KullanÄ±cÄ±ya tag ekle (segmentasyon iÃ§in)
export const setOneSignalTags = (tags: Record<string, string>) => {
  try {
    OneSignal.User.addTags(tags);
  } catch (error) {
    console.error('Error setting OneSignal tags:', error);
  }
};

// KullanÄ±cÄ± tag'lerini gÃ¼ncelle
export const updateOneSignalTags = (tags: Record<string, string>) => {
  try {
    OneSignal.User.addTags(tags);
  } catch (error) {
    console.error('Error updating OneSignal tags:', error);
  }
};

// OneSignal login iÅŸlemini gerÃ§ekleÅŸtir (internal helper function)
// Retry mekanizmasÄ± ile login baÅŸarÄ± kontrolÃ¼ yapar
const performOneSignalLogin = async (
  externalId: string, 
  playerId: string | null,
  maxRetries: number = 3,
  retryDelay: number = 1000
): Promise<void> => {
  console.log('ğŸ”µ OneSignal login iÅŸlemi baÅŸlatÄ±lÄ±yor:', {
    externalId,
    playerId: playerId || 'Yok',
    maxRetries,
  });

  let lastError: Error | null = null;
  
  // Retry mekanizmasÄ± ile login dene
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`ğŸ”µ OneSignal login denemesi ${attempt}/${maxRetries}...`);
      
      // OneSignal.login() async bir iÅŸlem olabilir, await edelim
      await OneSignal.login(externalId);
      
      // Login sonrasÄ± external ID'yi doÄŸrula (OneSignal SDK v5'te getExternalId mevcut)
      // Biraz bekle, SDK'nÄ±n internal state'ini gÃ¼ncellemesi iÃ§in
      await new Promise(resolve => setTimeout(resolve, 500));
      
      try {
        const currentExternalId = await OneSignal.User.getExternalId();
        if (currentExternalId === externalId) {
          console.log('âœ… OneSignal login baÅŸarÄ±lÄ±, external ID doÄŸrulandÄ±:', externalId);
        } else {
          console.warn(`âš ï¸ OneSignal login yapÄ±ldÄ± ama external ID eÅŸleÅŸmedi. Beklenen: ${externalId}, Mevcut: ${currentExternalId || 'Yok'}`);
          // EÅŸleÅŸmese bile devam et, belki SDK henÃ¼z gÃ¼ncellemedi
        }
      } catch (verifyError) {
        console.warn('âš ï¸ External ID doÄŸrulama hatasÄ± (non-blocking):', verifyError);
        // DoÄŸrulama hatasÄ± olsa bile devam et
      }
      
      // External ID'yi alias olarak da ekleyelim (Dashboard'da gÃ¶rÃ¼nmesi iÃ§in)
      // OneSignal SDK v5'te external ID'yi alias olarak eklemek daha gÃ¼venilir
      try {
        await OneSignal.User.addAlias('supabase_auth_id', externalId);
        console.log('âœ… OneSignal alias eklendi (supabase_auth_id):', externalId);
      } catch (aliasError) {
        console.warn('âš ï¸ OneSignal alias ekleme hatasÄ± (non-blocking):', aliasError);
      }
      
      // User properties'leri de gÃ¼ncelle (Dashboard'da gÃ¶rÃ¼nmesi iÃ§in)
      try {
        await OneSignal.User.addTags({
          'supabase_auth_id': externalId,
          'player_id': playerId || 'unknown',
        });
        console.log('âœ… OneSignal tags eklendi');
      } catch (tagsError) {
        console.warn('âš ï¸ OneSignal tags ekleme hatasÄ± (non-blocking):', tagsError);
      }
      
      // Push subscription bilgilerini log'la
      try {
        const subscriptionId = await OneSignal.User.pushSubscription.getIdAsync();
        const pushToken = await OneSignal.User.pushSubscription.getTokenAsync();
        console.log('âœ… OneSignal Push Subscription ID:', subscriptionId);
        console.log('âœ… OneSignal Push Token:', pushToken ? 'Mevcut' : 'Yok');
      } catch (subError) {
        console.warn('âš ï¸ OneSignal subscription bilgileri alÄ±namadÄ±:', subError);
      }
      
      console.log('âœ… OneSignal login iÅŸlemi tamamlandÄ±');
      return; // BaÅŸarÄ±lÄ±, Ã§Ä±k
      
    } catch (error: any) {
      lastError = error;
      console.error(`âŒ OneSignal login denemesi ${attempt}/${maxRetries} baÅŸarÄ±sÄ±z:`, error);
      
      // Son deneme deÄŸilse, bekle ve tekrar dene
      if (attempt < maxRetries) {
        console.log(`â³ ${retryDelay}ms sonra tekrar deneniyor...`);
        await new Promise(resolve => setTimeout(resolve, retryDelay));
      }
    }
  }
  
  // TÃ¼m denemeler baÅŸarÄ±sÄ±z oldu
  console.error('âŒ OneSignal login tÃ¼m denemeler baÅŸarÄ±sÄ±z oldu:', lastError);
  throw new Error(`OneSignal login baÅŸarÄ±sÄ±z (${maxRetries} deneme): ${lastError?.message || 'Bilinmeyen hata'}`);
};

// KullanÄ±cÄ±yÄ± OneSignal'e login et (external ID ile - Supabase auth ID)
// Player ID hazÄ±r olana kadar bekler (push subscription oluÅŸmalÄ±)
export const loginOneSignal = async (externalId: string, maxRetries: number = 10, delay: number = 1000): Promise<void> => {
  try {
    console.log('ğŸ”µ OneSignal login yapÄ±lÄ±yor, external ID (Supabase auth ID):', externalId);
    
    // OneSignal'in initialize edilip edilmediÄŸini kontrol et
    if (!isOneSignalInitialized) {
      console.log('â³ OneSignal henÃ¼z initialize edilmemiÅŸ, bekleniyor...');
      await initializeOneSignal();
    }
    
    // Player ID hazÄ±r olana kadar bekle (push subscription oluÅŸmalÄ±)
    let playerId: string | null = null;
    for (let i = 0; i < maxRetries; i++) {
      playerId = await getOneSignalPlayerId();
      if (playerId) {
        console.log('âœ… OneSignal Player ID hazÄ±r:', playerId);
        break;
      }
      console.log(`â³ OneSignal Player ID henÃ¼z hazÄ±r deÄŸil, ${delay}ms sonra tekrar deneniyor... (${i + 1}/${maxRetries})`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
    
    if (!playerId) {
      console.warn('âš ï¸ OneSignal Player ID alÄ±namadÄ±, subscription oluÅŸmasÄ± bekleniyor...');
      // Player ID yoksa, subscription oluÅŸunca login yapmak iÃ§in external ID'yi kaydet
      pendingExternalId = externalId;
      console.log('â³ Subscription oluÅŸunca otomatik login yapÄ±lacak');
      return; // Subscription change listener login yapacak
    }
    
    // Player ID hazÄ±rsa, login yap (retry mekanizmasÄ± performOneSignalLogin iÃ§inde)
    await performOneSignalLogin(externalId, playerId, 3, 1000);
    
    // Login baÅŸarÄ±lÄ± olduktan sonra external ID'yi tekrar doÄŸrula
    try {
      const verifiedExternalId = await OneSignal.User.getExternalId();
      if (verifiedExternalId === externalId) {
        console.log('âœ… OneSignal login ve external ID doÄŸrulama baÅŸarÄ±lÄ±');
      } else {
        console.warn(`âš ï¸ OneSignal login yapÄ±ldÄ± ama external ID doÄŸrulama baÅŸarÄ±sÄ±z. Beklenen: ${externalId}, Mevcut: ${verifiedExternalId || 'Yok'}`);
      }
    } catch (verifyError) {
      console.warn('âš ï¸ OneSignal external ID doÄŸrulama hatasÄ± (non-blocking):', verifyError);
    }
  } catch (error) {
    console.error('âŒ OneSignal login hatasÄ±:', error);
    throw error;
  }
};

// KullanÄ±cÄ±yÄ± OneSignal'den logout et
export const logoutOneSignal = () => {
  try {
    OneSignal.logout();
  } catch (error) {
    console.error('Error logging out OneSignal:', error);
  }
};
</file>

<file path="supabase/functions/process-pending-notifications/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const ONESIGNAL_APP_ID = Deno.env.get('ONESIGNAL_APP_ID') || '';
const ONESIGNAL_REST_API_KEY = Deno.env.get('ONESIGNAL_REST_API_KEY') || '';
const SUPABASE_URL = Deno.env.get('SUPABASE_URL') || '';
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || '';

interface NotificationPayload {
  receiver_ids: string[]; // AlÄ±cÄ± kullanÄ±cÄ± ID'leri (Supabase user IDs - external_id olarak kullanÄ±lacak)
  sender_id: string; // Bildirim gÃ¶nderen kullanÄ±cÄ± ID (rate limiting iÃ§in)
  group_id: string;
  group_name: string;
  title: string;
  message: string;
  type: 'status_update';
}

/**
 * Mesaj seÃ§imi ve placeholder deÄŸiÅŸtirme
 * Custom status'ler iÃ§in de messages array'i kullanÄ±lÄ±r
 */
function prepareNotificationMessage(
  messages: string[] | null | undefined,
  userName: string,
  groupName: string,
  statusText?: string
): string {
  let message: string;

  // Mesaj seÃ§imi
  if (messages && messages.length > 0) {
    // Rastgele bir mesaj seÃ§ (custom status'ler iÃ§in de geÃ§erli)
    const randomIndex = Math.floor(Math.random() * messages.length);
    message = messages[randomIndex];
  } else {
    // Default mesaj (messages array yoksa veya boÅŸsa)
    message = '{name} durumunu "{status}" olarak gÃ¼ncelledi';
  }

  // Placeholder deÄŸiÅŸtirme
  message = message.replace(/{name}/g, userName);
  message = message.replace(/{group}/g, groupName);
  if (statusText) {
    message = message.replace(/{status}/g, statusText);
  }

  return message;
}

serve(async (req) => {
  try {
    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

    // scheduled_at <= NOW() olan pending notification'larÄ± bul
    const { data: pendingNotifications, error: fetchError } = await supabase
      .from('pending_notifications')
      .select(`
        *,
        status:statuses(*),
        sender:users!pending_notifications_sender_id_fkey(display_name, custom_user_id),
        group:groups(name)
      `)
      .lte('scheduled_at', new Date().toISOString());

    if (fetchError) {
      console.error('Pending notifications fetch hatasÄ±:', fetchError);
      return new Response(
        JSON.stringify({ error: 'Pending notifications alÄ±namadÄ±', details: fetchError.message }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }

    if (!pendingNotifications || pendingNotifications.length === 0) {
      return new Response(
        JSON.stringify({ success: true, processed: 0, message: 'Ä°ÅŸlenecek bildirim yok' }),
        { status: 200, headers: { 'Content-Type': 'application/json' } }
      );
    }

    let processedCount = 0;
    let errorCount = 0;

    // Her pending notification iÃ§in bildirim gÃ¶nder
    for (const pending of pendingNotifications) {
      try {
        // Gerekli verileri kontrol et
        if (!pending.status || !pending.sender || !pending.group) {
          console.error('Eksik veri:', pending);
          errorCount++;
          continue;
        }

        // Status notifies kontrolÃ¼
        if (!pending.status.notifies) {
          // Bildirim gÃ¶nderme, kaydÄ± sil
          console.log('Status notifies false, kayÄ±t siliniyor:', pending.id);
          await supabase
            .from('pending_notifications')
            .delete()
            .eq('id', pending.id);
          continue;
        }

        // receiver_ids'lerin geÃ§erli olup olmadÄ±ÄŸÄ±nÄ± kontrol et (users tablosunda var mÄ±?)
        const { data: validUsers, error: validUsersError } = await supabase
          .from('users')
          .select('id')
          .in('id', pending.receiver_ids);

        if (validUsersError) {
          console.error('GeÃ§erli users kontrolÃ¼ hatasÄ±:', validUsersError);
          errorCount++;
          continue;
        }

        const validReceiverIds = validUsers?.map((u: { id: string }) => u.id) || [];

        if (validReceiverIds.length === 0) {
          // GeÃ§erli alÄ±cÄ± yok, kaydÄ± sil
          console.log('GeÃ§erli receiver_ids yok, kayÄ±t siliniyor:', pending.id);
          await supabase
            .from('pending_notifications')
            .delete()
            .eq('id', pending.id);
          continue;
        }

        // Mesaj hazÄ±rla
        // Custom status'ler iÃ§in de messages array'i kullanÄ±lÄ±r (statuses tablosunda messages kolonu var)
        const userName = pending.sender.display_name || pending.sender.custom_user_id || 'KullanÄ±cÄ±';
        const groupName = pending.group.name;
        const statusText = pending.status.text || 'Durum';
        
        // Status'un messages array'inden rastgele mesaj seÃ§ veya default mesaj kullan
        const message = prepareNotificationMessage(
          pending.status.messages, // Custom status'ler iÃ§in de messages array'i kullanÄ±lÄ±r
          userName,
          groupName,
          statusText
        );

        console.log('ğŸ”µ Status bildirimi hazÄ±rlanÄ±yor:', {
          sender: userName,
          group: groupName,
          status: statusText,
          receiver_count: validReceiverIds.length,
          message,
        });

        // Rate limiting kontrolÃ¼ (send-notification Edge Function'Ä±na gÃ¶nder)
        // Yeni API formatÄ±: receiver_ids kullanÄ±lÄ±yor (external_id olarak)
        const notificationPayload: NotificationPayload = {
          receiver_ids: validReceiverIds, // Supabase user IDs (external_id olarak kullanÄ±lacak)
          sender_id: pending.sender_id,
          group_id: pending.group_id,
          group_name: groupName,
          title: 'Durum GÃ¼ncellendi',
          message,
          type: 'status_update',
        };

        // send-notification Edge Function'Ä±nÄ± Ã§aÄŸÄ±r
        const { data: notificationResult, error: notificationError } = await supabase.functions.invoke(
          'send-notification',
          { body: notificationPayload }
        );

        if (notificationError) {
          console.error('Bildirim gÃ¶nderme hatasÄ±:', notificationError);
          errorCount++;
          // Rate limit hatasÄ± ise kaydÄ± silme, tekrar denesin
          if (notificationError.message?.includes('rate_limit_exceeded')) {
            // scheduled_at'i gÃ¼ncelle (1 dakika sonra tekrar dene)
            const newScheduledAt = new Date(Date.now() + 60 * 1000).toISOString();
            await supabase
              .from('pending_notifications')
              .update({ scheduled_at: newScheduledAt })
              .eq('id', pending.id);
          } else {
            // DiÄŸer hatalar iÃ§in kaydÄ± sil
            await supabase
              .from('pending_notifications')
              .delete()
              .eq('id', pending.id);
          }
        } else {
          // BaÅŸarÄ±lÄ±, kaydÄ± sil
          await supabase
            .from('pending_notifications')
            .delete()
            .eq('id', pending.id);
          processedCount++;
        }
      } catch (error) {
        console.error('Pending notification iÅŸleme hatasÄ±:', error);
        errorCount++;
        // Hata durumunda kaydÄ± sil
        await supabase
          .from('pending_notifications')
          .delete()
          .eq('id', pending.id);
      }
    }

    return new Response(
      JSON.stringify({
        success: true,
        processed: processedCount,
        errors: errorCount,
        total: pendingNotifications.length,
      }),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*',
        },
      }
    );
  } catch (error) {
    console.error('Process pending notifications hatasÄ±:', error);
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
});
</file>

<file path="supabase/functions/send-notification/index.ts">
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

// Environment variables - trim edilmiÅŸ ve doÄŸrulanmÄ±ÅŸ
const ONESIGNAL_APP_ID = (Deno.env.get('ONESIGNAL_APP_ID') || '').trim();
let ONESIGNAL_REST_API_KEY = (Deno.env.get('ONESIGNAL_REST_API_KEY') || '').trim();
const SUPABASE_URL = (Deno.env.get('SUPABASE_URL') || '').trim();
const SUPABASE_SERVICE_ROLE_KEY = (Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || '').trim();

// API Key format kontrolÃ¼ ve doÄŸrulama
const validateOneSignalApiKey = (apiKey: string): { valid: boolean; error?: string } => {
  if (!apiKey) {
    return { valid: false, error: 'API Key boÅŸ' };
  }
  
  // OneSignal REST API Key genellikle 40-50 karakter arasÄ± olur
  // Ama bazÄ± durumlarda daha uzun olabilir, bu yÃ¼zden sadece minimum kontrol yapÄ±yoruz
  if (apiKey.length < 20) {
    return { valid: false, error: `API Key Ã§ok kÄ±sa (${apiKey.length} karakter, minimum 20 bekleniyor)` };
  }
  
  // API Key sadece alfanumerik karakterler ve bazÄ± Ã¶zel karakterler iÃ§ermeli
  // Ama tam format kontrolÃ¼ yapmak yerine, sadece boÅŸluk kontrolÃ¼ yapÄ±yoruz
  if (apiKey.includes('\n') || apiKey.includes('\r')) {
    return { valid: false, error: 'API Key iÃ§inde yeni satÄ±r karakteri var' };
  }
  
  return { valid: true };
};

// API Key doÄŸrulama
const apiKeyValidation = validateOneSignalApiKey(ONESIGNAL_REST_API_KEY);

// Debug: Environment variables kontrolÃ¼ (API Key'in ilk/son 5 karakterini log'la, gÃ¼venlik iÃ§in)
const apiKeyPreview = ONESIGNAL_REST_API_KEY 
  ? `${ONESIGNAL_REST_API_KEY.substring(0, 5)}...${ONESIGNAL_REST_API_KEY.substring(ONESIGNAL_REST_API_KEY.length - 5)}`
  : 'Yok';

console.log('ğŸ”µ Edge Function environment variables:', {
  ONESIGNAL_APP_ID: ONESIGNAL_APP_ID ? 'âœ… Set' : 'âŒ Missing',
  ONESIGNAL_REST_API_KEY: ONESIGNAL_REST_API_KEY ? `âœ… Set (${ONESIGNAL_REST_API_KEY.length} karakter, ${apiKeyPreview})` : 'âŒ Missing',
  ONESIGNAL_REST_API_KEY_VALID: apiKeyValidation.valid ? 'âœ… Valid' : `âŒ Invalid: ${apiKeyValidation.error}`,
  SUPABASE_URL: SUPABASE_URL ? 'âœ… Set' : 'âŒ Missing',
  SUPABASE_SERVICE_ROLE_KEY: SUPABASE_SERVICE_ROLE_KEY ? 'âœ… Set' : 'âŒ Missing',
});

// Rate limit sÃ¼releri (dakika cinsinden)
const RATE_LIMITS: Record<string, number> = {
  'join_request': 5,        // 5 dakika
  'join_request_status': 1, // 1 dakika
  'direct_invite': 10,      // 10 dakika
  'status_update': 1,       // 1 dakika
  'mood_update': 1,         // 1 dakika
  'event_reminder': 60,     // 60 dakika (sistem bildirimi, daha uzun)
};

interface NotificationPayload {
  user_ids?: string[]; // OneSignal player_id'leri (DEPRECATED - include_aliases kullanÄ±lacak)
  receiver_ids: string[]; // AlÄ±cÄ± kullanÄ±cÄ± ID'leri (Supabase user IDs - external_id olarak kullanÄ±lacak)
  sender_id?: string; // Bildirim gÃ¶nderen kullanÄ±cÄ± ID (rate limiting iÃ§in)
  receiver_id_to_player_id?: Record<string, string>; // receiver_id -> player_id mapping (rate limiting iÃ§in, artÄ±k kullanÄ±lmÄ±yor)
  group_id: string;
  group_name: string;
  title: string;
  message: string;
  type: 'join_request' | 'join_request_status' | 'status_update' | 'mood_update' | 'event_reminder';
}

serve(async (req) => {
  try {
    // CORS headers
    if (req.method === 'OPTIONS') {
      return new Response(null, {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'POST, OPTIONS',
          'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
        },
      });
    }

    // Request body'yi parse et
    console.log('ğŸ”µ Request alÄ±ndÄ±, body parse ediliyor...');
    const payload: NotificationPayload = await req.json();
    console.log('ğŸ”µ Request payload:', {
      receiver_ids_count: payload.receiver_ids?.length || 0,
      receiver_ids: payload.receiver_ids?.slice(0, 3) || [], // Ä°lk 3'Ã¼ gÃ¶ster
      sender_id: payload.sender_id,
      group_id: payload.group_id,
      group_name: payload.group_name,
      type: payload.type,
    });

    // Validation - receiver_ids gerekli (Supabase user IDs - external_id olarak kullanÄ±lacak)
    if (!payload.receiver_ids || payload.receiver_ids.length === 0) {
      console.error('âŒ Validation hatasÄ±: receiver_ids eksik veya boÅŸ');
      return new Response(
        JSON.stringify({ error: 'receiver_ids gerekli (Supabase user IDs)' }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    if (!payload.group_id || !payload.group_name) {
      console.error('âŒ Validation hatasÄ±: group_id veya group_name eksik');
      return new Response(
        JSON.stringify({ error: 'group_id ve group_name gerekli' }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    console.log('âœ… Validation baÅŸarÄ±lÄ±');

    // Rate limiting kontrolÃ¼ (sadece sender_id varsa)
    // Status update ve mood update gibi Ã§oklu alÄ±cÄ± bildirimlerinde
    // limit aÅŸÄ±lan alÄ±cÄ±larÄ± filtrele, diÄŸerlerine gÃ¶nder
    let allowedReceiverIds: string[] = [];

    if (payload.sender_id && payload.receiver_ids && payload.receiver_ids.length > 0) {
      console.log('ğŸ”µ Rate limiting kontrolÃ¼ baÅŸlatÄ±lÄ±yor...', {
        sender_id: payload.sender_id,
        receiver_ids_count: payload.receiver_ids.length,
        type: payload.type,
      });

      const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
      const limitMinutes = RATE_LIMITS[payload.type] || 1;

      // Ã–nce receiver_ids'lerin geÃ§erli olup olmadÄ±ÄŸÄ±nÄ± kontrol et (users tablosunda var mÄ±?)
      // Bu, foreign key constraint hatalarÄ±nÄ± Ã¶nler
      console.log('ğŸ”µ GeÃ§erli receiver_ids kontrol ediliyor...');
      const { data: validUsers, error: validUsersError } = await supabase
        .from('users')
        .select('id')
        .in('id', payload.receiver_ids);

      if (validUsersError) {
        console.error('âŒ GeÃ§erli users kontrolÃ¼ hatasÄ±:', validUsersError);
        // Hata olsa bile devam et, rate limiting non-blocking
      }

      const validReceiverIds = validUsers?.map((u: { id: string }) => u.id) || [];
      console.log('ğŸ”µ GeÃ§erli receiver_ids:', {
        total: payload.receiver_ids.length,
        valid: validReceiverIds.length,
        invalid: payload.receiver_ids.length - validReceiverIds.length,
      });
      
      if (validReceiverIds.length === 0) {
        console.error('âŒ TÃ¼m receiver_ids geÃ§ersiz');
        return new Response(
          JSON.stringify({ 
            error: 'GeÃ§ersiz alÄ±cÄ± ID\'leri',
            message: 'TÃ¼m alÄ±cÄ± ID\'leri geÃ§ersiz veya kullanÄ±cÄ±lar silinmiÅŸ.',
          }),
          { status: 400, headers: { 'Content-Type': 'application/json' } }
        );
      }

      // Sadece geÃ§erli receiver_ids'leri kullan
      const validReceiverIdsSet = new Set(validReceiverIds);
      const filteredReceiverIds = payload.receiver_ids.filter(id => validReceiverIdsSet.has(id));
      console.log('ğŸ”µ FiltrelenmiÅŸ receiver_ids:', filteredReceiverIds.length);

      // Ã‡oklu alÄ±cÄ± bildirimleri iÃ§in (status_update, mood_update)
      const isMultiReceiver = payload.type === 'status_update' || payload.type === 'mood_update';
      console.log('ğŸ”µ Rate limiting tipi:', isMultiReceiver ? 'Multi-receiver (paralel)' : 'Single-receiver (sÄ±ralÄ±)');

      // Ã‡oklu alÄ±cÄ± bildirimlerinde paralel kontrol, tek alÄ±cÄ± bildirimlerinde sÄ±ralÄ± kontrol
      if (isMultiReceiver) {
        // Paralel kontrol (performans iÃ§in) - sadece geÃ§erli receiver_ids'ler iÃ§in
        console.log('ğŸ”µ Paralel rate limit kontrolÃ¼ baÅŸlatÄ±lÄ±yor...', filteredReceiverIds.length, 'receiver iÃ§in');
        const rateLimitChecks = await Promise.allSettled(
          filteredReceiverIds.map(receiverId =>
            supabase.rpc('check_rate_limit', {
              p_sender_id: payload.sender_id,
              p_receiver_id: receiverId,
              p_group_id: payload.group_id,
              p_notification_type: payload.type,
              p_limit_minutes: limitMinutes,
            })
          )
        );

        // SonuÃ§larÄ± iÅŸle
        console.log('ğŸ”µ Rate limit kontrolÃ¼ sonuÃ§larÄ± iÅŸleniyor...');
        rateLimitChecks.forEach((result, index) => {
          const receiverId = filteredReceiverIds[index];

          if (result.status === 'fulfilled') {
            const { data: rateLimitCheck, error: rateLimitError } = result.value;

            if (rateLimitError) {
              console.error('Rate limit kontrolÃ¼ hatasÄ±:', rateLimitError);
              // Hata olsa bile devam et (rate limiting non-blocking)
              allowedReceiverIds.push(receiverId);
            } else if (rateLimitCheck && rateLimitCheck.length > 0) {
              const { can_send } = rateLimitCheck[0];
              if (can_send) {
                allowedReceiverIds.push(receiverId);
              } else {
                // Rate limit aÅŸÄ±ldÄ± - bu alÄ±cÄ±yÄ± atla
                console.log(`âš ï¸ Rate limit aÅŸÄ±ldÄ±: sender=${payload.sender_id}, receiver=${receiverId}, type=${payload.type}`);
              }
            } else {
              // KayÄ±t yoksa izin ver
              allowedReceiverIds.push(receiverId);
            }
          } else {
            // Promise rejected - hata durumunda izin ver (non-blocking)
            console.error('âŒ Rate limit kontrolÃ¼ promise hatasÄ±:', result.reason);
            allowedReceiverIds.push(receiverId);
          }
        });
        console.log('âœ… Paralel rate limit kontrolÃ¼ tamamlandÄ±:', {
          total: filteredReceiverIds.length,
          allowed: allowedReceiverIds.length,
          blocked: filteredReceiverIds.length - allowedReceiverIds.length,
        });
      } else {
        // Tek alÄ±cÄ± bildirimlerinde sÄ±ralÄ± kontrol (hata durumunda hemen durdur)
        // Sadece geÃ§erli receiver_ids'ler iÃ§in kontrol yap
        console.log('ğŸ”µ SÄ±ralÄ± rate limit kontrolÃ¼ baÅŸlatÄ±lÄ±yor...', filteredReceiverIds.length, 'receiver iÃ§in');
        for (const receiverId of filteredReceiverIds) {
          console.log('ğŸ”µ Rate limit kontrolÃ¼:', { sender: payload.sender_id, receiver: receiverId, type: payload.type });
          const { data: rateLimitCheck, error: rateLimitError } = await supabase.rpc(
            'check_rate_limit',
            {
              p_sender_id: payload.sender_id,
              p_receiver_id: receiverId,
              p_group_id: payload.group_id,
              p_notification_type: payload.type,
              p_limit_minutes: limitMinutes,
            }
          );

          if (rateLimitError) {
            // Foreign key constraint hatasÄ± gibi hatalar iÃ§in log'la ama devam et
            if (rateLimitError.code === '23503') {
              console.warn(`Rate limit kontrolÃ¼: receiver_id (${receiverId}) users tablosunda yok, atlanÄ±yor`);
              // Bu receiver_id'yi atla
              continue;
            }
            console.error('Rate limit kontrolÃ¼ hatasÄ±:', rateLimitError);
            // DiÄŸer hatalar iÃ§in devam et (rate limiting non-blocking)
            allowedReceiverIds.push(receiverId);
          } else if (rateLimitCheck && rateLimitCheck.length > 0 && rateLimitCheck[0]) {
          const { can_send, wait_until } = rateLimitCheck[0];
          
          if (can_send) {
            allowedReceiverIds.push(receiverId);
          } else {
              // Rate limit aÅŸÄ±ldÄ± - tek alÄ±cÄ± bildirimlerinde tÃ¼m bildirimi durdur
              const waitSeconds = Math.ceil((new Date(wait_until).getTime() - Date.now()) / 1000);
              const waitMinutes = Math.ceil(waitSeconds / 60);
              
              return new Response(
                JSON.stringify({
                  error: 'rate_limit_exceeded',
                  message: `Ã‡ok sÄ±k bildirim gÃ¶nderiyorsunuz. LÃ¼tfen ${waitMinutes} dakika bekleyin.`,
                  wait_until: wait_until,
                  wait_seconds: waitSeconds,
                }),
                {
                  status: 429, // Too Many Requests
                  headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*',
                    'Retry-After': waitSeconds.toString(),
                  },
                }
              );
            }
          } else {
            // KayÄ±t yoksa izin ver
            allowedReceiverIds.push(receiverId);
          }
        }
      }

      // Ã‡oklu alÄ±cÄ± bildirimlerinde hiÃ§bir alÄ±cÄ±ya gÃ¶nderilemiyorsa hata dÃ¶ndÃ¼r
      if (isMultiReceiver && allowedReceiverIds.length === 0) {
        console.error('âŒ TÃ¼m alÄ±cÄ±lar iÃ§in rate limit aÅŸÄ±ldÄ±');
        return new Response(
          JSON.stringify({
            error: 'rate_limit_exceeded',
            message: 'TÃ¼m alÄ±cÄ±lar iÃ§in rate limit aÅŸÄ±ldÄ±. LÃ¼tfen bir sÃ¼re bekleyin.',
          }),
          {
            status: 429,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
          }
        );
      }

      // Ã‡oklu alÄ±cÄ± bildirimlerinde limit aÅŸmayan alÄ±cÄ±larÄ±n receiver_ids'lerini filtrele
      // ArtÄ±k player_id yerine external_id (receiver_id) kullanacaÄŸÄ±z
      if (isMultiReceiver) {
        // Sadece limit aÅŸmayan alÄ±cÄ±lara bildirim gÃ¶nder
        payload.receiver_ids = allowedReceiverIds;
        console.log('âœ… Rate limiting sonrasÄ± receiver_ids:', allowedReceiverIds.length);
      } else {
        // Tek alÄ±cÄ± bildirimlerinde zaten allowedReceiverIds kontrol edildi
        payload.receiver_ids = allowedReceiverIds;
        console.log('âœ… Rate limiting sonrasÄ± receiver_ids:', allowedReceiverIds.length);
      }
    } else {
      console.log('â„¹ï¸ Rate limiting atlandÄ± (sender_id yok)');
    }

    // OneSignal API'ye bildirim gÃ¶nder (Yeni API v2 formatÄ±)
    // include_aliases.external_id kullanÄ±yoruz (receiver_ids = Supabase user IDs = external_id)
    console.log('ğŸ”µ OneSignal payload hazÄ±rlanÄ±yor...', {
      receiver_ids_count: payload.receiver_ids.length,
      receiver_ids_preview: payload.receiver_ids.slice(0, 3),
    });
    
    const oneSignalPayload = {
      app_id: ONESIGNAL_APP_ID,
      include_aliases: {
        external_id: payload.receiver_ids, // Supabase user IDs = OneSignal external_id
      },
      target_channel: 'push', // Push notification channel
      headings: {
        en: `${payload.group_name} - ${payload.title}`,
        tr: `${payload.group_name} - ${payload.title}`,
      },
      contents: {
        en: `${payload.group_name} grubundan: ${payload.message}`,
        tr: `${payload.group_name} grubundan: ${payload.message}`,
      },
      data: {
        group_id: payload.group_id,
        group_name: payload.group_name,
        type: payload.type,
      },
      // iOS ve Android iÃ§in Ã¶zel ayarlar
      ios_badgeType: 'Increase',
      ios_badgeCount: 1,
    };

    console.log('ğŸ”µ OneSignal API Ã§aÄŸrÄ±sÄ± yapÄ±lÄ±yor (Yeni API v2):', {
      app_id: ONESIGNAL_APP_ID,
      endpoint: '/notifications?c=push',
      receiver_ids_count: payload.receiver_ids.length,
      receiver_ids_preview: payload.receiver_ids.slice(0, 3), // Ä°lk 3'Ã¼ gÃ¶ster
      title: `${payload.group_name} - ${payload.title}`,
      message: `${payload.group_name} grubundan: ${payload.message}`,
    });

    // OneSignal REST API Key kontrolÃ¼ ve doÄŸrulama
    if (!ONESIGNAL_REST_API_KEY) {
      console.error('âŒ ONESIGNAL_REST_API_KEY environment variable eksik!');
      return new Response(
        JSON.stringify({ 
          error: 'OneSignal REST API Key yapÄ±landÄ±rÄ±lmamÄ±ÅŸ',
          message: 'ONESIGNAL_REST_API_KEY environment variable eksik. Supabase Dashboard â†’ Edge Functions â†’ Settings â†’ Secrets\'dan ekleyin.',
        }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // API Key format kontrolÃ¼
    if (!apiKeyValidation.valid) {
      console.error('âŒ ONESIGNAL_REST_API_KEY format hatasÄ±:', apiKeyValidation.error);
      return new Response(
        JSON.stringify({ 
          error: 'OneSignal REST API Key format hatasÄ±',
          message: `API Key geÃ§ersiz: ${apiKeyValidation.error}. LÃ¼tfen Supabase Dashboard â†’ Edge Functions â†’ Settings â†’ Secrets\'dan doÄŸru API Key'i ekleyin.`,
        }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // OneSignal REST API Authorization header formatÄ± (Yeni API v2)
    // Yeni API iÃ§in: Authorization: Key {REST_API_KEY}
    // API Key'in baÅŸÄ±nda "Key " prefix'i olmamalÄ±, sadece API key olmalÄ±
    // OneSignal API Key formatÄ±: "os_v2_app_..." veya benzeri
    // Authorization header: "Key os_v2_app_..." formatÄ±nda olmalÄ±
    const authorizationHeader = `Key ${ONESIGNAL_REST_API_KEY.trim()}`;

    // Yeni API endpoint: /notifications?c=push
    const oneSignalApiUrl = 'https://api.onesignal.com/notifications?c=push';

    console.log('ğŸ”µ OneSignal API Ã§aÄŸrÄ±sÄ± detaylarÄ± (Yeni API v2):', {
      url: oneSignalApiUrl,
      method: 'POST',
      app_id: ONESIGNAL_APP_ID,
      receiver_ids_count: payload.receiver_ids.length,
      authorization_header_preview: `${authorizationHeader.substring(0, 25)}...`,
      api_key_length: ONESIGNAL_REST_API_KEY.length,
      api_key_preview: apiKeyPreview,
      api_key_starts_with: ONESIGNAL_REST_API_KEY.substring(0, 10),
      api_key_ends_with: ONESIGNAL_REST_API_KEY.substring(ONESIGNAL_REST_API_KEY.length - 10),
    });

    const oneSignalResponse = await fetch(oneSignalApiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': authorizationHeader,
      },
      body: JSON.stringify(oneSignalPayload),
    });

    if (!oneSignalResponse.ok) {
      const errorText = await oneSignalResponse.text();
      let errorDetails: any = {
        status: oneSignalResponse.status,
        statusText: oneSignalResponse.statusText,
        error: errorText,
      };

      // 403 Forbidden hatasÄ± iÃ§in Ã¶zel kontrol
      if (oneSignalResponse.status === 403) {
        errorDetails.diagnosis = {
          possible_causes: [
            'API Key yanlÄ±ÅŸ veya geÃ§ersiz',
            'API Key formatÄ± hatalÄ± (baÅŸÄ±nda/sonunda boÅŸluk olabilir)',
            'API Key bu App ID iÃ§in yetkisiz',
            'API Key sÃ¼resi dolmuÅŸ veya iptal edilmiÅŸ',
          ],
          api_key_length: ONESIGNAL_REST_API_KEY.length,
          api_key_preview: apiKeyPreview,
          authorization_header_preview: `${authorizationHeader.substring(0, 20)}...`,
          troubleshooting: 'Supabase Dashboard â†’ Edge Functions â†’ Settings â†’ Secrets\'dan ONESIGNAL_REST_API_KEY\'i kontrol edin. OneSignal Dashboard â†’ Settings â†’ Keys & IDs\'den REST API Key\'i doÄŸrulayÄ±n.',
        };
      }

      console.error('âŒ OneSignal API hatasÄ±:', errorDetails);
      
      return new Response(
        JSON.stringify({ 
          error: 'OneSignal bildirim gÃ¶nderme hatasÄ±', 
          details: errorText,
          status: oneSignalResponse.status,
          diagnosis: errorDetails.diagnosis || undefined,
        }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const oneSignalResult = await oneSignalResponse.json();
    console.log('âœ… OneSignal bildirim gÃ¶nderildi:', {
      id: oneSignalResult.id,
      recipients: oneSignalResult.recipients,
      errors: oneSignalResult.errors,
    });

    return new Response(
      JSON.stringify({ success: true, result: oneSignalResult }),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*',
        },
      }
    );
  } catch (error) {
    console.error('âŒ Bildirim gÃ¶nderme hatasÄ± (catch bloÄŸu):', error);
    const errorMessage = error instanceof Error ? error.message : 'Bilinmeyen hata';
    const errorStack = error instanceof Error ? error.stack : undefined;
    console.error('âŒ Hata detaylarÄ±:', {
      message: errorMessage,
      stack: errorStack,
      error_type: error?.constructor?.name || typeof error,
    });
    return new Response(
      JSON.stringify({ 
        error: errorMessage,
        details: errorStack,
      }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
});
</file>

<file path="types/auth.ts">
/**
 * Auth Provider Types
 * Apple ve Google OAuth provider'larÄ±ndan gelen farklÄ± formatlarÄ± normalize eder
 */

export type AuthProvider = 'apple' | 'google';

/**
 * Normalized User Data
 * Apple ve Google'dan gelen farklÄ± formatlarÄ± tek bir formata Ã§evirir
 * custom_user_id YOK - Supabase auth.users UUID direkt kullanÄ±lÄ±r
 */
export interface NormalizedUserData {
  id: string; // UUID - Supabase auth.users'dan
  email: string | null;
  displayName: string | null;
  photoUrl: string | null;
  provider: AuthProvider;
}

/**
 * Supabase User objesinden normalized data Ã§Ä±karma iÃ§in helper type
 */
export interface SupabaseUserMetadata {
  full_name?: string;
  name?: string;
  avatar_url?: string;
  picture?: string;
  email?: string;
}

/**
 * Auth Error Types
 */
export type AuthErrorCode =
  | 'NETWORK_ERROR'
  | 'CANCELLED'
  | 'INVALID_TOKEN'
  | 'PROVIDER_ERROR'
  | 'UNKNOWN_ERROR';

export interface AuthError {
  code: AuthErrorCode;
  message: string;
  originalError?: unknown;
}
</file>

<file path="utils/avatar.ts">
import { ImageSourcePropType } from 'react-native';

const AVATAR_MAP: Record<string, ImageSourcePropType> = {
  'bear.png': require('@/assets/avatars/bear.png'),
  'man-1.png': require('@/assets/avatars/man-1.png'),
  'man-2.png': require('@/assets/avatars/man-2.png'),
  'man-3.png': require('@/assets/avatars/man-3.png'),
  'man-4.png': require('@/assets/avatars/man-4.png'),
  'man-5.png': require('@/assets/avatars/man-5.png'),
  'woman-1.png': require('@/assets/avatars/woman-1.png'),
  'woman-2.png': require('@/assets/avatars/woman-2.png'),
  'woman-3.png': require('@/assets/avatars/woman-3.png'),
  'woman-4.png': require('@/assets/avatars/woman-4.png'),
  'woman-5.png': require('@/assets/avatars/woman-5.png'),
};

const DEFAULT_AVATAR = 'bear.png';

/**
 * KullanÄ±cÄ±nÄ±n avatar dosya adÄ±ndan ImageSourcePropType dÃ¶ndÃ¼rÃ¼r
 * @param avatar - Avatar dosya adÄ± (Ã¶rn: "bear.png", "man-1.png") veya null
 * @returns ImageSourcePropType - React Native Image component'i iÃ§in uygun source
 */
export function getAvatarSource(avatar: string | null | undefined): ImageSourcePropType {
  const avatarName = avatar || DEFAULT_AVATAR;
  return AVATAR_MAP[avatarName] || AVATAR_MAP[DEFAULT_AVATAR];
}

/**
 * TÃ¼m mevcut avatar dosya adlarÄ±nÄ± dÃ¶ndÃ¼rÃ¼r
 * @returns string[] - Avatar dosya adlarÄ± listesi
 */
export function getAvailableAvatars(): string[] {
  return Object.keys(AVATAR_MAP);
}

/**
 * Avatar dosya adÄ±nÄ±n geÃ§erli olup olmadÄ±ÄŸÄ±nÄ± kontrol eder
 * @param avatar - Avatar dosya adÄ±
 * @returns boolean - GeÃ§erli ise true
 */
export function isValidAvatar(avatar: string): boolean {
  return avatar in AVATAR_MAP;
}
</file>

<file path="utils/group-type-selector.ts">
export const groupTypeSelector = (type: string) => {
  switch (type) {
    case 'family':
      return 'Your Family';
    case 'friends':
      return 'Your Friends';
    case 'work':
      return 'Your work friends';
    default:
      return 'Your Group';
  }
};
</file>

<file path="utils/linking.ts">
import { Alert, Linking } from 'react-native';

// External URL'ler
export const PRIVACY_POLICY_URL = 'https://geliom.app/privacy-policy';
export const TERMS_OF_USE_URL = 'https://geliom.app/terms-of-use';

/**
 * External URL'i aÃ§ar
 * @param url AÃ§Ä±lacak URL
 * @param fallbackMessage URL aÃ§Ä±lamazsa gÃ¶sterilecek hata mesajÄ±
 */
export const openExternalURL = async (url: string, fallbackMessage?: string): Promise<void> => {
  try {
    const supported = await Linking.canOpenURL(url);
    if (supported) {
      await Linking.openURL(url);
    } else {
      Alert.alert(
        'Hata',
        fallbackMessage || `Bu URL aÃ§Ä±lamÄ±yor: ${url}`
      );
    }
  } catch (error) {
    console.error('URL aÃ§ma hatasÄ±:', error);
    Alert.alert(
      'Hata',
      'BaÄŸlantÄ± aÃ§Ä±lÄ±rken bir hata oluÅŸtu'
    );
  }
};

/**
 * Gizlilik PolitikasÄ±nÄ± aÃ§ar
 */
export const openPrivacyPolicy = () => {
  return openExternalURL(
    PRIVACY_POLICY_URL,
    'Gizlilik PolitikasÄ± sayfasÄ± aÃ§Ä±lamadÄ±'
  );
};

/**
 * KullanÄ±m ÅartlarÄ±nÄ± aÃ§ar
 */
export const openTermsOfUse = () => {
  return openExternalURL(
    TERMS_OF_USE_URL,
    'KullanÄ±m ÅartlarÄ± sayfasÄ± aÃ§Ä±lamadÄ±'
  );
};
</file>

<file path="eas.json">
{
  "cli": {
    "version": ">= 16.26.0",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "distribution": "internal"
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}
</file>

<file path="eslint.config.js">
// https://docs.expo.dev/guides/using-eslint/
const { defineConfig } = require('eslint/config');
const expoConfig = require('eslint-config-expo/flat');

module.exports = defineConfig([
  expoConfig,
  {
    ignores: ['dist/*'],
  },
]);
</file>

<file path="google-services.json">
{
  "project_info": {
    "project_number": "53336710716",
    "project_id": "geliom-8d06f",
    "storage_bucket": "geliom-8d06f.firebasestorage.app"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:53336710716:android:3299f86178a303588c2d39",
        "android_client_info": {
          "package_name": "com.eoist.geliom"
        }
      },
      "oauth_client": [
        {
          "client_id": "53336710716-a6u8baf8pmvppr9vmhkv5rv8l8e8nti0.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "com.eoist.geliom",
            "certificate_hash": "610e3c94225cea2c04de558b63a847d751fc1664"
          }
        },
        {
          "client_id": "53336710716-ocrnuvqlpq02lvss0hvjgeqc08539sqm.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCSighX37jvoaj6gFSbfZvw4N9_wJbrwaY"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "53336710716-ocrnuvqlpq02lvss0hvjgeqc08539sqm.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "53336710716-ldovpft6789mdmqr2jflh3ugrbuagbom.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.eoist.geliom",
                "app_store_id": "6754461885"
              }
            }
          ]
        }
      }
    }
  ],
  "configuration_version": "1"
}
</file>

<file path="GoogleService-Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CLIENT_ID</key>
	<string>53336710716-ldovpft6789mdmqr2jflh3ugrbuagbom.apps.googleusercontent.com</string>
	<key>REVERSED_CLIENT_ID</key>
	<string>com.googleusercontent.apps.53336710716-ldovpft6789mdmqr2jflh3ugrbuagbom</string>
	<key>ANDROID_CLIENT_ID</key>
	<string>53336710716-a6u8baf8pmvppr9vmhkv5rv8l8e8nti0.apps.googleusercontent.com</string>
	<key>API_KEY</key>
	<string>AIzaSyDS7_WSCWuUuo2Z7EIMqIRvfVCf2FnlhOA</string>
	<key>GCM_SENDER_ID</key>
	<string>53336710716</string>
	<key>PLIST_VERSION</key>
	<string>1</string>
	<key>BUNDLE_ID</key>
	<string>com.eoist.geliom</string>
	<key>PROJECT_ID</key>
	<string>geliom-8d06f</string>
	<key>STORAGE_BUCKET</key>
	<string>geliom-8d06f.firebasestorage.app</string>
	<key>IS_ADS_ENABLED</key>
	<false></false>
	<key>IS_ANALYTICS_ENABLED</key>
	<false></false>
	<key>IS_APPINVITE_ENABLED</key>
	<true></true>
	<key>IS_GCM_ENABLED</key>
	<true></true>
	<key>IS_SIGNIN_ENABLED</key>
	<true></true>
	<key>GOOGLE_APP_ID</key>
	<string>1:53336710716:ios:5995bcbacb0c1d788c2d39</string>
</dict>
</plist>
</file>

<file path="tsconfig.json">
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}
</file>

<file path=".cursor/rules/generally.mdc">
---
alwaysApply: true
---

**rule** never use shadow
**rule** everytime use Stylesheet
**rule** use must use shared component firstly
**rule** every constant value should be in constant folder
**rule** if neccassery create component but if already have same component use it.
</file>

<file path="api/index.ts">
// Supabase client
export { supabase } from './supabase';

// Types
export * from '../types/database';

// Users API
export {
  // Mutations
  useCreateUser, useCurrentUser, useDeleteUser,
  // Query Keys
  userKeys, useUpdateUser, useUser, useUserByCustomId,
  // Queries
  useUsers,
  // Realtime
  useUsersRealtime
} from './users';

// Moods API
export {
  // Query Keys
  moodKeys,
  // Mutations
  useCreateMood, useDeleteMood, useMood,
  useMoodByText,
  // Queries
  useMoods,
  // Realtime
  useMoodsRealtime, useUpdateMood
} from './moods';

// Groups API
export {
  // Query Keys
  groupKeys, useApproveJoinRequest,
  // Mutations
  useCreateGroup,
  // Join Requests
  useCreateJoinRequest, useDeleteGroup, useGroup,
  useGroupByInviteCode, useGroupJoinRequests,
  // Join Requests Realtime
  useGroupJoinRequestsRealtime, useGroupMembers, useGroupMembersRealtime,
  // Queries
  useGroups,
  // Realtime
  useGroupsRealtime, useIsGroupMember, useJoinGroup,
  useLeaveGroup, useMyJoinRequests, useMyJoinRequestsRealtime, useRejectJoinRequest, useTransferGroupOwnership, useUpdateGroup, useUserGroups
} from './groups';

// Nicknames API
export {
  // Query Keys
  nicknameKeys,
  // Mutations
  useCreateNickname, useDeleteNickname,
  // Queries
  useGroupNicknames, useNickname,
  // Realtime
  useNicknamesRealtime, useUpdateNickname, useUpsertNickname, useUserNicknames,
  useUserSetNicknames
} from './nicknames';

// Statuses API
export {
  // Query Keys
  statusKeys,
  // Mutations
  useCreateStatus, useCustomStatuses, useDefaultStatuses, useDeleteStatus, useRemoveUserStatus, userStatusKeys, useSetUserStatus, useStatus,
  // Queries
  useStatuses,
  // Realtime
  useStatusesRealtime, useUpdateStatus, useUserStatus, useUserStatusesRealtime, useUsersWithStatuses
} from './statuses';

// Notifications API (Bildirim gÃ¶nderme fonksiyonlarÄ±)
export {
  sendEventReminderNotification, sendJoinRequestNotification,
  sendJoinRequestStatusNotification, sendMoodUpdateNotification, sendNotification, sendStatusUpdateNotification
} from './notifications';

// Muted Notifications API
export {
  mutedKeys,
  useIsMuted as useIsUserMuted,
  useMutedNotifications as useMutedNotificationsList,
  useMuteUser,
  useToggleMuteUser,
  useUnmuteUser
} from './muted';

// Subscriptions API
export {
  // Query Keys
  subscriptionKeys, useCancelSubscription,
  // Mutations
  useCreateSubscription, useCurrentUserSubscription, useDeleteSubscription, useIsSubscriptionActive,
  // Realtime
  useSubscriptionRealtime, useUpdateSubscription,
  // Queries
  useUserSubscription
} from './subscriptions';

// Events API
export {
  // Query Keys
  eventKeys,
  // Mutations
  useCreateEvent, useDeleteEvent, useEvent, useEventsRealtime,
  // Queries
  useGroupEvents,
  // Realtime
  useGroupEventsRealtime, useUpcomingGroupEvents, useUpdateEvent, useUserCreatedEvents, useUserGroupsEvents
} from './events';

// Utility functions for common operations
import { supabase } from './supabase';

export const apiUtils = {
  // Auth helpers
  getCurrentUserId: async () => {
    const { data: { user } } = await supabase.auth.getUser();
    return user?.id || null;
  },
  
  // Check if user is group member
  checkGroupMembership: async (groupId: string, userId: string) => {
    const { data, error } = await supabase
      .from('group_members')
      .select('user_id')
      .eq('group_id', groupId)
      .eq('user_id', userId)
      .single();
    
    if (error && error.code !== 'PGRST116') throw error;
    return !!data;
  },
  
  // Check if user owns group
  checkGroupOwnership: async (groupId: string, userId: string) => {
    const { data, error } = await supabase
      .from('groups')
      .select('owner_id')
      .eq('id', groupId)
      .eq('owner_id', userId)
      .single();
    
    if (error && error.code !== 'PGRST116') throw error;
    return !!data;
  },
  
  // Generate unique invite code
  generateInviteCode: () => {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let result = '';
    for (let i = 0; i < 8; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  },
  
  // Format date for display
  formatEventDate: (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('tr-TR', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  },
  
  // Check if subscription is active
  isSubscriptionActive: (subscription: { status: string; expires_at?: string | null }) => {
    if (subscription.status !== 'active') return false;
    
    if (subscription.expires_at) {
      const expiresAt = new Date(subscription.expires_at);
      const now = new Date();
      return expiresAt > now;
    }
    
    return true; // expires_at null ise sÄ±nÄ±rsÄ±z abonelik
  },
};
</file>

<file path="api/notifications.ts">
import { supabase } from './supabase';

/**
 * Bildirim gÃ¶nderme API'si
 * Supabase Edge Function'Ä± Ã§aÄŸÄ±rÄ±r
 */

interface SendNotificationParams {
  user_ids?: string[]; // DEPRECATED - ArtÄ±k kullanÄ±lmÄ±yor, receiver_ids kullanÄ±lacak
  receiver_ids: string[]; // AlÄ±cÄ± kullanÄ±cÄ± ID'leri (Supabase user IDs - external_id olarak kullanÄ±lacak)
  sender_id?: string; // Bildirim gÃ¶nderen kullanÄ±cÄ± ID (rate limiting iÃ§in)
  receiver_id_to_player_id?: Record<string, string>; // DEPRECATED - ArtÄ±k kullanÄ±lmÄ±yor
  group_id: string;
  group_name: string;
  title: string;
  message: string;
  type: 'join_request' | 'join_request_status' | 'status_update' | 'mood_update' | 'event_reminder';
}

/**
 * Bildirim gÃ¶nder
 */
export const sendNotification = async (params: SendNotificationParams) => {
  const { data, error } = await supabase.functions.invoke('send-notification', {
    body: params,
  });
      
  if (error) {
    // Rate limit hatasÄ± kontrolÃ¼
    if (error.message?.includes('rate_limit_exceeded') || data?.error === 'rate_limit_exceeded') {
      const rateLimitError = new Error(data?.message || 'Ã‡ok sÄ±k bildirim gÃ¶nderiyorsunuz. LÃ¼tfen bekleyin.');
      (rateLimitError as any).code = 'RATE_LIMIT_EXCEEDED';
      (rateLimitError as any).wait_until = data?.wait_until;
      (rateLimitError as any).wait_seconds = data?.wait_seconds;
      throw rateLimitError;
    }
    
    console.error('Bildirim gÃ¶nderme hatasÄ±:', error);
    throw error;
  }

      return data;
};

/**
 * Grup katÄ±lma isteÄŸi bildirimi gÃ¶nder
 */
export const sendJoinRequestNotification = async (
  groupOwnerId: string, // Supabase user ID (external_id olarak kullanÄ±lacak)
  groupId: string,
  groupName: string,
  requesterName: string,
  requesterId: string // Rate limiting iÃ§in
) => {
  return sendNotification({
    receiver_ids: [groupOwnerId], // Supabase user ID = OneSignal external_id
    sender_id: requesterId,
    group_id: groupId,
    group_name: groupName,
    title: 'Yeni KatÄ±lma Ä°steÄŸi',
    message: `${requesterName} grubunuza katÄ±lmak istiyor`,
    type: 'join_request',
  });
};

/**
 * KatÄ±lma isteÄŸi durumu bildirimi gÃ¶nder (onaylandÄ±/reddedildi)
 */
export const sendJoinRequestStatusNotification = async (
  requesterId: string, // Supabase user ID (external_id olarak kullanÄ±lacak)
  groupId: string,
  groupName: string,
  status: 'approved' | 'rejected',
  groupOwnerId: string // Rate limiting iÃ§in
) => {
  const title = status === 'approved' ? 'KatÄ±lma Ä°steÄŸi OnaylandÄ±' : 'KatÄ±lma Ä°steÄŸi Reddedildi';
  const message =
    status === 'approved'
      ? `${groupName} grubuna katÄ±lma isteÄŸiniz onaylandÄ±!`
      : `${groupName} grubuna katÄ±lma isteÄŸiniz reddedildi.`;

  return sendNotification({
    receiver_ids: [requesterId], // Supabase user ID = OneSignal external_id
    sender_id: groupOwnerId,
    group_id: groupId,
    group_name: groupName,
    title,
    message,
    type: 'join_request_status',
  });
};

/**
 * Durum gÃ¼ncellemesi bildirimi gÃ¶nder
 */
export const sendStatusUpdateNotification = async (
  receiverIds: string[], // Supabase user IDs (external_id olarak kullanÄ±lacak)
  groupId: string,
  groupName: string,
  userName: string,
  statusText: string,
  senderId: string // Rate limiting iÃ§in
) => {
  return sendNotification({
    receiver_ids: receiverIds, // Supabase user IDs = OneSignal external_id
    sender_id: senderId,
    group_id: groupId,
    group_name: groupName,
    title: 'Durum GÃ¼ncellendi',
    message: `${userName} durumunu "${statusText}" olarak gÃ¼ncelledi`,
    type: 'status_update',
  });
};

/**
 * Mood gÃ¼ncellemesi bildirimi gÃ¶nder
 */
export const sendMoodUpdateNotification = async (
  receiverIds: string[], // Supabase user IDs (external_id olarak kullanÄ±lacak)
  groupId: string,
  groupName: string,
  userName: string,
  moodText: string,
  senderId: string // Rate limiting iÃ§in
) => {
  return sendNotification({
    receiver_ids: receiverIds, // Supabase user IDs = OneSignal external_id
    sender_id: senderId,
    group_id: groupId,
    group_name: groupName,
    title: 'Mood GÃ¼ncellendi',
    message: `${userName} mood'unu "${moodText}" olarak gÃ¼ncelledi`,
    type: 'mood_update',
  });
};

/**
 * Etkinlik hatÄ±rlatÄ±cÄ±sÄ± bildirimi gÃ¶nder
 */
export const sendEventReminderNotification = async (
  receiverIds: string[], // Supabase user IDs (external_id olarak kullanÄ±lacak)
  groupId: string,
  groupName: string,
  eventTitle: string
) => {
  return sendNotification({
    receiver_ids: receiverIds, // Supabase user IDs = OneSignal external_id
    group_id: groupId,
    group_name: groupName,
    title: 'Etkinlik HatÄ±rlatÄ±cÄ±sÄ±',
    message: `${eventTitle} iÃ§in 1 saat kaldÄ±!`,
    type: 'event_reminder',
  });
};
</file>

<file path="api/supabase.ts">
import AsyncStorage from '@react-native-async-storage/async-storage';
import { createClient } from '@supabase/supabase-js';
import 'react-native-url-polyfill/auto'; // Supabase'in React Native'de dÃ¼zgÃ¼n Ã§alÄ±ÅŸmasÄ± iÃ§in gerekli

// Supabase projenizin bilgilerini buraya girin.
// En iyi pratik, bu bilgileri bir .env dosyasÄ±nda saklamaktÄ±r.
const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL || '';
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || '';

// Supabase istemcisini oluÅŸturuyoruz.
// AsyncStorage'Ä± oturum bilgilerini saklamak iÃ§in kullanÄ±yoruz.
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: AsyncStorage,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
  realtime: {
    params: {
      eventsPerSecond: 10,
    },
  },
});
</file>

<file path="app/(drawer)/(group)/create-group.tsx">
import { apiUtils } from "@/api";
import { useCreateGroup, useJoinGroup } from "@/api/groups";
import KeyboardAwareView from "@/components/KeyboardAwareView";
import { BaseLayout, GeliomButton, Typography } from "@/components/shared";
import { useAuth } from "@/contexts/AuthContext";
import { useGroupContext } from "@/contexts/GroupContext";
import { useTheme } from "@/contexts/ThemeContext";
import type { GroupWithOwner } from "@/types/database";
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useState } from "react";
import { Alert, StyleSheet, TextInput, TouchableOpacity, View } from "react-native";
import { useSafeAreaInsets } from 'react-native-safe-area-context';

const GROUP_TYPES = [
  { value: 'family', label: 'Aile', icon: 'home', desc: 'Ev halkÄ± iÃ§in' },
  { value: 'friends', label: 'ArkadaÅŸlar', icon: 'people', desc: 'En yakÄ±nlar iÃ§in' },
  { value: 'work', label: 'Ä°ÅŸ', icon: 'briefcase', desc: 'Ekip iÃ§in' },
  { value: 'other', label: 'DiÄŸer', icon: 'shapes', desc: 'Ã–zel gruplar' },
];

export default function CreateGroupScreen() {
  const { user } = useAuth();
  const { setSelectedGroup } = useGroupContext();
  const { colors } = useTheme();
  const router = useRouter();
  const insets = useSafeAreaInsets();
  
  // Hook'larÄ± component'in en Ã¼st seviyesinde tanÄ±mla
  const createGroupMutation = useCreateGroup();
  const joinGroupMutation = useJoinGroup();
  
  const headerHeight = 56 + insets.top;

  const [name, setName] = useState('');
  const [type, setType] = useState('family');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [nameError, setNameError] = useState<string | null>(null);
  
  const MEMBER_LIMIT = 5;

  const handleCreateGroup = async () => {
    if (!name.trim() || name.trim().length < 3) {
      setNameError('En az 3 karakter gerekli');
      return;
    }
    if (!user?.id) return;

    try {
      setIsSubmitting(true);
      const inviteCode = apiUtils.generateInviteCode();
      const group = await createGroupMutation.mutateAsync({
        owner_id: user.id,
        type,
        name: name.trim(),
        invite_code: inviteCode,
        member_limit: MEMBER_LIMIT,
      });
      await joinGroupMutation.mutateAsync({ group_id: group.id, user_id: user.id });
      
      const groupWithOwner: GroupWithOwner = { ...group, owner: user };
      await setSelectedGroup(groupWithOwner);
      router.replace('/(drawer)/home');
    } catch (error: any) {
      console.error('Grup oluÅŸturma hatasÄ±:', error);
      Alert.alert('Hata', error.message || 'Grup oluÅŸturulamadÄ±');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <BaseLayout
      headerShow={true}
      header={{
        leftIcon: { icon: <Ionicons name="arrow-back" size={24} color={colors.text} />, onPress: () => router.back() },
        title: <Typography variant="h5" color={colors.text}>Yeni Birlik Kur</Typography>,
        backgroundColor: colors.background,
      }}
    >
      <KeyboardAwareView contentContainerStyle={styles.contentContainer} keyboardVerticalOffset={headerHeight}>
        <View style={styles.headerSection}>
          <Typography variant="h3" color={colors.primary} style={{ marginBottom: 8 }}>
            {name ? name : 'Ä°simsiz Grup'}
          </Typography>
          <Typography variant="body" color={colors.secondaryText} style={{ textAlign: 'center' }}>
            Sevdiklerinle anlÄ±k durumlarÄ±nÄ± paylaÅŸmak iÃ§in Ã¶zel bir alan.
          </Typography>
        </View>

        <View style={styles.form}>
          <View style={styles.inputGroup}>
            <Typography variant="label" color={colors.text} style={{ marginBottom: 8 }}>Grup Ä°smi</Typography>
            <TextInput
              style={[styles.input, { backgroundColor: colors.cardBackground, color: colors.text, borderColor: nameError ? colors.error : colors.stroke }]}
              placeholder="Ã–rn: CanÄ±m Ailem"
              placeholderTextColor={colors.secondaryText + '80'}
              value={name}
              onChangeText={(t) => { setName(t); setNameError(null); }}
              maxLength={30}
            />
          </View>

          <View style={styles.inputGroup}>
            <Typography variant="label" color={colors.text} style={{ marginBottom: 12 }}>Grup Tipi</Typography>
            <View style={styles.typeGrid}>
              {GROUP_TYPES.map((groupType) => {
                const isSelected = type === groupType.value;
                return (
                  <TouchableOpacity
                    key={groupType.value}
                    style={[styles.typeCard, { backgroundColor: isSelected ? colors.primary + '10' : colors.cardBackground, borderColor: isSelected ? colors.primary : colors.stroke }]}
                    onPress={() => setType(groupType.value)}
                    activeOpacity={0.7}
                  >
                    <View style={[styles.iconBadge, { backgroundColor: isSelected ? colors.primary : colors.tertiary }]}>
                      <Ionicons name={groupType.icon as any} size={20} color={isSelected ? colors.white : colors.primary} />
                    </View>
                    <Typography variant="body" fontWeight="semibold" color={colors.text} style={{ marginTop: 8 }}>{groupType.label}</Typography>
                  </TouchableOpacity>
                );
              })}
            </View>
          </View>

          <GeliomButton
            state={isSubmitting ? 'loading' : 'active'}
            layout="full-width"
            size="large"
            icon="checkmark-circle"
            onPress={handleCreateGroup}
            disabled={isSubmitting}
          >
            {isSubmitting ? 'OluÅŸturuluyor...' : 'Grubu OluÅŸtur'}
          </GeliomButton>
        </View>
      </KeyboardAwareView>
    </BaseLayout>
  );
}

const styles = StyleSheet.create({
  contentContainer: { padding: 24, paddingBottom: 100 },
  headerSection: { alignItems: 'center', marginBottom: 32, paddingHorizontal: 20 },
  form: { gap: 28 },
  inputGroup: { gap: 4 },
  input: { borderWidth: 1.5, borderRadius: 16, paddingHorizontal: 16, paddingVertical: 16, fontSize: 18, fontFamily: 'Comfortaa-Medium' },
  typeGrid: { flexDirection: 'row', flexWrap: 'wrap', gap: 12 },
  typeCard: { width: '48%', padding: 12, borderRadius: 16, borderWidth: 1.5, alignItems: 'center', justifyContent: 'center' },
  iconBadge: { width: 40, height: 40, borderRadius: 20, justifyContent: 'center', alignItems: 'center' },
});
</file>

<file path="app/(drawer)/(group)/group-management.tsx">
import { useGroupJoinRequests, useGroupJoinRequestsRealtime, useUpdateGroup } from '@/api/groups';
import { useCreateMood } from '@/api/moods';
import { useCreateStatus } from '@/api/statuses';
import { BaseLayout, GeliomButton, Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useGroupContext } from '@/contexts/GroupContext';
import { useTheme } from '@/contexts/ThemeContext';
import { Ionicons } from '@expo/vector-icons';
import * as Clipboard from 'expo-clipboard';
import { useRouter } from 'expo-router';
import React, { useState } from 'react';
import { Alert, KeyboardAvoidingView, Modal, Platform, ScrollView, StyleSheet, Switch, TextInput, TouchableOpacity, View } from 'react-native';

export default function GroupManagementScreen() {
  const { user } = useAuth();
  const { selectedGroup } = useGroupContext();
  const { colors } = useTheme();
  const router = useRouter();

  const [isCopying, setIsCopying] = useState(false);
  const [groupNameModalVisible, setGroupNameModalVisible] = useState(false);
  const [newGroupName, setNewGroupName] = useState('');
  const [statusModalVisible, setStatusModalVisible] = useState(false);
  const [newStatusText, setNewStatusText] = useState('');
  const [newStatusEmoji, setNewStatusEmoji] = useState('');
  const [notifiesStatus, setNotifiesStatus] = useState(false);
  const [moodModalVisible, setMoodModalVisible] = useState(false);
  const [newMoodText, setNewMoodText] = useState('');
  const [newMoodEmoji, setNewMoodEmoji] = useState('');

  const updateGroup = useUpdateGroup();
  const createStatus = useCreateStatus();
  const createMood = useCreateMood();

  const isOwner = selectedGroup?.owner_id === user?.id;
  
  // KatÄ±lma isteklerini Ã§ek (sadece owner iÃ§in)
  const { data: joinRequests = [] } = useGroupJoinRequests(selectedGroup?.id || '', 'pending');
  const pendingRequestsCount = joinRequests.length;
  
  // Realtime subscription
  useGroupJoinRequestsRealtime(selectedGroup?.id || '');

  const handleJoinRequestsPress = () => {
    if (selectedGroup) {
      router.push('/(drawer)/(group)/join-requests');
    }
  };

  if (!selectedGroup) {
    return (
      <BaseLayout
        headerShow={true}
        header={{
          leftIcon: {
            icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
            onPress: () => router.back(),
          },
          title: <Typography variant="h5" color={colors.text}>Grup YÃ¶netimi</Typography>,
          backgroundColor: colors.background,
          style: { borderBottomWidth: 0 },
        }}
      >
        <View style={[styles.emptyContainer, { backgroundColor: colors.background }]}>
          <Ionicons name="people-outline" size={64} color={colors.secondaryText} />
          <Typography variant="h4" color={colors.text} style={{ marginTop: 16, marginBottom: 8 }}>
            Grup SeÃ§ilmedi
          </Typography>
          <Typography variant="body" color={colors.secondaryText} style={{ textAlign: 'center' }}>
            Grup yÃ¶netimi iÃ§in bir grup seÃ§melisiniz.
          </Typography>
        </View>
      </BaseLayout>
    );
  }

  const copyInviteCode = async () => {
    if (selectedGroup.invite_code) {
      await Clipboard.setStringAsync(selectedGroup.invite_code);
      setIsCopying(true);
      setTimeout(() => setIsCopying(false), 2000);
    }
  };

  const handleUpdateGroupName = async () => {
    if (!newGroupName.trim() || !isOwner) return;
    
    // Validation: Max 20 karakter
    if (newGroupName.trim().length > 20) {
      Alert.alert('Hata', 'Grup adÄ± en fazla 20 karakter olabilir');
      return;
    }
    
    try {
      await updateGroup.mutateAsync({
        id: selectedGroup.id,
        updates: { name: newGroupName.trim() },
      });
      setGroupNameModalVisible(false);
      setNewGroupName('');
      Alert.alert('BaÅŸarÄ±lÄ±', 'Grup adÄ± gÃ¼ncellendi');
    } catch (error: any) {
      console.error('Grup adÄ± gÃ¼ncelleme hatasÄ±:', error);
      Alert.alert('Hata', error.message || 'Grup adÄ± gÃ¼ncellenemedi');
    }
  };

  const handleCreateStatus = async () => {
    if (!newStatusText.trim() || !isOwner || !user?.id || !selectedGroup?.id) return;
    
    try {
      await createStatus.mutateAsync({
        text: newStatusText.trim(),
        notifies: notifiesStatus, // KullanÄ±cÄ± seÃ§imi
        is_custom: true,
        owner_id: user.id,
        group_id: selectedGroup.id, // Custom status'ler grup bazlÄ±
        emoji: newStatusEmoji.trim() || undefined, // Emoji opsiyonel
        messages: undefined, // messages opsiyonel, undefined gÃ¶nder
      });
      setStatusModalVisible(false);
      setNewStatusText('');
      setNewStatusEmoji('');
      setNotifiesStatus(false);
      Alert.alert('BaÅŸarÄ±lÄ±', 'Ã–zel durum oluÅŸturuldu');
    } catch (error: any) {
      console.error('Status oluÅŸturma hatasÄ±:', error);
      const errorMessage = error?.message || error?.code || 'Durum oluÅŸturulamadÄ±';
      Alert.alert('Hata', errorMessage);
    }
  };

  const handleCreateMood = async () => {
    if (!newMoodText.trim() || !isOwner || !user?.id || !selectedGroup?.id) return;
    
    try {
      await createMood.mutateAsync({
        text: newMoodText.trim(),
        emoji: newMoodEmoji.trim() || undefined,
        group_id: selectedGroup.id, // Custom mood'lar grup bazlÄ±
      });
      setMoodModalVisible(false);
      setNewMoodText('');
      setNewMoodEmoji('');
      Alert.alert('BaÅŸarÄ±lÄ±', 'Ã–zel mood oluÅŸturuldu');
    } catch (error: any) {
      console.error('Mood oluÅŸturma hatasÄ±:', error);
      const errorMessage = error?.message || error?.code || 'Mood oluÅŸturulamadÄ±';
      Alert.alert('Hata', errorMessage);
    }
  };

  return (
    <BaseLayout
      headerShow={true}
      header={{
        leftIcon: {
          icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
          onPress: () => router.back(),
        },
        title: <Typography variant="h5" color={colors.text}>Grup YÃ¶netimi</Typography>,
        rightIcon: isOwner ? {
          icon: (
            <View style={styles.rightIconContainer}>
              <TouchableOpacity
                onPress={handleJoinRequestsPress}
                style={[styles.actionButton, { backgroundColor: colors.cardBackground + '80', borderColor: colors.stroke }]}
              >
                <Ionicons name="person-add-outline" size={18} color={colors.text} />
                {pendingRequestsCount > 0 && (
                  <View style={[styles.badge, { backgroundColor: colors.error }]}>
                    <Typography variant="caption" color={colors.white} style={styles.badgeText}>
                      {pendingRequestsCount > 9 ? '9+' : pendingRequestsCount}
                    </Typography>
                  </View>
                )}
              </TouchableOpacity>
            </View>
          ),
          onPress: handleJoinRequestsPress,
        } : undefined,
        backgroundColor: colors.background,
        style: { borderBottomWidth: 0 },
      }}
    >
      <ScrollView
        style={styles.container}
        contentContainerStyle={styles.contentContainer}
      >
        {/* Davet Kodu KartÄ± */}
        <View style={[styles.inviteCard, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}>
          <View style={styles.inviteCardHeader}>
            <Ionicons name="key-outline" size={24} color={colors.primary} />
            <View style={{ flex: 1, marginLeft: 12 }}>
              <Typography variant="h5" color={colors.text}>
                {selectedGroup.name} - Davet Kodu
              </Typography>
            </View>
          </View>
          <View style={styles.inviteCodeContainer}>
            <Typography variant="h3" color={colors.primary} style={styles.inviteCode}>
              {selectedGroup.invite_code}
            </Typography>
            <GeliomButton
              state={isCopying ? 'active' : 'passive'}
              size="small"
              icon={isCopying ? 'checkmark' : 'copy'}
              onPress={copyInviteCode}
            >
              {isCopying ? 'KopyalandÄ±' : 'Kopyala'}
            </GeliomButton>
          </View>
          <Typography variant="caption" color={colors.secondaryText} style={{ marginTop: 8 }}>
            Bu kodu paylaÅŸarak kullanÄ±cÄ±lar grubunuza katÄ±lma isteÄŸi gÃ¶nderebilir
          </Typography>
        </View>

        {/* Grup AyarlarÄ± (Sadece Owner) */}
        {isOwner && (
          <View style={styles.settingsSection}>
            <Typography variant="h5" color={colors.text} style={styles.sectionTitle}>
              Grup AyarlarÄ±
            </Typography>
            
            {/* Grup AdÄ± DeÄŸiÅŸtir */}
            <TouchableOpacity
              onPress={() => {
                setNewGroupName(selectedGroup.name);
                setGroupNameModalVisible(true);
              }}
              style={[styles.settingItem, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}
            >
              <View style={styles.settingItemContent}>
                <Ionicons name="pencil-outline" size={20} color={colors.primary} />
                <View style={styles.settingItemText}>
                  <Typography variant="body" color={colors.text}>
                    Grup AdÄ±
                  </Typography>
                  <Typography variant="caption" color={colors.secondaryText}>
                    {selectedGroup.name}
                  </Typography>
                </View>
                <Ionicons name="chevron-forward" size={18} color={colors.secondaryText} />
              </View>
            </TouchableOpacity>

            {/* Ã–zel Durum Ekle */}
            <TouchableOpacity
              onPress={() => setStatusModalVisible(true)}
              style={[styles.settingItem, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}
            >
              <View style={styles.settingItemContent}>
                <Ionicons name="add-circle-outline" size={20} color={colors.primary} />
                <View style={styles.settingItemText}>
                  <Typography variant="body" color={colors.text}>
                    Ã–zel Durum Ekle
                  </Typography>
                  <Typography variant="caption" color={colors.secondaryText}>
                    Gruba Ã¶zel durum oluÅŸtur
                  </Typography>
                </View>
                <Ionicons name="chevron-forward" size={18} color={colors.secondaryText} />
              </View>
            </TouchableOpacity>

            {/* Ã–zel Mood Ekle */}
            <TouchableOpacity
              onPress={() => setMoodModalVisible(true)}
              style={[styles.settingItem, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}
            >
              <View style={styles.settingItemContent}>
                <Ionicons name="happy-outline" size={20} color={colors.primary} />
                <View style={styles.settingItemText}>
                  <Typography variant="body" color={colors.text}>
                    Ã–zel Mood Ekle
                  </Typography>
                  <Typography variant="caption" color={colors.secondaryText}>
                    Gruba Ã¶zel mood oluÅŸtur
                  </Typography>
                </View>
                <Ionicons name="chevron-forward" size={18} color={colors.secondaryText} />
              </View>
            </TouchableOpacity>

            {/* Status ve Mood SÄ±rala */}
            <TouchableOpacity
              onPress={() => router.push('/(drawer)/(group)/reorder-status-mood')}
              style={[styles.settingItem, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}
            >
              <View style={styles.settingItemContent}>
                <Ionicons name="reorder-three-outline" size={20} color={colors.primary} />
                <View style={styles.settingItemText}>
                  <Typography variant="body" color={colors.text}>
                    Status ve Mood SÄ±rala
                  </Typography>
                  <Typography variant="caption" color={colors.secondaryText}>
                    Status ve mood sÄ±ralamasÄ±nÄ± dÃ¼zenle
                  </Typography>
                </View>
                <Ionicons name="chevron-forward" size={18} color={colors.secondaryText} />
              </View>
            </TouchableOpacity>
          </View>
        )}

        {/* YÃ¶netim ButonlarÄ± */}
        <View style={styles.actionsContainer}>
          <Typography variant="h5" color={colors.text} style={styles.sectionTitle}>
            Ãœye YÃ¶netimi
          </Typography>
          
          {/* TÃ¼m Ãœyeler iÃ§in */}
          <TouchableOpacity
            onPress={() => router.push('/(drawer)/(group)/manage-members')}
            style={[styles.memberButton, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}
          >
            <View style={styles.memberButtonContent}>
              <Ionicons name="people-outline" size={24} color={colors.primary} />
              <View style={styles.memberButtonText}>
                <Typography variant="h5" color={colors.text}>
                  Ãœyeleri YÃ¶net
                </Typography>
                <Typography variant="caption" color={colors.secondaryText}>
                  Ãœyeleri gÃ¶rÃ¼ntÃ¼le, takma ad ver, sessize al
                </Typography>
              </View>
              <Ionicons name="chevron-forward" size={20} color={colors.secondaryText} />
            </View>
          </TouchableOpacity>
        </View>
      </ScrollView>

      {/* Grup AdÄ± DeÄŸiÅŸtir Modal */}
      <Modal
        visible={groupNameModalVisible}
        transparent
        animationType="slide"
        onRequestClose={() => setGroupNameModalVisible(false)}
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={styles.modalOverlay}
        >
          <ScrollView
            keyboardShouldPersistTaps="handled"
            contentContainerStyle={styles.modalScrollContent}
          >
            <View style={[styles.modalContent, { backgroundColor: colors.cardBackground }]}>
            <Typography variant="h5" color={colors.text} style={styles.modalTitle}>
              Grup AdÄ±nÄ± DeÄŸiÅŸtir
            </Typography>
            
            <TextInput
              style={[styles.modalInput, { 
                backgroundColor: colors.background, 
                color: colors.text,
                borderColor: colors.stroke 
              }]}
              placeholder="Grup adÄ± (max 20 karakter)"
              placeholderTextColor={colors.secondaryText}
              value={newGroupName}
              onChangeText={setNewGroupName}
              maxLength={20}
            />
            <Typography variant="caption" color={colors.secondaryText} style={{ marginTop: 4, marginBottom: 8 }}>
              {newGroupName.length}/20 karakter
            </Typography>
            
            <View style={styles.modalActions}>
              <GeliomButton
                state="passive"
                size="medium"
                onPress={() => {
                  setGroupNameModalVisible(false);
                  setNewGroupName('');
                }}
                style={styles.modalButton}
              >
                Ä°ptal
              </GeliomButton>
              <GeliomButton
                state={updateGroup.isPending ? 'loading' : 'active'}
                size="medium"
                onPress={handleUpdateGroupName}
                style={styles.modalButton}
                disabled={!newGroupName.trim()}
              >
                Kaydet
              </GeliomButton>
            </View>
            </View>
          </ScrollView>
        </KeyboardAvoidingView>
      </Modal>

      {/* Ã–zel Durum Ekle Modal */}
      <Modal
        visible={statusModalVisible}
        transparent
        animationType="slide"
        onRequestClose={() => setStatusModalVisible(false)}
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={styles.modalOverlay}
        >
          <ScrollView
            keyboardShouldPersistTaps="handled"
            contentContainerStyle={styles.modalScrollContent}
          >
            <View style={[styles.modalContent, { backgroundColor: colors.cardBackground }]}>
            <Typography variant="h5" color={colors.text} style={styles.modalTitle}>
              Ã–zel Durum Ekle
            </Typography>
            
            <TextInput
              style={[styles.modalInput, { 
                backgroundColor: colors.background, 
                color: colors.text,
                borderColor: colors.stroke 
              }]}
              placeholder="Durum metni (Ã¶rn: ToplantÄ±dayÄ±m)"
              placeholderTextColor={colors.secondaryText}
              value={newStatusText}
              onChangeText={setNewStatusText}
              maxLength={50}
            />
            
            <TextInput
              style={[styles.modalInput, { 
                backgroundColor: colors.background, 
                color: colors.text,
                borderColor: colors.stroke 
              }]}
              placeholder="Emoji (opsiyonel, Ã¶rn: ğŸ“…)"
              placeholderTextColor={colors.secondaryText}
              value={newStatusEmoji}
              onChangeText={setNewStatusEmoji}
              maxLength={2}
            />
            
            {/* Notifies Switch */}
            <View style={[styles.switchContainer, { borderColor: colors.stroke }]}>
              <Typography variant="body" color={colors.text} style={{ flex: 1 }}>
                Bildirim gÃ¶nder
              </Typography>
              <Switch
                value={notifiesStatus}
                onValueChange={setNotifiesStatus}
                trackColor={{ false: colors.stroke, true: colors.primary }}
                thumbColor={colors.white}
              />
            </View>
            
            <View style={styles.modalActions}>
              <GeliomButton
                state="passive"
                size="medium"
                onPress={() => {
                  setStatusModalVisible(false);
                  setNewStatusText('');
                  setNewStatusEmoji('');
                  setNotifiesStatus(false);
                }}
                style={styles.modalButton}
              >
                Ä°ptal
              </GeliomButton>
              <GeliomButton
                state={createStatus.isPending ? 'loading' : 'active'}
                size="medium"
                onPress={handleCreateStatus}
                style={styles.modalButton}
                disabled={!newStatusText.trim()}
              >
                OluÅŸtur
              </GeliomButton>
            </View>
          </View>
          </ScrollView>
        </KeyboardAvoidingView>
      </Modal>

      {/* Ã–zel Mood Ekle Modal */}
      <Modal
        visible={moodModalVisible}
        transparent
        animationType="slide"
        onRequestClose={() => setMoodModalVisible(false)}
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={styles.modalOverlay}
        >
          <ScrollView
            keyboardShouldPersistTaps="handled"
            contentContainerStyle={styles.modalScrollContent}
          >
            <View style={[styles.modalContent, { backgroundColor: colors.cardBackground }]}>
            <Typography variant="h5" color={colors.text} style={styles.modalTitle}>
              Ã–zel Mood Ekle
            </Typography>
            
            <TextInput
              style={[styles.modalInput, { 
                backgroundColor: colors.background, 
                color: colors.text,
                borderColor: colors.stroke 
              }]}
              placeholder="Mood metni (Ã¶rn: HeyecanlÄ±)"
              placeholderTextColor={colors.secondaryText}
              value={newMoodText}
              onChangeText={setNewMoodText}
              maxLength={50}
            />
            
            <TextInput
              style={[styles.modalInput, { 
                backgroundColor: colors.background, 
                color: colors.text,
                borderColor: colors.stroke 
              }]}
              placeholder="Emoji (opsiyonel, Ã¶rn: ğŸ‰)"
              placeholderTextColor={colors.secondaryText}
              value={newMoodEmoji}
              onChangeText={setNewMoodEmoji}
              maxLength={2}
            />
            
            <View style={styles.modalActions}>
              <GeliomButton
                state="passive"
                size="medium"
                onPress={() => {
                  setMoodModalVisible(false);
                  setNewMoodText('');
                  setNewMoodEmoji('');
                }}
                style={styles.modalButton}
              >
                Ä°ptal
              </GeliomButton>
              <GeliomButton
                state={createMood.isPending ? 'loading' : 'active'}
                size="medium"
                onPress={handleCreateMood}
                style={styles.modalButton}
                disabled={!newMoodText.trim()}
              >
                OluÅŸtur
              </GeliomButton>
            </View>
          </View>
          </ScrollView>
        </KeyboardAvoidingView>
      </Modal>
    </BaseLayout>
  );
}

const styles = StyleSheet.create({
  rightIconContainer: {
    position: 'relative',
  },
  actionButton: {
    width: 36,
    height: 36,
    borderRadius: 18,
    borderWidth: 1,
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
  },
  badge: {
    position: 'absolute',
    top: -4,
    right: -4,
    minWidth: 18,
    height: 18,
    borderRadius: 9,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 4,
  },
  badgeText: {
    fontSize: 10,
    fontWeight: 'bold',
  },
  container: {
    flex: 1,
    paddingHorizontal: 12,
  },
  contentContainer: {
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 60,
    paddingHorizontal: 24,
  },
  inviteCard: {
    borderRadius: 16,
    borderWidth: 1.5,
    padding: 20,
    marginBottom: 24,
  },
  inviteCardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  inviteCodeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  inviteCode: {
    letterSpacing: 2,
    fontFamily: 'Comfortaa-Bold',
  },
  actionsContainer: {
    gap: 12,
  },
  memberButton: {
    borderRadius: 16,
    borderWidth: 1.5,
    padding: 16,
  },
  memberButtonContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  memberButtonText: {
    flex: 1,
    marginLeft: 12,
  },
  settingsSection: {
    marginBottom: 24,
  },
  sectionTitle: {
    marginBottom: 12,
    marginLeft: 4,
  },
  settingItem: {
    borderRadius: 12,
    borderWidth: 1,
    padding: 12,
    marginBottom: 8,
  },
  settingItemContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  settingItemText: {
    flex: 1,
    marginLeft: 12,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalScrollContent: {
    flexGrow: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContent: {
    width: '90%',
    maxWidth: 400,
    padding: 24,
    borderRadius: 16,
  },
  modalTitle: {
    marginBottom: 16,
    textAlign: 'center',
  },
  modalInput: {
    borderWidth: 1,
    borderRadius: 8,
    padding: 12,
    marginBottom: 12,
    fontSize: 16,
  },
  modalActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 12,
    marginTop: 8,
  },
  modalButton: {
    flex: 1,
  },
  switchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 12,
    paddingHorizontal: 4,
    marginBottom: 12,
    borderBottomWidth: 1,
  },
});
</file>

<file path="app/(drawer)/(group)/join-group.tsx">
import { useCreateJoinRequest, useGroupByInviteCode } from '@/api/groups';
import KeyboardAwareView from '@/components/KeyboardAwareView';
import { BaseLayout, GeliomButton, Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useTheme } from '@/contexts/ThemeContext';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useState } from 'react';
import { Alert, StyleSheet, TextInput, View } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function JoinGroupScreen() {
  const { user } = useAuth();
  const { colors } = useTheme();
  const router = useRouter();
  const insets = useSafeAreaInsets();
  const headerHeight = 56 + insets.top;

  const [inviteCode, setInviteCode] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [codeError, setCodeError] = useState<string | null>(null);

  // Davet kodu ile grubu bul
  const { data: group, isLoading: isLoadingGroup, refetch: refetchGroup } = useGroupByInviteCode(
    inviteCode.trim().toUpperCase()
  );

  const createJoinRequest = useCreateJoinRequest();

  const handleJoinRequest = async () => {
    if (!inviteCode.trim()) {
      setCodeError('Davet kodu gerekli');
      return;
    }

    if (!user?.id) {
      Alert.alert('Hata', 'KullanÄ±cÄ± bilgisi bulunamadÄ±');
      return;
    }

    if (!group) {
      setCodeError('GeÃ§ersiz davet kodu');
      return;
    }

    try {
      setIsSubmitting(true);
      setCodeError(null);

      await createJoinRequest.mutateAsync({
        group_id: group.id,
        requester_id: user.id,
        invite_code: inviteCode, // Pass the invite code
      });

      Alert.alert(
        'Ä°stek GÃ¶nderildi',
        `${group.name} grubuna katÄ±lma isteÄŸiniz gÃ¶nderildi. Grup kurucusu onayladÄ±ÄŸÄ±nda gruba katÄ±lacaksÄ±nÄ±z.`,
        [
          {
            text: 'Tamam',
            onPress: () => router.back(),
          },
        ]
      );
    } catch (error: any) {
      setCodeError(error.message || 'Ä°stek gÃ¶nderilemedi');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleCodeChange = (text: string) => {
    // Sadece bÃ¼yÃ¼k harf ve rakam kabul et
    const cleaned = text.toUpperCase().replace(/[^A-Z0-9]/g, '');
    setInviteCode(cleaned);
    setCodeError(null);

    // EÄŸer kod 8 karakter ise otomatik arama yap
    if (cleaned.length === 8) {
      refetchGroup();
    }
  };

  return (
    <BaseLayout
      headerShow={true}
      header={{
        leftIcon: {
          icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
          onPress: () => router.back(),
        },
        title: <Typography variant="h5" color={colors.text}>Gruba KatÄ±l</Typography>,
        backgroundColor: colors.background,
      }}
    >
      <KeyboardAwareView contentContainerStyle={styles.contentContainer} keyboardVerticalOffset={headerHeight}>
        <View style={styles.headerSection}>
          <View style={[styles.iconContainer, { backgroundColor: colors.primary + '20' }]}>
            <Ionicons name="people" size={48} color={colors.primary} />
          </View>
          <Typography variant="h3" color={colors.text} style={{ marginTop: 24, marginBottom: 8 }}>
            Davet Kodu ile KatÄ±l
          </Typography>
          <Typography variant="body" color={colors.secondaryText} style={{ textAlign: 'center' }}>
            Grup kurucusundan aldÄ±ÄŸÄ±nÄ±z 8 haneli davet kodunu girin
          </Typography>
        </View>

        <View style={styles.form}>
          <View style={styles.inputGroup}>
            <Typography variant="label" color={colors.text} style={{ marginBottom: 8 }}>
              Davet Kodu
            </Typography>
            <TextInput
              style={[
                styles.input,
                {
                  backgroundColor: colors.cardBackground,
                  color: colors.text,
                  borderColor: codeError ? colors.error : group ? colors.success : colors.stroke,
                },
              ]}
              placeholder="ABC12345"
              placeholderTextColor={colors.secondaryText + '80'}
              value={inviteCode}
              onChangeText={handleCodeChange}
              maxLength={8}
              autoCapitalize="characters"
              autoCorrect={false}
            />
            {codeError && (
              <Typography variant="caption" color={colors.error} style={{ marginTop: 4 }}>
                {codeError}
              </Typography>
            )}
            {group && !codeError && (
              <Typography variant="caption" color={colors.success} style={{ marginTop: 4 }}>
                âœ“ {group.name} grubu bulundu
              </Typography>
            )}
          </View>

          {group && (
            <View style={[styles.groupInfo, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}>
              <View style={styles.groupInfoHeader}>
                <View style={[styles.groupIcon, { backgroundColor: colors.primary + '20' }]}>
                  <Ionicons
                    name={group.type === 'family' ? 'home' : group.type === 'work' ? 'briefcase' : 'people'}
                    size={24}
                    color={colors.primary}
                  />
                </View>
                <View style={styles.groupInfoText}>
                  <Typography variant="h5" color={colors.text} numberOfLines={1}>
                    {group.name}
                  </Typography>
                  <Typography variant="caption" color={colors.secondaryText}>
                    {group.type === 'family' ? 'Aile' : group.type === 'friends' ? 'ArkadaÅŸlar' : group.type === 'work' ? 'Ä°ÅŸ' : 'DiÄŸer'} â€¢ Kurucu: {group.owner?.display_name || 'Bilinmiyor'}
                  </Typography>
                </View>
              </View>
            </View>
          )}

          <GeliomButton
            state={isSubmitting ? 'loading' : group ? 'active' : 'passive'}
            layout="full-width"
            size="large"
            icon="send"
            onPress={handleJoinRequest}
            disabled={!group || isSubmitting}
          >
            {isSubmitting ? 'GÃ¶nderiliyor...' : 'KatÄ±lma Ä°steÄŸi GÃ¶nder'}
          </GeliomButton>
        </View>
      </KeyboardAwareView>
    </BaseLayout>
  );
}

const styles = StyleSheet.create({
  contentContainer: {
    padding: 24,
    paddingBottom: 100,
  },
  headerSection: {
    alignItems: 'center',
    marginBottom: 32,
    paddingHorizontal: 20,
  },
  iconContainer: {
    width: 96,
    height: 96,
    borderRadius: 48,
    justifyContent: 'center',
    alignItems: 'center',
  },
  form: {
    gap: 24,
  },
  inputGroup: {
    gap: 4,
  },
  input: {
    borderWidth: 1.5,
    borderRadius: 16,
    paddingHorizontal: 16,
    paddingVertical: 16,
    fontSize: 20,
    fontFamily: 'Comfortaa-Bold',
    letterSpacing: 2,
    textAlign: 'center',
  },
  groupInfo: {
    borderRadius: 16,
    borderWidth: 1.5,
    padding: 16,
  },
  groupInfoHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  groupIcon: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  groupInfoText: {
    flex: 1,
  },
});
</file>

<file path="app/(drawer)/(group)/manage-members.tsx">
import { useMutedNotificationsList, useToggleMuteUser } from '@/api';
import { useGroupMembers, useLeaveGroup, useTransferGroupOwnership } from '@/api/groups';
import { useDeleteNickname, useGroupNicknames, useUpsertNickname } from '@/api/nicknames';
import { useUpdateUserAvatar } from '@/api/users';
import { AvatarSelector, BaseLayout, GeliomButton, Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useGroupContext } from '@/contexts/GroupContext';
import { useTheme } from '@/contexts/ThemeContext';
import type { GroupMemberWithUser, User } from '@/types/database';
import { getAvatarSource } from '@/utils/avatar';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useState } from 'react';
import {
  ActivityIndicator,
  Alert,
  FlatList,
  Image,
  KeyboardAvoidingView,
  Modal,
  Platform,
  ScrollView,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  View
} from 'react-native';

export default function ManageMembersScreen() {
  const { colors } = useTheme();
  const { user } = useAuth();
  const { selectedGroup } = useGroupContext();
  const router = useRouter();
  
  const [selectedMember, setSelectedMember] = useState<GroupMemberWithUser | null>(null);
  const [nicknameModalVisible, setNicknameModalVisible] = useState(false);
  const [nicknameText, setNicknameText] = useState('');
  const [transferOwnerModalVisible, setTransferOwnerModalVisible] = useState(false);
  const [avatarSelectorVisible, setAvatarSelectorVisible] = useState(false);
  
  const { data: members = [], isLoading: membersLoading } = useGroupMembers(selectedGroup?.id || '');
  const { data: nicknames = [] } = useGroupNicknames(selectedGroup?.id || '');
  const { data: mutedUsers = [] } = useMutedNotificationsList(user?.id || '');
  
  const upsertNickname = useUpsertNickname();
  const deleteNickname = useDeleteNickname();
  const toggleMute = useToggleMuteUser();
  const transferOwnership = useTransferGroupOwnership();
  const leaveGroup = useLeaveGroup();
  const updateAvatar = useUpdateUserAvatar();
  
  const isOwner = selectedGroup?.owner_id === user?.id;
  const mutedUserIds = new Set(mutedUsers.map(m => m.muted_user_id));
  
  // KullanÄ±cÄ±nÄ±n nickname'ini bul (mevcut kullanÄ±cÄ± iÃ§in)
  const getNicknameForUser = (targetUserId: string) => {
    const nickname = nicknames.find(
      n => n.setter_user_id === user?.id && n.target_user_id === targetUserId
    );
    return nickname?.nickname;
  };
  
  // KullanÄ±cÄ± sessize alÄ±nmÄ±ÅŸ mÄ±?
  const isMuted = (targetUserId: string) => {
    return mutedUserIds.has(targetUserId);
  };
  
  const handleNicknamePress = (member: GroupMemberWithUser) => {
    const currentNickname = getNicknameForUser(member.user_id);
    setSelectedMember(member);
    setNicknameText(currentNickname || '');
    setNicknameModalVisible(true);
  };
  
  const handleSaveNickname = async () => {
    if (!selectedMember || !user?.id || !selectedGroup?.id) return;
    
    if (nicknameText.trim()) {
      try {
        await upsertNickname.mutateAsync({
          group_id: selectedGroup.id,
          setter_user_id: user.id,
          target_user_id: selectedMember.user_id,
          nickname: nicknameText.trim(),
        });
        setNicknameModalVisible(false);
        setNicknameText('');
        setSelectedMember(null);
      } catch (error) {
        console.error('Nickname kaydetme hatasÄ±:', error);
        Alert.alert('Hata', 'Nickname kaydedilemedi');
      }
    } else {
      // BoÅŸ ise sil
      try {
        await deleteNickname.mutateAsync({
          groupId: selectedGroup.id,
          setterUserId: user.id,
          targetUserId: selectedMember.user_id,
        });
        setNicknameModalVisible(false);
        setNicknameText('');
        setSelectedMember(null);
      } catch (error) {
        console.error('Nickname silme hatasÄ±:', error);
        Alert.alert('Hata', 'Nickname silinemedi');
      }
    }
  };
  
  const handleToggleMute = async (member: GroupMemberWithUser) => {
    if (!user?.id) return;
    
    const currentlyMuted = isMuted(member.user_id);
    
    try {
      await toggleMute.mutateAsync({
        muterUserId: user.id,
        mutedUserId: member.user_id,
        isCurrentlyMuted: currentlyMuted,
      });
    } catch (error) {
      console.error('Sessize alma hatasÄ±:', error);
      Alert.alert('Hata', 'Ä°ÅŸlem baÅŸarÄ±sÄ±z oldu');
    }
  };
  
  const handleTransferOwnership = async (member: GroupMemberWithUser) => {
    if (!selectedGroup?.id || !isOwner) return;
    
    Alert.alert(
      'YÃ¶neticilik Devri',
      `${member.user?.display_name || member.user?.custom_user_id} kullanÄ±cÄ±sÄ±na yÃ¶neticiliÄŸi devretmek istediÄŸinize emin misiniz?`,
      [
        { text: 'Ä°ptal', style: 'cancel' },
        {
          text: 'Devret',
          style: 'destructive',
          onPress: async () => {
            try {
              await transferOwnership.mutateAsync({
                groupId: selectedGroup.id,
                newOwnerId: member.user_id,
              });
              setTransferOwnerModalVisible(false);
              setSelectedMember(null);
              Alert.alert('BaÅŸarÄ±lÄ±', 'YÃ¶neticilik devredildi');
              router.back();
            } catch (error) {
              console.error('YÃ¶neticilik devri hatasÄ±:', error);
              Alert.alert('Hata', 'YÃ¶neticilik devredilemedi');
            }
          },
        },
      ]
    );
  };
  
  const handleAvatarSelect = async (avatar: string | null) => {
    if (!user?.id) {
      Alert.alert('Hata', 'KullanÄ±cÄ± bilgisi bulunamadÄ±');
      return;
    }
    
    try {
      await updateAvatar.mutateAsync({
        userId: user.id,
        avatar,
      });
      // useUpdateUserAvatar hook'u zaten userKeys.all, userKeys.detail ve userKeys.current query'lerini invalidate ediyor
      Alert.alert('BaÅŸarÄ±lÄ±', 'Avatar gÃ¼ncellendi');
    } catch (error: any) {
      console.error('Avatar gÃ¼ncelleme hatasÄ±:', error);
      const errorMessage = error?.message || 'Avatar gÃ¼ncellenemedi';
      Alert.alert('Hata', errorMessage);
    }
  };

  const handleRemoveMember = async (member: GroupMemberWithUser) => {
    if (!selectedGroup?.id || !isOwner) return;
    
    if (member.user_id === user?.id) {
      // Kendini Ã§Ä±karma
      Alert.alert(
        'Gruptan AyrÄ±l',
        'Gruptan ayrÄ±lmak istediÄŸinize emin misiniz?',
        [
          { text: 'Ä°ptal', style: 'cancel' },
          {
            text: 'AyrÄ±l',
            style: 'destructive',
            onPress: async () => {
              try {
                await leaveGroup.mutateAsync({
                  groupId: selectedGroup.id,
                  userId: user.id,
                });
                router.replace('/(drawer)/home');
              } catch (error) {
                console.error('Gruptan ayrÄ±lma hatasÄ±:', error);
                Alert.alert('Hata', 'Gruptan ayrÄ±lamadÄ±nÄ±z');
              }
            },
          },
        ]
      );
    } else {
      // BaÅŸkasÄ±nÄ± Ã§Ä±karma (sadece owner)
      Alert.alert(
        'Ãœyeyi Ã‡Ä±kar',
        `${member.user?.display_name || member.user?.custom_user_id} kullanÄ±cÄ±sÄ±nÄ± gruptan Ã§Ä±karmak istediÄŸinize emin misiniz?`,
        [
          { text: 'Ä°ptal', style: 'cancel' },
          {
            text: 'Ã‡Ä±kar',
            style: 'destructive',
            onPress: async () => {
              try {
                await leaveGroup.mutateAsync({
                  groupId: selectedGroup.id,
                  userId: member.user_id,
                });
                Alert.alert('BaÅŸarÄ±lÄ±', 'Ãœye gruptan Ã§Ä±karÄ±ldÄ±');
              } catch (error) {
                console.error('Ãœye Ã§Ä±karma hatasÄ±:', error);
                Alert.alert('Hata', 'Ãœye Ã§Ä±karÄ±lamadÄ±');
              }
            },
          },
        ]
      );
    }
  };
  
  if (!selectedGroup) {
    return (
      <BaseLayout
        headerShow={true}
        header={{
          leftIcon: {
            icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
            onPress: () => router.back(),
          },
          title: <Typography variant="h5" color={colors.text}>Ãœyeleri YÃ¶net</Typography>,
          backgroundColor: colors.background,
        }}
      >
        <View style={[styles.container, { backgroundColor: colors.background }]}>
          <Typography variant="h6" style={styles.emptyText}>
            LÃ¼tfen bir grup seÃ§in
          </Typography>
        </View>
      </BaseLayout>
    );
  }
  
  if (membersLoading) {
    return (
      <BaseLayout
        headerShow={true}
        header={{
          leftIcon: {
            icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
            onPress: () => router.back(),
          },
          title: <Typography variant="h5" color={colors.text}>Ãœyeleri YÃ¶net</Typography>,
          backgroundColor: colors.background,
        }}
      >
        <View style={[styles.container, styles.centerContent, { backgroundColor: colors.background }]}>
          <ActivityIndicator size="large" color={colors.primary} />
        </View>
      </BaseLayout>
    );
  }
  
  const renderMemberItem = ({ item }: { item: GroupMemberWithUser }) => {
    const memberUser = item.user as User;
    const isMemberOwner = selectedGroup.owner_id === item.user_id;
    const isCurrentUser = item.user_id === user?.id;
    const nickname = getNicknameForUser(item.user_id);
    const muted = isMuted(item.user_id);
    
    return (
      <View style={[styles.memberCard, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}>
        <View style={styles.memberHeader}>
          <View style={styles.memberLeft}>
            <View style={styles.avatarContainer}>
              <Image
                source={getAvatarSource(memberUser.avatar)}
                style={styles.avatarImage}
                resizeMode="cover"
              />
            </View>
            <View style={styles.memberInfo}>
              <Typography variant="body" fontWeight="semibold" style={styles.memberName}>
                {nickname || memberUser.display_name || memberUser.custom_user_id}
              </Typography>
              {nickname && (
                <Typography variant="caption" style={[styles.memberSubtext, { color: colors.secondaryText }]}>
                  {memberUser.display_name || memberUser.custom_user_id}
                </Typography>
              )}
              <View style={styles.badges}>
                {isMemberOwner && (
                  <Typography variant="caption" style={[styles.badge, { color: colors.primary }]}>
                    YÃ¶netici
                  </Typography>
                )}
                {muted && (
                  <Typography variant="caption" style={[styles.badge, { color: colors.error }]}>
                    Sessize AlÄ±ndÄ±
                  </Typography>
                )}
              </View>
            </View>
          </View>
          {isCurrentUser && (
            <TouchableOpacity
              onPress={() => setAvatarSelectorVisible(true)}
              style={[styles.avatarEditButton, { backgroundColor: colors.primary + '20' }]}
            >
              <Ionicons name="camera" size={18} color={colors.primary} />
            </TouchableOpacity>
          )}
        </View>
        
        <View style={styles.memberActions}>
          {/* Nickname */}
          <TouchableOpacity
            onPress={() => handleNicknamePress(item)}
            style={[styles.actionButton, { backgroundColor: colors.primary + '20' }]}
          >
            <Typography variant="bodySmall" style={{ color: colors.primary }}>
              {nickname ? 'âœï¸' : 'â•'} Takma Ad
            </Typography>
          </TouchableOpacity>
          
          {/* Sessize Al/KaldÄ±r */}
          <TouchableOpacity
            onPress={() => handleToggleMute(item)}
            style={[styles.actionButton, { backgroundColor: muted ? colors.error + '20' : colors.secondary + '20' }]}
          >
            <Typography variant="bodySmall" style={{ color: muted ? colors.error : colors.secondary }}>
              {muted ? 'ğŸ”‡ AÃ§' : 'ğŸ”• Sessize Al'}
            </Typography>
          </TouchableOpacity>
          
          {/* YÃ¶neticilik Devri (sadece owner, kendisi hariÃ§) */}
          {isOwner && !isCurrentUser && !isMemberOwner && (
            <TouchableOpacity
              onPress={() => {
                setSelectedMember(item);
                setTransferOwnerModalVisible(true);
              }}
              style={[styles.actionButton, { backgroundColor: colors.warning + '20' }]}
            >
              <Typography variant="bodySmall" style={{ color: colors.warning }}>
                ğŸ‘‘ YÃ¶netici Yap
              </Typography>
            </TouchableOpacity>
          )}
          
          {/* Ãœyeyi Ã‡Ä±kar (sadece owner veya kendisi) */}
          {(isOwner || isCurrentUser) && (
            <TouchableOpacity
              onPress={() => handleRemoveMember(item)}
              style={[styles.actionButton, { backgroundColor: colors.error + '20' }]}
            >
              <Typography variant="bodySmall" style={{ color: colors.error }}>
                {isCurrentUser ? 'ğŸšª AyrÄ±l' : 'âŒ Ã‡Ä±kar'}
              </Typography>
            </TouchableOpacity>
          )}
        </View>
      </View>
    );
  };
  
  return (
    <BaseLayout
      headerShow={true}
      header={{
        leftIcon: {
          icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
          onPress: () => router.back(),
        },
        title: <Typography variant="h5" color={colors.text}>Ãœyeleri YÃ¶net</Typography>,
        backgroundColor: colors.background,
      }}
    >
      <View style={[styles.container, { backgroundColor: colors.background }]}>
        <FlatList
          data={members}
          renderItem={renderMemberItem}
          keyExtractor={(item) => item.user_id}
          contentContainerStyle={styles.listContent}
          ListEmptyComponent={
            <View style={styles.centerContent}>
              <Typography variant="body" style={styles.emptyText}>
                Grupta Ã¼ye yok
              </Typography>
            </View>
          }
        />
      
      {/* Nickname Modal */}
      <Modal
        visible={nicknameModalVisible}
        transparent
        animationType="slide"
        onRequestClose={() => setNicknameModalVisible(false)}
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={styles.modalOverlay}
        >
          <ScrollView
            keyboardShouldPersistTaps="handled"
            contentContainerStyle={styles.modalScrollContent}
          >
            <View style={[styles.modalContent, { backgroundColor: colors.cardBackground }]}>
            <Typography variant="h6" style={styles.modalTitle}>
              Takma Ad {selectedMember?.user?.display_name ? `(${selectedMember.user.display_name})` : ''}
            </Typography>
            
            <TextInput
              style={[styles.input, { 
                backgroundColor: colors.background, 
                color: colors.text,
                borderColor: colors.stroke 
              }]}
              placeholder="Takma ad girin (boÅŸ bÄ±rakÄ±rsanÄ±z silinir)"
              placeholderTextColor={colors.secondaryText}
              value={nicknameText}
              onChangeText={setNicknameText}
              maxLength={50}
            />
            
            <View style={styles.modalActions}>
              <GeliomButton
                state="passive"
                size="medium"
                onPress={() => {
                  setNicknameModalVisible(false);
                  setNicknameText('');
                  setSelectedMember(null);
                }}
                style={styles.modalButton}
              >
                Ä°ptal
              </GeliomButton>
              <GeliomButton
                state={upsertNickname.isPending || deleteNickname.isPending ? 'loading' : 'active'}
                size="medium"
                onPress={handleSaveNickname}
                style={styles.modalButton}
              >
                Kaydet
              </GeliomButton>
            </View>
          </View>
          </ScrollView>
        </KeyboardAvoidingView>
      </Modal>
      
      {/* Transfer Ownership Modal */}
      <Modal
        visible={transferOwnerModalVisible}
        transparent
        animationType="slide"
        onRequestClose={() => setTransferOwnerModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={[styles.modalContent, { backgroundColor: colors.cardBackground }]}>
            <Typography variant="h6" style={styles.modalTitle}>
              YÃ¶neticilik Devri
            </Typography>
            
            <Typography variant="body" style={[styles.modalText, { color: colors.text }]}>
              {selectedMember?.user?.display_name || selectedMember?.user?.custom_user_id} kullanÄ±cÄ±sÄ±na yÃ¶neticiliÄŸi devretmek istediÄŸinize emin misiniz?
            </Typography>
            
            <View style={styles.modalActions}>
              <GeliomButton
                state="passive"
                size="medium"
                onPress={() => {
                  setTransferOwnerModalVisible(false);
                  setSelectedMember(null);
                }}
                style={styles.modalButton}
              >
                Ä°ptal
              </GeliomButton>
              <GeliomButton
                state={transferOwnership.isPending ? 'loading' : 'active'}
                size="medium"
                onPress={() => selectedMember && handleTransferOwnership(selectedMember)}
                style={styles.modalButton}
              >
                Devret
              </GeliomButton>
            </View>
          </View>
        </View>
      </Modal>

      {/* Avatar Selector Modal */}
      <AvatarSelector
        visible={avatarSelectorVisible}
        currentAvatar={user?.avatar}
        onSelect={handleAvatarSelect}
        onClose={() => setAvatarSelectorVisible(false)}
      />
      </View>
    </BaseLayout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  centerContent: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  listContent: {
    padding: 16,
    paddingBottom: 100,
  },
  memberCard: {
    padding: 12,
    borderRadius: 12,
    marginBottom: 8,
    borderWidth: 1,
  },
  memberHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  memberLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  avatarContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    marginRight: 12,
    overflow: 'hidden',
  },
  avatarImage: {
    width: 40,
    height: 40,
    borderRadius: 20,
  },
  avatarEditButton: {
    width: 32,
    height: 32,
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
  },
  memberInfo: {
    flex: 1,
  },
  memberName: {
    marginBottom: 2,
  },
  memberSubtext: {
    marginBottom: 4,
  },
  badges: {
    flexDirection: 'row',
    gap: 8,
    marginTop: 4,
  },
  badge: {
    fontWeight: '600',
  },
  memberActions: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 6,
  },
  actionButton: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 8,
  },
  emptyText: {
    textAlign: 'center',
    marginTop: 32,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalScrollContent: {
    flexGrow: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContent: {
    width: '90%',
    maxWidth: 400,
    padding: 24,
    borderRadius: 16,
  },
  modalTitle: {
    marginBottom: 16,
    textAlign: 'center',
  },
  modalText: {
    marginBottom: 24,
    textAlign: 'center',
  },
  input: {
    borderWidth: 1,
    borderRadius: 8,
    padding: 12,
    marginBottom: 24,
    fontSize: 16,
  },
  modalActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 12,
  },
  modalButton: {
    flex: 1,
  },
});
</file>

<file path="app/(drawer)/(group)/reorder-status-mood.tsx">
import { useMoods } from '@/api/moods';
import { useCustomStatuses, useDefaultStatuses } from '@/api/statuses';
import AddStatusMoodModal from '@/components/dashboard/AddStatusMoodModal';
import { BaseLayout, GeliomButton, Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useGroupContext } from '@/contexts/GroupContext';
import { useTheme } from '@/contexts/ThemeContext';
import { useManageStatusMood } from '@/hooks/useManageStatusMood';
import type { Mood, Status } from '@/types/database';
import { getMoodOrder, getStatusOrder, saveMoodOrder, saveStatusOrder } from '@/utils/storage';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useEffect, useMemo, useState } from 'react';
import { ActivityIndicator, StyleSheet, TouchableOpacity, View } from 'react-native';
import DraggableFlatList, { RenderItemParams, ScaleDecorator } from 'react-native-draggable-flatlist';

type ItemType = Status | Mood;

export default function ReorderStatusMoodScreen() {
  const { colors } = useTheme();
  const { user } = useAuth();
  const { selectedGroup } = useGroupContext();
  const router = useRouter();

  const [activeTab, setActiveTab] = useState<'status' | 'mood'>('status');
  const [statusOrder, setStatusOrder] = useState<number[]>([]);
  const [moodOrder, setMoodOrder] = useState<number[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [hasChanges, setHasChanges] = useState(false);
  const [isModalVisible, setIsModalVisible] = useState(false);

  // Status ve mood verilerini Ã§ek
  const { data: defaultStatuses = [] } = useDefaultStatuses();
  const { data: customStatuses = [] } = useCustomStatuses(selectedGroup?.id || '', user?.id);
  const { data: allMoods = [] } = useMoods(selectedGroup?.id);

  // Management Hook
  const { handleAddStatus, handleAddMood, handleDeleteStatus, handleDeleteMood, checkSubscriptionAndProceed } = useManageStatusMood(selectedGroup?.id || '');

  // Local storage'dan sÄ±ralamayÄ± yÃ¼kle
  useEffect(() => {
    const loadOrders = async () => {
      if (user?.id) {
        const [statusOrderData, moodOrderData] = await Promise.all([
          getStatusOrder(user.id),
          getMoodOrder(user.id),
        ]);
        setStatusOrder(statusOrderData);
        setMoodOrder(moodOrderData);
        setIsLoading(false);
      }
    };
    loadOrders();
  }, [user?.id]);

  // Status'leri birleÅŸtir ve sÄ±rala (tÃ¼m status'ler - custom + default)
  const sortedStatuses = useMemo(() => {
    const allStatuses = [...customStatuses, ...defaultStatuses];

    if (statusOrder.length === 0) {
      // SÄ±ralama yoksa: Custom'lar Ã¶nce, sonra default'lar
      return allStatuses;
    }

    const ordered: Status[] = [];
    const unordered: Status[] = [];

    // SÄ±ralamaya gÃ¶re tÃ¼m status'leri ekle (custom + default)
    statusOrder.forEach((statusId) => {
      const status = allStatuses.find(s => s.id === statusId);
      if (status) {
        ordered.push(status);
      }
    });

    // SÄ±ralamada olmayan status'leri sona ekle
    allStatuses.forEach((status) => {
      if (!statusOrder.includes(status.id) && !ordered.find(s => s.id === status.id)) {
        unordered.push(status);
      }
    });

    return [...ordered, ...unordered];
  }, [customStatuses, defaultStatuses, statusOrder]);

  // Mood'larÄ± sÄ±rala (tÃ¼m mood'lar - custom + default)
  const sortedMoods = useMemo(() => {
    if (moodOrder.length === 0) {
      // SÄ±ralama yoksa: Custom'lar Ã¶nce, sonra default'lar
      const customMoods = allMoods.filter(m => m.group_id != null);
      const defaultMoods = allMoods.filter(m => m.group_id == null);
      return [...customMoods, ...defaultMoods];
    }

    const ordered: Mood[] = [];
    const unordered: Mood[] = [];

    // SÄ±ralamaya gÃ¶re tÃ¼m mood'larÄ± ekle (custom + default)
    moodOrder.forEach((moodId) => {
      const mood = allMoods.find(m => m.id === moodId);
      if (mood) {
        ordered.push(mood);
      }
    });

    // SÄ±ralamada olmayan mood'larÄ± sona ekle
    allMoods.forEach((mood) => {
      if (!moodOrder.includes(mood.id) && !ordered.find(m => m.id === mood.id)) {
        unordered.push(mood);
      }
    });

    return [...ordered, ...unordered];
  }, [allMoods, moodOrder]);

  const handleStatusDragEnd = ({ data }: { data: Status[] }) => {
    const newOrder = data.map(s => s.id);
    setStatusOrder(newOrder);
    setHasChanges(true);
  };

  const handleMoodDragEnd = ({ data }: { data: Mood[] }) => {
    const newOrder = data.map(m => m.id);
    setMoodOrder(newOrder);
    setHasChanges(true);
  };

  const handleSave = async () => {
    if (!user?.id) return;

    try {
      await Promise.all([
        saveStatusOrder(user.id, statusOrder),
        saveMoodOrder(user.id, moodOrder),
      ]);
      setHasChanges(false);
      router.back();
    } catch (error) {
      console.error('SÄ±ralama kaydetme hatasÄ±:', error);
    }
  };

  const onSaveItem = (text: string, emoji: string) => {
    if (activeTab === 'status') {
      handleAddStatus(text, emoji);
    } else {
      handleAddMood(text, emoji);
    }
  };

  const renderStatusItem = ({ item, drag, isActive }: RenderItemParams<Status>) => {
    const isCustom = item.is_custom;

    return (
      <ScaleDecorator>
        <TouchableOpacity
          onLongPress={drag}
          disabled={isActive}
          style={[
            styles.item,
            {
              backgroundColor: colors.cardBackground,
              borderColor: isActive ? colors.primary : colors.stroke,
              opacity: isActive ? 0.8 : 1,
            },
          ]}
        >
          <View style={styles.itemContent}>
            <Ionicons name="reorder-three-outline" size={24} color={colors.secondaryText} style={styles.dragHandle} />
            {item.emoji && (
              <Typography variant="h6" style={{ marginRight: 8 }}>{item.emoji}</Typography>
            )}
            <Typography variant="body" color={colors.text} style={{ flex: 1 }}>
              {item.text}
            </Typography>
            {isCustom && (
              <TouchableOpacity onPress={() => handleDeleteStatus(item.id)} style={styles.deleteButton}>
                <Ionicons name="trash-outline" size={20} color={colors.error} />
              </TouchableOpacity>
            )}
          </View>
        </TouchableOpacity>
      </ScaleDecorator>
    );
  };

  const renderMoodItem = ({ item, drag, isActive }: RenderItemParams<Mood>) => {
    const isCustom = item.group_id != null;

    return (
      <ScaleDecorator>
        <TouchableOpacity
          onLongPress={drag}
          disabled={isActive}
          style={[
            styles.item,
            {
              backgroundColor: colors.cardBackground,
              borderColor: isActive ? colors.primary : colors.stroke,
              opacity: isActive ? 0.8 : 1,
            },
          ]}
        >
          <View style={styles.itemContent}>
            <Ionicons name="reorder-three-outline" size={24} color={colors.secondaryText} style={styles.dragHandle} />
            {item.emoji && (
              <Typography variant="h6" style={{ marginRight: 8 }}>{item.emoji}</Typography>
            )}
            <Typography variant="body" color={colors.text} style={{ flex: 1 }}>
              {item.text}
            </Typography>
            {isCustom && (
              <TouchableOpacity onPress={() => handleDeleteMood(item.id)} style={styles.deleteButton}>
                <Ionicons name="trash-outline" size={20} color={colors.error} />
              </TouchableOpacity>
            )}
          </View>
        </TouchableOpacity>
      </ScaleDecorator>
    );
  };

  if (isLoading) {
    return (
      <BaseLayout
        headerShow={true}
        header={{
          leftIcon: {
            icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
            onPress: () => router.back(),
          },
          title: <Typography variant="h5" color={colors.text}>Status & Mood YÃ¶netimi</Typography>,
          backgroundColor: colors.background,
          style: { borderBottomWidth: 0 },
        }}
      >
        <View style={[styles.loadingContainer, { backgroundColor: colors.background }]}>
          <ActivityIndicator size="large" color={colors.primary} />
        </View>
      </BaseLayout>
    );
  }

  return (
    <BaseLayout
      headerShow={true}
      header={{
        leftIcon: {
          icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
          onPress: () => router.back(),
        },
        title: <Typography variant="h5" color={colors.text}>Status & Mood YÃ¶netimi</Typography>,
        rightIcon: {
          icon: hasChanges ? (
            <GeliomButton
              state="active"
              size="small"
              onPress={handleSave}
            >
              Kaydet
            </GeliomButton>
          ) : (
            <TouchableOpacity onPress={() => checkSubscriptionAndProceed(() => setIsModalVisible(true))}>
              <Ionicons name="add" size={28} color={colors.primary} />
            </TouchableOpacity>
          ),
          onPress: hasChanges ? handleSave : () => checkSubscriptionAndProceed(() => setIsModalVisible(true)),
        },
        backgroundColor: colors.background,
        style: { borderBottomWidth: 0 },
      }}
    >
      <View style={[styles.container, { backgroundColor: colors.background }]}>
        {/* Tab Selector */}
        <View style={[styles.tabContainer, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}>
          <TouchableOpacity
            onPress={() => setActiveTab('status')}
            style={[
              styles.tab,
              activeTab === 'status' && { backgroundColor: colors.primary },
            ]}
          >
            <Typography
              variant="body"
              color={activeTab === 'status' ? colors.white : colors.text}
              fontWeight={activeTab === 'status' ? 'semibold' : 'regular'}
            >
              Status
            </Typography>
          </TouchableOpacity>
          <TouchableOpacity
            onPress={() => setActiveTab('mood')}
            style={[
              styles.tab,
              activeTab === 'mood' && { backgroundColor: colors.primary },
            ]}
          >
            <Typography
              variant="body"
              color={activeTab === 'mood' ? colors.white : colors.text}
              fontWeight={activeTab === 'mood' ? 'semibold' : 'regular'}
            >
              Mood
            </Typography>
          </TouchableOpacity>
        </View>

        {/* Info Text */}
        <View style={styles.infoContainer}>
          <Typography variant="caption" color={colors.secondaryText} style={{ textAlign: 'center', paddingHorizontal: 16 }}>
            TÃ¼m status/mood'larÄ± sÃ¼rÃ¼kleyip bÄ±rakarak sÄ±ralayabilirsiniz. Ã–zel olanlarÄ± silebilirsiniz.
          </Typography>
        </View>

        {/* Status List */}
        {activeTab === 'status' && (
          <View style={styles.listContainer}>
            <View style={styles.section}>
              <Typography variant="h6" color={colors.text} style={styles.sectionTitle}>
                Status'ler
              </Typography>
              <DraggableFlatList
                data={sortedStatuses}
                onDragEnd={handleStatusDragEnd}
                keyExtractor={(item) => `status-${item.id}`}
                renderItem={renderStatusItem}
                contentContainerStyle={styles.listContent}
              />
            </View>
          </View>
        )}

        {/* Mood List */}
        {activeTab === 'mood' && (
          <View style={styles.listContainer}>
            <View style={styles.section}>
              <Typography variant="h6" color={colors.text} style={styles.sectionTitle}>
                Mood'lar
              </Typography>
              <DraggableFlatList
                data={sortedMoods}
                onDragEnd={handleMoodDragEnd}
                keyExtractor={(item) => `mood-${item.id}`}
                renderItem={renderMoodItem}
                contentContainerStyle={styles.listContent}
              />
            </View>
          </View>
        )}

        <AddStatusMoodModal
          visible={isModalVisible}
          type={activeTab}
          onClose={() => setIsModalVisible(false)}
          onSave={onSaveItem}
        />
      </View>
    </BaseLayout>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  tabContainer: {
    flexDirection: 'row',
    margin: 16,
    padding: 4,
    borderRadius: 12,
    borderWidth: 1,
  },
  tab: {
    flex: 1,
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  infoContainer: {
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  listContainer: {
    flex: 1,
  },
  section: {
    marginBottom: 24,
  },
  sectionTitle: {
    paddingHorizontal: 16,
    marginBottom: 12,
  },
  listContent: {
    paddingHorizontal: 16,
    paddingBottom: 100,
  },
  item: {
    flexDirection: 'row',
    padding: 16,
    borderRadius: 12,
    borderWidth: 1,
    marginBottom: 8,
  },
  itemContent: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  dragHandle: {
    marginRight: 12,
  },
  deleteButton: {
    padding: 8,
    marginLeft: 8,
  },
});
</file>

<file path="app/(drawer)/(group)/search-user.tsx">
import { useCreateJoinRequest } from '@/api/groups';
import { useUserByCustomId } from '@/api/users';
import KeyboardAwareView from '@/components/KeyboardAwareView';
import { BaseLayout, GeliomButton, Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useGroupContext } from '@/contexts/GroupContext';
import { useTheme } from '@/contexts/ThemeContext';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useState } from 'react';
import { Alert, StyleSheet, TextInput, View } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function SearchUserScreen() {
  const { user } = useAuth();
  const { selectedGroup } = useGroupContext();
  const { colors } = useTheme();
  const router = useRouter();
  const insets = useSafeAreaInsets();
  const headerHeight = 56 + insets.top;

  const [customUserId, setCustomUserId] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [searchError, setSearchError] = useState<string | null>(null);

  // Custom user ID ile kullanÄ±cÄ± ara
  const {
    data: foundUser,
    isLoading: isLoadingUser,
    refetch: refetchUser,
  } = useUserByCustomId(customUserId.trim().toUpperCase());

  const createJoinRequest = useCreateJoinRequest();

  const handleSearch = () => {
    if (!customUserId.trim()) {
      setSearchError('KullanÄ±cÄ± ID gerekli');
      return;
    }

    setSearchError(null);
    refetchUser();
  };

  const handleSendInvite = async () => {
    if (!foundUser) {
      setSearchError('KullanÄ±cÄ± bulunamadÄ±');
      return;
    }

    if (!user?.id) {
      Alert.alert('Hata', 'KullanÄ±cÄ± bilgisi bulunamadÄ±');
      return;
    }

    if (!selectedGroup) {
      Alert.alert('Hata', 'LÃ¼tfen Ã¶nce bir grup seÃ§in');
      return;
    }

    if (foundUser.id === user.id) {
      Alert.alert('Hata', 'Kendinize davet gÃ¶nderemezsiniz');
      return;
    }

    try {
      setIsSubmitting(true);
      setSearchError(null);

      await createJoinRequest.mutateAsync({
        group_id: selectedGroup.id,
        requester_id: foundUser.id,
        invite_code: selectedGroup.invite_code, // Pass the invite code
      });

      Alert.alert(
        'Davet GÃ¶nderildi',
        `${foundUser.display_name || foundUser.custom_user_id} kullanÄ±cÄ±sÄ±na ${selectedGroup.name} grubuna katÄ±lma daveti gÃ¶nderildi.`,
        [
          {
            text: 'Tamam',
            onPress: () => {
              setCustomUserId('');
              router.back();
            },
          },
        ]
      );
    } catch (error: any) {
      setSearchError(error.message || 'Davet gÃ¶nderilemedi');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleUserIdChange = (text: string) => {
    // Sadece bÃ¼yÃ¼k harf ve rakam kabul et
    const cleaned = text.toUpperCase().replace(/[^A-Z0-9]/g, '');
    setCustomUserId(cleaned);
    setSearchError(null);
  };

  return (
    <BaseLayout
      headerShow={true}
      header={{
        leftIcon: {
          icon: <Ionicons name="arrow-back" size={24} color={colors.text} />,
          onPress: () => router.back(),
        },
        title: <Typography variant="h5" color={colors.text}>KullanÄ±cÄ± Ara</Typography>,
        backgroundColor: colors.background,
      }}
    >
      <KeyboardAwareView contentContainerStyle={styles.contentContainer} keyboardVerticalOffset={headerHeight}>
        <View style={styles.headerSection}>
          <View style={[styles.iconContainer, { backgroundColor: colors.primary + '20' }]}>
            <Ionicons name="search" size={48} color={colors.primary} />
          </View>
          <Typography variant="h3" color={colors.text} style={{ marginTop: 24, marginBottom: 8 }}>
            KullanÄ±cÄ± Ara ve Davet Et
          </Typography>
          <Typography variant="body" color={colors.secondaryText} style={{ textAlign: 'center' }}>
            KullanÄ±cÄ±nÄ±n custom ID'sini girerek arama yapÄ±n ve gruba davet gÃ¶nderin
          </Typography>
        </View>

        <View style={styles.form}>
          <View style={styles.inputGroup}>
            <Typography variant="label" color={colors.text} style={{ marginBottom: 8 }}>
              KullanÄ±cÄ± ID
            </Typography>
            <View style={styles.searchContainer}>
              <TextInput
                style={[
                  styles.input,
                  {
                    backgroundColor: colors.cardBackground,
                    color: colors.text,
                    borderColor: searchError ? colors.error : foundUser ? colors.success : colors.stroke,
                  },
                ]}
                placeholder="ABC12345"
                placeholderTextColor={colors.secondaryText + '80'}
                value={customUserId}
                onChangeText={handleUserIdChange}
                autoCapitalize="characters"
                autoCorrect={false}
                returnKeyType="search"
                onSubmitEditing={handleSearch}
              />
              <GeliomButton
                state={isLoadingUser ? 'loading' : customUserId.trim() ? 'active' : 'passive'}
                size="small"
                icon="search"
                onPress={handleSearch}
                disabled={!customUserId.trim() || isLoadingUser}
              >
                Ara
              </GeliomButton>
            </View>
            {searchError && (
              <Typography variant="caption" color={colors.error} style={{ marginTop: 4 }}>
                {searchError}
              </Typography>
            )}
            {foundUser && !searchError && (
              <Typography variant="caption" color={colors.success} style={{ marginTop: 4 }}>
                âœ“ KullanÄ±cÄ± bulundu
              </Typography>
            )}
          </View>

          {foundUser && (
            <View style={[styles.userCard, { backgroundColor: colors.cardBackground, borderColor: colors.stroke }]}>
              <View style={styles.userCardHeader}>
                <View style={[styles.avatar, { backgroundColor: colors.primary + '20' }]}>
                  {foundUser.photo_url ? (
                    <Ionicons name="person" size={32} color={colors.primary} />
                  ) : (
                    <Ionicons name="person-outline" size={32} color={colors.primary} />
                  )}
                </View>
                <View style={styles.userInfo}>
                  <Typography variant="h5" color={colors.text} numberOfLines={1}>
                    {foundUser.display_name || 'Ä°simsiz KullanÄ±cÄ±'}
                  </Typography>
                  <Typography variant="caption" color={colors.secondaryText}>
                    @{foundUser.custom_user_id}
                  </Typography>
                  {foundUser.email && (
                    <Typography variant="caption" color={colors.secondaryText} style={{ marginTop: 2 }}>
                      {foundUser.email}
                    </Typography>
                  )}
                </View>
              </View>
            </View>
          )}

          {selectedGroup && (
            <View style={[styles.groupInfo, { backgroundColor: colors.cardBackground + '80', borderColor: colors.stroke }]}>
              <View style={styles.groupInfoHeader}>
                <Ionicons name="people" size={20} color={colors.secondaryText} />
                <Typography variant="caption" color={colors.secondaryText} style={{ marginLeft: 8 }}>
                  Davet gÃ¶nderilecek grup: <Typography variant="caption" color={colors.text} fontWeight="semibold">{selectedGroup.name}</Typography>
                </Typography>
              </View>
            </View>
          )}

          {!selectedGroup && (
            <View style={[styles.warningCard, { backgroundColor: colors.warning + '20', borderColor: colors.warning }]}>
              <Ionicons name="warning-outline" size={20} color={colors.warning} />
              <Typography variant="caption" color={colors.warning} style={{ marginLeft: 8, flex: 1 }}>
                Davet gÃ¶ndermek iÃ§in Ã¶nce bir grup seÃ§melisiniz.
              </Typography>
            </View>
          )}

          <GeliomButton
            state={isSubmitting ? 'loading' : foundUser && selectedGroup ? 'active' : 'passive'}
            layout="full-width"
            size="large"
            icon="send"
            onPress={handleSendInvite}
            disabled={!foundUser || !selectedGroup || isSubmitting}
          >
            {isSubmitting ? 'GÃ¶nderiliyor...' : 'Davet GÃ¶nder'}
          </GeliomButton>
        </View>
      </KeyboardAwareView>
    </BaseLayout>
  );
}

const styles = StyleSheet.create({
  contentContainer: {
    padding: 24,
    paddingBottom: 100,
  },
  headerSection: {
    alignItems: 'center',
    marginBottom: 32,
    paddingHorizontal: 20,
  },
  iconContainer: {
    width: 96,
    height: 96,
    borderRadius: 48,
    justifyContent: 'center',
    alignItems: 'center',
  },
  form: {
    gap: 24,
  },
  inputGroup: {
    gap: 4,
  },
  searchContainer: {
    flexDirection: 'row',
    gap: 12,
    alignItems: 'flex-start',
  },
  input: {
    flex: 1,
    borderWidth: 1.5,
    borderRadius: 16,
    paddingHorizontal: 16,
    paddingVertical: 16,
    fontSize: 18,
    fontFamily: 'Comfortaa-Medium',
  },
  userCard: {
    borderRadius: 16,
    borderWidth: 1.5,
    padding: 16,
  },
  userCardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  avatar: {
    width: 56,
    height: 56,
    borderRadius: 28,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  userInfo: {
    flex: 1,
  },
  groupInfo: {
    borderRadius: 12,
    borderWidth: 1,
    padding: 12,
  },
  groupInfoHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  warningCard: {
    borderRadius: 12,
    borderWidth: 1,
    padding: 12,
    flexDirection: 'row',
    alignItems: 'center',
  },
});
</file>

<file path="components/dashboard/EmptyStateView.tsx">
import { GeliomButton, Typography } from '@/components/shared';
import { useTheme } from '@/contexts/ThemeContext';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React from 'react';
import { StyleSheet, View } from 'react-native';

export default function EmptyStateView() {
  const { colors } = useTheme();
  const router = useRouter();

  return (
    <View style={styles.container}>
      <View style={[styles.iconCircle, { backgroundColor: colors.tertiary + '30' }]}>
        <Ionicons name="people-outline" size={64} color={colors.primary} />
      </View>
      
      <Typography variant="h3" color={colors.text} style={styles.title}>
        HoÅŸ Geldin!
      </Typography>
      
      <Typography variant="body" color={colors.secondaryText} style={styles.description}>
        HenÃ¼z bir grubun seÃ§ili deÄŸil veya bir gruba Ã¼ye deÄŸilsin. 
        ArkadaÅŸlarÄ±nla ve ailenle baÄŸlantÄ±da kalmak iÃ§in bir grup oluÅŸtur veya katÄ±l.
      </Typography>

      <View style={styles.actions}>
        <GeliomButton
          state="active"
          size="large"
          layout="full-width"
          icon="add-circle"
          onPress={() => router.push('/(drawer)/(group)/create-group')}
        >
          Yeni Grup OluÅŸtur
        </GeliomButton>
        
        <GeliomButton
          state="active"
          size="large"
          layout="full-width"
          icon="people"
          variant="outline"
          onPress={() => router.push('/(drawer)/(group)/join-group')}
        >
          Gruba KatÄ±l
        </GeliomButton>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 24,
  },
  iconCircle: {
    width: 120,
    height: 120,
    borderRadius: 60,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 24,
  },
  title: {
    textAlign: 'center',
    marginBottom: 12,
  },
  description: {
    textAlign: 'center',
    marginBottom: 32,
    lineHeight: 24,
  },
  actions: {
    width: '100%',
    gap: 16,
  },
});
</file>

<file path="components/shared/BaseLayout.tsx">
import { useTheme } from '@/contexts/ThemeContext';
import React, { ReactNode } from 'react';
import {
  ImageBackground,
  Platform,
  StatusBar,
  StyleSheet,
  TouchableOpacity,
  View,
  ViewStyle
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

// Header iÃ§in icon tipini tanÄ±mla
export interface HeaderIconProps {
  icon: ReactNode;
  onPress?: () => void;
}

// Header props interface'i
export interface HeaderProps {
  leftIcon?: HeaderIconProps;
  rightIcon?: HeaderIconProps;
  title?: ReactNode;
  backgroundColor?: string;
  height?: number;
  style?: ViewStyle;
}

// BaseLayout props interface'i
export interface BaseLayoutProps {
  children: ReactNode;
  fullScreen?: boolean;
  headerShow?: boolean;
  header?: HeaderProps;
  backgroundImage?: any;
  backgroundColor?: string;
  style?: ViewStyle;
  contentStyle?: ViewStyle;
}

// Header Component'i
const Header: React.FC<HeaderProps> = ({
  leftIcon,
  rightIcon,
  title,
  backgroundColor,
  height = 56,
  style,
}) => {
  const { colors } = useTheme();
  const insets = useSafeAreaInsets();

  return (
    <View
      style={[
        styles.headerContainer,
        {
          backgroundColor: backgroundColor || colors.background,
          height: height + insets.top,
          paddingTop: insets.top,
        },
        style,
      ]}
    >
      <View style={styles.headerContent}>
        {/* Sol taraf - Icon ve Title */}
        <View style={styles.headerLeft}>
          {leftIcon && (
            <TouchableOpacity 
              style={styles.iconContainer}
              onPress={leftIcon.onPress}
              activeOpacity={0.7}
            >
              {leftIcon.icon}
            </TouchableOpacity>
          )}
          {title && <View style={styles.titleContainer}>{title}</View>}
        </View>

        {/* SaÄŸ taraf - Icon */}
        {rightIcon && (
          <View style={styles.headerRight}>
            <TouchableOpacity 
              style={styles.iconContainer}
              onPress={rightIcon.onPress}
              activeOpacity={0.7}
            >
              {rightIcon.icon}
            </TouchableOpacity>
          </View>
        )}
      </View>
    </View>
  );
};

// Ana BaseLayout Component'i
const BaseLayout: React.FC<BaseLayoutProps> = ({
  children,
  fullScreen = false,
  headerShow = true,
  header,
  backgroundImage,
  backgroundColor,
  style,
  contentStyle,
}) => {
  const { colors, isDark } = useTheme();
  const insets = useSafeAreaInsets();

  // Status bar style'Ä±nÄ± tema gÃ¶re ayarla
  const statusBarStyle = isDark ? 'light-content' : 'dark-content';
  const statusBarBackgroundColor = header?.backgroundColor || backgroundColor || colors.background;

  // Container style'Ä±nÄ± hazÄ±rla
  const containerStyle: ViewStyle = {
    ...styles.container,
    backgroundColor: backgroundColor || colors.background,
    paddingBottom: fullScreen ? 0 : insets.bottom,
    paddingLeft: fullScreen ? 0 : insets.left,
    paddingRight: fullScreen ? 0 : insets.right,
    ...style,
  };

  // Content style'Ä±nÄ± hazÄ±rla
  const finalContentStyle: ViewStyle = {
    ...styles.content,
    ...contentStyle,
  };

  return (
    <>
      {/* Status Bar */}
      <StatusBar
        barStyle={statusBarStyle}
        backgroundColor={Platform.OS === 'android' ? statusBarBackgroundColor : undefined}
        translucent={fullScreen}
      />

      {/* Ana Container */}
      {backgroundImage ? (
        <ImageBackground source={backgroundImage} style={containerStyle}>
          {/* Header */}
          {headerShow && header && (
            <Header {...header} />
          )}

          {/* Content */}
          <View style={finalContentStyle}>
            {children}
          </View>
        </ImageBackground>
      ) : (
        <View style={containerStyle}>
          {/* Header */}
          {headerShow && header && (
            <Header {...header} />
          )}

          {/* Content */}
          <View style={finalContentStyle}>
            {children}
          </View>
        </View>
      )}
    </>
  );
};

// Styles
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
  },
  headerContainer: {
    justifyContent: 'flex-end',
    zIndex: 1000,
  },
  headerContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    height: 56,
    paddingHorizontal: 16,
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  headerRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconContainer: {
    minWidth: 40,
    minHeight: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  titleContainer: {
    marginLeft: 12,
    flex: 1,
  },
});

export default BaseLayout;
</file>

<file path="components/shared/Button.tsx">
// Button.tsx - Gradient KenarlÄ±k DÃ¼zeltmesiyle

import CustomText from "@/components/shared/Text";
import { useTheme } from "@/contexts/ThemeContext";
import { Fonts, TypographyKeys } from "@/theme/typography";
import { LinearGradient } from "expo-linear-gradient";
import React from "react";
import { ActivityIndicator, StyleSheet, TouchableOpacity, TouchableOpacityProps, View } from "react-native";

interface ButtonProps extends TouchableOpacityProps {
    title: string;
    onPress: () => void;
    variant?: 'gradient' | 'primary' | 'outline';
    size?: 'large' | 'small';
    disabled?: boolean;
    loading?: boolean;
    icon?: React.ReactNode;
    textVariant?: keyof TypographyKeys;
    fontWeight?: keyof Fonts;
    passive?: boolean;
}

export default function Button({
    title,
    onPress,
    variant = 'gradient',
    size = 'large',
    disabled = false,
    loading = false,
    icon,
    textVariant,
    fontWeight,
    style,
    passive = false,
    ...props
}: ButtonProps) {   
    const { colors } = useTheme();

    // TÄ±klanabilirliÄŸi `isEffectivelyDisabled`'a baÄŸlÄ±yoruz
    const isEffectivelyDisabled = (disabled || loading) && !passive;

    const defaultTextVariant = size === 'large' ? 'h6' : 'body2';

    const getGradientStartAndEnd = () => {
        if (size === 'large') return { start: { x: 0, y: 0 }, end: { x: 1, y: 0 } };
        return { start: { x: 1, y: 0 }, end: { x: 0, y: 0 } };
    }

    // TÃ¼m stil (renk, opaklÄ±k) koÅŸullarÄ±nÄ± `shouldApplyDisabledStyle`'a baÄŸlÄ±yoruz
    const getTextColor = () => {
        if (isEffectivelyDisabled) return colors.secondaryText;
        if (variant === 'outline') return colors.primary;
        return colors.text;
    };

    const content = (
        <View style={[
            styles.contentWrapper,
            size === 'small' && styles.contentPadding,
        ]}>
            {icon && !loading && <View style={styles.iconWrapper}>{icon}</View>}
            <CustomText
                variant={textVariant || defaultTextVariant}
                fontWeight={fontWeight}
                style={[styles.text, { color: getTextColor() }]}
            >
                {title}
            </CustomText>
            {loading && <ActivityIndicator color={getTextColor()} style={styles.loader} />}
        </View>
    );

    const containerStyle = [
        styles.baseContainer,
        size === 'large' ? styles.largeContainer : styles.smallContainer,
        isEffectivelyDisabled && { opacity: 0.6 },
        style,
    ];

    if (variant === 'outline') {
        return (
            <TouchableOpacity 
            activeOpacity={0.8}
            onPress={onPress} disabled={isEffectivelyDisabled} style={containerStyle} {...props}>
                <LinearGradient
                    colors={isEffectivelyDisabled ? [colors.disabled, colors.disabled] : colors.linearGradient as [string, string]}
                    start={getGradientStartAndEnd().start}
                    end={getGradientStartAndEnd().end}
                    style={[
                        styles.fullWidthHeight,
                        styles.borderFrame,
                        size === 'small' ? styles.smallBorderRadius : styles.largeBorderRadius,
                    ]}
                >
                    <View style={[
                        styles.outlineInnerView,
                        { backgroundColor: colors.background },
                        size === 'small' ? styles.smallInnerRadius : styles.largeInnerRadius,
                    ]}>
                        {content}
                    </View>
                </LinearGradient>
            </TouchableOpacity>
        );
    }
    
    if (variant === 'gradient') {
        return (
            <TouchableOpacity activeOpacity={0.8} onPress={onPress} disabled={isEffectivelyDisabled} style={containerStyle} {...props}>
                <LinearGradient
                    colors={isEffectivelyDisabled ? [colors.disabled, colors.disabled] : colors.linearGradient as [string, string]}
                    start={getGradientStartAndEnd().start}
                    end={getGradientStartAndEnd().end}
                    style={[
                        styles.fullWidthHeight,
                        { borderRadius: size === 'large' ? styles.largeContainer.borderRadius : styles.smallContainer.borderRadius }
                    ]}
                >
                    {content}
                </LinearGradient>
            </TouchableOpacity>
        );
    }

    return (
        <TouchableOpacity
            activeOpacity={0.8}
            onPress={onPress}
            disabled={isEffectivelyDisabled}
            style={[
                { backgroundColor: isEffectivelyDisabled ? colors.disabled : colors.primary },
                containerStyle,
            ]}
            {...props}
        >
            {content}
        </TouchableOpacity>
    );
};

const styles = StyleSheet.create({
    baseContainer: {
        justifyContent: 'center',
        alignItems: 'center',
        overflow: 'hidden',
    },
    largeContainer: {
        width: '100%',
        height: 56,
        borderRadius: 28,
    },
    smallContainer: {
        alignSelf: 'flex-start',
        height: 36,
        borderRadius: 20,
    },
    fullWidthHeight: {
        width: '100%',
        height: '100%',
        justifyContent: 'center',
        alignItems: 'center'
    },
    contentWrapper: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
    },
    contentPadding: {
        paddingHorizontal: 16,
    },
    borderFrame: {
        padding: 1,
    },
    iconWrapper: {
        marginRight: 8,
    },
    text: {
        textAlign: 'center',
    },
    loader: {
        marginLeft: 10,
    },
    outlineInnerView: {
        width: '100%',
        height: '100%',
        justifyContent: 'center',
        alignItems: 'center',
    },
    largeBorderRadius: { borderRadius: 28 },
    largeInnerRadius: { borderRadius: 27 },
    smallBorderRadius: { borderRadius: 20 },
    smallInnerRadius: { borderRadius: 19 },
});
</file>

<file path="components/ui/NetworkToast.tsx">
import { useTheme } from "@/contexts/ThemeContext";
import { Ionicons } from "@expo/vector-icons";
import React, { useEffect } from "react";
import { StyleSheet, View } from "react-native";
import Animated, { useAnimatedStyle, useSharedValue, withSpring, withTiming } from "react-native-reanimated";
import { CustomText } from "../shared";

export type NetworkToastType = 'weak' | 'offline';

interface NetworkToastProps {
  type: NetworkToastType;
  message: string;
  visible: boolean;
  onHide?: () => void;
  duration?: number;
}

export default function NetworkToast({
  type,
  message,
  visible,
  onHide,
  duration = 3000,
}: NetworkToastProps) {
  const { colors } = useTheme();
  const translateY = useSharedValue(-100);
  const opacity = useSharedValue(0);

  useEffect(() => {
    if (visible) {
      // Show animation
      translateY.value = withSpring(0, {
        damping: 15,
        stiffness: 100,
      });
      opacity.value = withTiming(1, { duration: 300 });

      // Auto hide after duration
      if (duration > 0) {
        const timer = setTimeout(() => {
          hideToast();
        }, duration);

        return () => clearTimeout(timer);
      }
    } else {
      hideToast();
    }
  }, [visible]);

  const hideToast = () => {
    translateY.value = withTiming(-100, { duration: 300 });
    opacity.value = withTiming(0, { duration: 300 });

    setTimeout(() => {
      onHide?.();
    }, 300);
  };

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ translateY: translateY.value }],
    opacity: opacity.value,
  }));

  if (!visible) return null;

  const isWeak = type === 'weak';
  const iconBgColor = isWeak ? '#FFA500' : '#E50049'; // Orange for weak, Red for offline

  return (
    <Animated.View
      style={[
        styles.container,
        {
          backgroundColor: isWeak ? colors.secondaryBackground : colors.secondaryBackground,
        },
        animatedStyle,
      ]}
    >
      <View style={[styles.iconContainer, { backgroundColor: iconBgColor }]}>
        {isWeak ? (
          <Ionicons name="information" size={20} color={colors.white} />
        ) : (
          <View style={styles.crossIcon}>
            <View style={[styles.crossLine, styles.crossLine1, { backgroundColor: colors.text }]} />
            <View style={[styles.crossLine, styles.crossLine2, { backgroundColor: colors.text }]} />
          </View>
        )}
      </View>

      <View style={styles.messageContainer}>
        <CustomText
          variant="body"
          fontWeight="regular"
          color={colors.text}
          style={styles.message}
        >
          {message}
        </CustomText>
      </View>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    top: 60, // Below status bar
    left: 16,
    right: 16,
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 12,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
    zIndex: 9999,
  },
  iconContainer: {
    width: 32,
    height: 32,
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  crossIcon: {
    width: 20,
    height: 20,
    position: 'relative',
    justifyContent: 'center',
    alignItems: 'center',
  },
  crossLine: {
    position: 'absolute',
    width: 14,
    height: 2,
    borderRadius: 1,
  },
  crossLine1: {
    transform: [{ rotate: '45deg' }],
  },
  crossLine2: {
    transform: [{ rotate: '-45deg' }],
  },
  messageContainer: {
    flex: 1,
  },
  message: {
    lineHeight: 20,
  },
});
</file>

<file path="components/index.ts">
export { default as CustomDrawerContent } from './CustomDrawerContent';
export { default as KeyboardAwareView } from './KeyboardAwareView';
export { NotificationHandler } from './NotificationHandler';
</file>

<file path="components/KeyboardAwareView.tsx">
import React from 'react';
import {
  GestureResponderEvent,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  StyleProp,
  StyleSheet,
  ViewStyle,
} from 'react-native';

interface KeyboardAwareViewProps {
  /** Ä°Ã§eriÄŸi gÃ¶sterir */
  children: React.ReactNode;
  
  /** KeyboardAvoidingView iÃ§in stil */
  style?: StyleProp<ViewStyle>;
  
  /** ScrollView'in iÃ§indeki contentContainer iÃ§in stil */
  contentContainerStyle?: StyleProp<ViewStyle>;
  
  /**
   * EkranÄ±n Ã¼st kÄ±smÄ±ndaki (Ã¶rneÄŸin header) boÅŸluk miktarÄ±.
   * Bu bileÅŸen bir header'Ä±n altÄ±ndaysa, header'Ä±n yÃ¼ksekliÄŸini buraya girin.
   */
  keyboardVerticalOffset?: number;
  
  /**
   * Dokunma olayÄ±nÄ± iletmek iÃ§in opsiyonel bir prop.
   * Bazen 'ScrollView' yerine dÄ±ÅŸarÄ±daki bir view'a dokunulduÄŸunu bilmek istersiniz.
   */
  onTouchStart?: (event: GestureResponderEvent) => void;
}

/**
 * Klavye aÃ§Ä±ldÄ±ÄŸÄ±nda iÃ§eriÄŸin klavyenin altÄ±nda kalmasÄ±nÄ± engelleyen,
 * hem iOS hem de Android iÃ§in tutarlÄ± Ã§alÄ±ÅŸan sarmalayÄ±cÄ± bileÅŸen.
 * * Temelde 'KeyboardAvoidingView' ve 'ScrollView'i doÄŸru ayarlarla birleÅŸtirir.
 * * En Ã¶nemli Ã¶zelliÄŸi: ScrollView'in 'contentContainerStyle'Ä±na otomatik olarak
 * 'flexGrow: 1' ekler. Bu sayede iÃ§erik kÄ±sayken bile ekranÄ± doldurur
 * (Ã¶rn: 'justifyContent: 'space-between'' ile butonu en alta itmek iÃ§in).
 */
export default function KeyboardAwareView({ children, style, contentContainerStyle, keyboardVerticalOffset = 0, onTouchStart }: KeyboardAwareViewProps) {
  return (
    <KeyboardAvoidingView
      style={[styles.container, style]}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? keyboardVerticalOffset : 0}
      enabled={Platform.OS === 'ios'}
    >
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={[
          styles.contentContainer,
          contentContainerStyle,
        ]}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
        onTouchStart={onTouchStart}
        bounces={false}
      >
        {children}
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    width: '100%',
  },
  scrollView: {
    flex: 1,
  },
  contentContainer: {
    /**
     * BU Ã‡OK Ã–NEMLÄ°!
     * 'flexGrow: 1', iÃ§eriÄŸin ScrollView'dan kÄ±sa olmasÄ± durumunda bile
     * tÃ¼m alanÄ± kaplamasÄ±nÄ± saÄŸlar. Bu, 'justifyContent' gibi stillerin
     * (Ã¶rn: butonu en alta yapÄ±ÅŸtÄ±rmak) Ã§alÄ±ÅŸmasÄ±na olanak tanÄ±r.
     */
    flexGrow: 1,
  },
});
</file>

<file path="constants/adapty.ts">
export const FIRST_SUBSCRIPTION_PLACEMENT = "first-subscription";
</file>

<file path="contexts/BottomSheetContext.tsx">
import BottomSheet, { BottomSheetBackdrop, BottomSheetView } from '@gorhom/bottom-sheet';
import React, { createContext, ReactNode, useCallback, useContext, useMemo, useRef, useState } from 'react';
import { StyleSheet } from 'react-native';
import { useTheme } from './ThemeContext';

// Bottom Sheet Options Interface
export interface BottomSheetOptions {
    enablePanDownToClose?: boolean;
    enableOverlayTap?: boolean;
    snapPoints?: (string | number)[];
    index?: number;
    handleIndicatorStyle?: any;
    backgroundStyle?: any;
}

// Context Interface
interface BottomSheetContextValue {
    openBottomSheet: (content: ReactNode, options?: BottomSheetOptions) => void;
    closeBottomSheet: () => void;
    snapToIndex: (index: number) => void;
    isOpen: boolean;
}

// Create Context
const BottomSheetContext = createContext<BottomSheetContextValue | undefined>(undefined);

// Provider Props
interface BottomSheetProviderProps {
    children: ReactNode;
}

export const BottomSheetProvider: React.FC<BottomSheetProviderProps> = ({ children }) => {
    const { colors } = useTheme();
    const bottomSheetRef = useRef<BottomSheet>(null);
    const [content, setContent] = useState<ReactNode>(null);
    const [isOpen, setIsOpen] = useState(false);
    const [options, setOptions] = useState<BottomSheetOptions>({
        enablePanDownToClose: true,
        enableOverlayTap: true,
        snapPoints: ['50%'],
        index: 0,
    });

    // Default snap points - dynamic sizing iÃ§in CONTENT_HEIGHT kullanÄ±lacak
    const snapPoints = useMemo(() => options.snapPoints || ['60%'], [options.snapPoints]);

    // Open Bottom Sheet - Direkt content kabul ediyor
    const openBottomSheet = useCallback((newContent: ReactNode, newOptions?: BottomSheetOptions) => {
        setOptions({
            enablePanDownToClose: newOptions?.enablePanDownToClose ?? true,
            enableOverlayTap: newOptions?.enableOverlayTap ?? true,
            snapPoints: newOptions?.snapPoints || ['60%'],
            index: newOptions?.index ?? 0,
            handleIndicatorStyle: newOptions?.handleIndicatorStyle,
            backgroundStyle: newOptions?.backgroundStyle,
        });
        
        setContent(newContent);
        setIsOpen(true);
        bottomSheetRef.current?.snapToIndex(newOptions?.index ?? 0);
    }, []);

    // Close Bottom Sheet
    const closeBottomSheet = useCallback(() => {
        bottomSheetRef.current?.close();
        setIsOpen(false);
        // Animasyon bitene kadar iÃ§eriÄŸi temizleme
        setTimeout(() => setContent(null), 300);
    }, []);

    const snapToIndex = useCallback((index: number) => {
        bottomSheetRef.current?.snapToIndex(index);
    }, []);

    // Render backdrop
    const renderBackdrop = useCallback(
        (props: any) => {
            // Android'de backdrop touch event'leri blokluyor
            // Sadece bottom sheet aÃ§Ä±ksa (index >= 0) backdrop gÃ¶ster
            if (props.animatedIndex?.value < 0) {
                return null;
            }
            return (
                <BottomSheetBackdrop
                    {...props}
                    disappearsOnIndex={-1}
                    appearsOnIndex={0}
                    opacity={0.5}
                    pressBehavior={options.enableOverlayTap ? 'close' : 'none'}
                />
            );
        },
        [options.enableOverlayTap]
    );

    // Context value
    const value = useMemo(
        () => ({
            openBottomSheet,
            closeBottomSheet,
            snapToIndex,
            isOpen,
        }),
        [openBottomSheet, closeBottomSheet, isOpen, snapToIndex]
    );

    return (
        <BottomSheetContext.Provider value={value}>
            {children}
            <BottomSheet
                ref={bottomSheetRef}
                index={-1}
                snapPoints={snapPoints}
                enablePanDownToClose={options.enablePanDownToClose}
                backdropComponent={renderBackdrop}
                handleIndicatorStyle={[
                    styles.handleIndicator,
                    { backgroundColor: colors.secondaryText },
                    options.handleIndicatorStyle,
                ]}
                backgroundStyle={[
                    { backgroundColor: colors.background },
                    options.backgroundStyle,
                ]}
                keyboardBehavior="extend"
                keyboardBlurBehavior="restore"
                android_keyboardInputMode="adjustResize"
                animateOnMount={false}
                onChange={(index) => {
                    if (index === -1) {
                        setIsOpen(false);
                        setTimeout(() => setContent(null), 300);
                    }
                }}
            >
                <BottomSheetView style={styles.contentContainer}>
                    {content}
                </BottomSheetView>
            </BottomSheet>
        </BottomSheetContext.Provider>
    );
};

// Custom Hook
export const useBottomSheet = (): BottomSheetContextValue => {
    const context = useContext(BottomSheetContext);
    if (!context) {
        throw new Error('useBottomSheet must be used within a BottomSheetProvider');
    }
    return context;
};

const styles = StyleSheet.create({
    handleIndicator: {
        width: 40,
        height: 4,
        borderRadius: 2,
    },
    contentContainer: {
        flex: 1,
        paddingHorizontal: 16,
        paddingBottom: 24,
    },
});
</file>

<file path="docs/project-flow.md">
Geliom - Proje Detay Raporu ve GeliÅŸtirme PlanÄ±
DokÃ¼man SÃ¼rÃ¼mÃ¼: 2.0
Son GÃ¼ncelleme: 2025-01-XX
1. Proje Ã–zeti ve Vizyon
1.1. Proje AdÄ±
Geliom
1.2. Proje Vizyonu
Ä°nsanlarÄ±n dijital gÃ¼rÃ¼ltÃ¼den uzak, sadece en yakÄ±n Ã§evreleriyle (arkadaÅŸlar ve aile) samimi ve anlÄ±k bir ÅŸekilde baÄŸlantÄ± kurarak sosyal hayatlarÄ±nÄ± zahmetsizce organize etmelerini saÄŸlayan bir platform olmak.
1.3. Ã‡Ã¶zÃ¼len Temel Problem
"Ne yapsak?", "MÃ¼sait misin?", "Hadi buluÅŸalÄ±m!" gibi gÃ¼nlÃ¼k sosyal koordinasyon sorularÄ±nÄ±, uzun mesajlaÅŸmalara veya telefon trafiÄŸine gerek kalmadan, tek bir dokunuÅŸla Ã§Ã¶zmek. Spontane buluÅŸmalarÄ± ve planlÄ± etkinlikleri teÅŸvik etmek.
1.4. Hedef Kitle
Birincil: 16-25 yaÅŸ arasÄ± lise/Ã¼niversite Ã¶ÄŸrencileri ve genÃ§ profesyoneller.
Ä°kincil: YakÄ±n aile baÄŸlarÄ±na sahip, teknolojiye yatkÄ±n yetiÅŸkinler.
2. Teknoloji YÄ±ÄŸÄ±nÄ± ve Mimari
Bu teknoloji yÄ±ÄŸÄ±nÄ±, hÄ±zlÄ± geliÅŸtirme (Expo), Ã¶lÃ§eklenebilirlik (Supabase) ve sektÃ¶r standardÄ± araÃ§larla (Firebase, Adapty) saÄŸlam bir temel oluÅŸturmak iÃ§in seÃ§ilmiÅŸtir.
Alan
Teknoloji/Servis
Beklentiler ve Sorumluluklar
Frontend
React Native (Expo)
HÄ±zlÄ± ve cross-platform (iOS/Android) geliÅŸtirme. Kolay OTA (Over-the-Air) gÃ¼ncellemeler.
Navigasyon
React Navigation
Ekranlar arasÄ± geÃ§iÅŸlerin akÄ±cÄ± ve standartlara uygun yÃ¶netimi.
State Management
Zustand / Context API
Uygulama genelindeki state'in (kullanÄ±cÄ± bilgileri, gruplar vb.) verimli yÃ¶netimi.
Backend (BaaS)
Supabase
Projenin ana backend'i. TÃ¼m veri iÅŸlemleri, kimlik doÄŸrulama ve anlÄ±k gÃ¼ncellemeler buradan yÃ¶netilecek.
VeritabanÄ±
Supabase (PostgreSQL)
Ä°liÅŸkisel veri yapÄ±sÄ±, gÃ¼Ã§lÃ¼ sorgulama ve veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼. SatÄ±r Seviyesi GÃ¼venlik (RLS) ile maksimum gÃ¼venlik.
Kimlik DoÄŸrulama
Supabase Auth
Google ile gÃ¼venli ve kolay giriÅŸ. KullanÄ±cÄ± yÃ¶netimi.
AnlÄ±k Veri
Supabase Realtime
Durum ve duygu durumu deÄŸiÅŸikliklerinin tÃ¼m grup Ã¼yelerine anÄ±nda yansÄ±tÄ±lmasÄ±.
Sunucu FonksiyonlarÄ±
Supabase Edge Functions
Bildirim gÃ¶nderme, zamanlanmÄ±ÅŸ etkinlikleri kontrol etme gibi sunucu tarafÄ± mantÄ±klarÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±.
Push Bildirim
OneSignal
Segmentasyon, zengin bildirimler ve yÃ¼ksek teslimat oranÄ±. KullanÄ±cÄ±ya Ã¶zel bildirimlerin yÃ¶netimi.
Abonelik YÃ¶netimi
Adapty
App Store/Play Store aboneliklerinin kolay entegrasyonu. Paywall A/B testi, gelir analizi ve kullanÄ±cÄ± segmentasyonu.
Analiz & Hata Takibi
Firebase
Analytics: KullanÄ±cÄ± davranÄ±ÅŸlarÄ±nÄ± (en Ã§ok kullanÄ±lan Ã¶zellikler, ekran sÃ¼releri vb.) izleyerek Ã¼rÃ¼n kararlarÄ± alma.
Crashlytics: Uygulama Ã§Ã¶kmelerini anÄ±nda tespit edip detaylÄ± raporlar alarak hÄ±zlÄ±ca dÃ¼zeltme.

3. VeritabanÄ± Mimarisi
VeritabanÄ± yapÄ±sÄ±, projenin temelini oluÅŸturur. TÃ¼m tablolar, iliÅŸkiler ve gÃ¼venlik politikalarÄ± supabase_setup.sql betiÄŸinde tanÄ±mlanmÄ±ÅŸtÄ±r. DetaylÄ± gÃ¶rsel ÅŸema iÃ§in db_diagram.md dosyasÄ±na bakÄ±lmalÄ±dÄ±r.
Ana Tablolar:
users: KullanÄ±cÄ± profilleri.
groups: ArkadaÅŸ ve aile gruplarÄ±.
group_members: KullanÄ±cÄ±-grup iliÅŸkisi.
group_join_requests: Grup katÄ±lma istekleri (onay sistemi iÃ§in).
statuses / user_statuses: AnlÄ±k eylem durumlarÄ± (default + custom).
moods: Duygu durumlarÄ± (default + kullanÄ±cÄ±ya Ã¶zel).
subscriptions: KullanÄ±cÄ± abonelik bilgileri.
scheduled_events: ZamanlanmÄ±ÅŸ etkinlikler (Premium).
nicknames, muted_notifications: Sosyal etkileÅŸim tablolarÄ±.
4. Ã–zellik Listesi ve KullanÄ±cÄ± AkÄ±ÅŸlarÄ± (Features & Actions)
4.1. Ãœcretsiz Ã–zellikler (MVP Ã‡ekirdeÄŸi)
KullanÄ±cÄ± YÃ¶netimi ve Profil
[ ] Action: KullanÄ±cÄ± Google hesabÄ± ile uygulamaya giriÅŸ yapar.
[ ] Action: Ä°lk giriÅŸte kullanÄ±cÄ± iÃ§in otomatik olarak profil ve custom_user_id oluÅŸturulur.
[ ] Ekran: Profilim EkranÄ±
[ ] Action: KullanÄ±cÄ± display_name ve custom_user_id'sini gÃ¼ncelleyebilir.
[ ] Action: KullanÄ±cÄ±, Ã¶nceden tanÄ±mlÄ± moods listesinden duygu durumunu seÃ§ebilir.
[ ] Action: KullanÄ±cÄ±, duygu durumunun (show_mood) diÄŸerleri tarafÄ±ndan gÃ¶rÃ¼lÃ¼p gÃ¶rÃ¼lmeyeceÄŸini ayarlayabilir.
Grup YÃ¶netimi
[ ] Ekran: Ana Ekran (Dashboard)
[ ] Action: KullanÄ±cÄ±, Ã¼ye olduÄŸu gruplarÄ± ve aileleri listeler.
[ ] Action: "Grup OluÅŸtur" butonu ile yeni bir grup/aile oluÅŸturur (1 adet grup, 1 adet aile limiti - Premium'da sÄ±nÄ±rsÄ±z).
[ ] Action: "Gruba KatÄ±l" alanÄ±na davet kodu girerek bir gruba katÄ±lma isteÄŸi gÃ¶nderir.
[ ] Action: Custom user ID ile kullanÄ±cÄ± arama yaparak direkt davet gÃ¶nderebilir.
[ ] Ekran: Grup KatÄ±lma Ä°stekleri (Grup Kurucusu iÃ§in)
[ ] Action: Grup kurucusu, gelen katÄ±lma isteklerini gÃ¶rÃ¼r (kullanÄ±cÄ± bilgisi, istek zamanÄ±).
[ ] Action: Grup kurucusu, katÄ±lma isteÄŸini onaylar veya reddeder.
[ ] Backend: OnaylandÄ±ÄŸÄ±nda kullanÄ±cÄ± otomatik olarak gruba eklenir (group_members).
[ ] Backend: ReddedildiÄŸinde istek silinir ve kullanÄ±cÄ±ya bildirim gÃ¶nderilir.
[ ] Ekran: Grup DetaylarÄ± EkranÄ±
[ ] Action: Grup Ã¼yelerini ve anlÄ±k durumlarÄ±nÄ±/duygularÄ±nÄ± gÃ¶rÃ¼r.
[ ] Action: Gruba Ã¶zel invite_code'u kopyalayÄ±p paylaÅŸabilir.
[ ] Action: Gruptan ayrÄ±labilir.
Sosyal EtkileÅŸim
[ ] Component: HÄ±zlÄ± Eylem ButonlarÄ± (Ana Ekranda)
[ ] Action: KullanÄ±cÄ± default statuses listesinden birini seÃ§er (MÃ¼saitim, MeÅŸgulÃ¼m vb.).
[ ] Action: Premium kullanÄ±cÄ±lar, oluÅŸturduklarÄ± custom status'larÄ± da listede gÃ¶rÃ¼r ve seÃ§ebilir.
[ ] Backend: Status listesi: Default statuses + KullanÄ±cÄ±nÄ±n custom status'larÄ± (is_custom=true, owner_id=kullanÄ±cÄ±_id) birleÅŸtirilir.
[ ] Backend: SeÃ§ilen durum, user_statuses tablosunu gÃ¼nceller ve Realtime ile anÄ±nda diÄŸer Ã¼yelere yansÄ±r.
[ ] Backend: EÄŸer durum notifies=true ise, Supabase Edge Function tetiklenir ve OneSignal Ã¼zerinden gruba bildirim gÃ¶nderilir.
[ ] Action: KullanÄ±cÄ± default moods listesinden duygu durumunu seÃ§er.
[ ] Action: Premium kullanÄ±cÄ±lar, oluÅŸturduklarÄ± custom mood'larÄ± da listede gÃ¶rÃ¼r ve seÃ§ebilir.
[ ] Backend: Mood listesi: Default moods + KullanÄ±cÄ±nÄ±n custom mood'larÄ± (owner_id=kullanÄ±cÄ±_id) birleÅŸtirilir.
[ ] Action: Grup DetaylarÄ± ekranÄ±nda bir Ã¼yenin Ã¼zerine basÄ±lÄ± tutarak o Ã¼yeye Ã¶zel, sadece kendisinin gÃ¶rebileceÄŸi bir nickname atayabilir.
[ ] Action: Grup DetaylarÄ± ekranÄ±nda bir Ã¼yeden gelen bildirimleri sessize alabilir (muted_notifications).
4.2. Premium Ã–zellikler (Abonelikli)
Abonelik YÃ¶netimi
[ ] Ekran: Premium/Paywall EkranÄ±
[ ] Action: KullanÄ±cÄ±ya premium Ã¶zellikler tanÄ±tÄ±lÄ±r ve abonelik seÃ§enekleri sunulur (aylÄ±k/yÄ±llÄ±k).
[ ] Backend: Adapty SDK'sÄ± ile satÄ±n alma iÅŸlemi yÃ¶netilir.
[ ] Backend: BaÅŸarÄ±lÄ± satÄ±n alma sonrasÄ± Adapty webhook'u veya client tarafÄ± callback ile subscriptions tablosu gÃ¼ncellenir.
[ ] Action: KullanÄ±cÄ±, profil ekranÄ±ndan mevcut abonelik durumunu ve bitiÅŸ tarihini gÃ¶rebilir.
GeniÅŸletilmiÅŸ Limitler
[ ] Backend: KullanÄ±cÄ±nÄ±n subscriptions.status'u 'premium' ise grup ve aile oluÅŸturma limitleri kaldÄ±rÄ±lÄ±r.
[ ] Backend: Premium kullanÄ±cÄ±larÄ±n oluÅŸturduÄŸu gruplarÄ±n member_limit'i daha yÃ¼ksek olur (Ã¶rn: 15).
ZamanlanmÄ±ÅŸ Etkinlikler
[ ] Ekran: Etkinlik OluÅŸturma EkranÄ± (Premium)
[ ] Action: KullanÄ±cÄ± bir grup seÃ§erek etkinlik adÄ±, tarihi ve saati belirler.
[ ] Action: Etkinlik iÃ§in bildirim zamanÄ± ayarlar.
[ ] Backend: scheduled_events tablosuna yeni etkinlik kaydedilir.
[ ] Backend: ZamanlanmÄ±ÅŸ bir Supabase Edge Function (cron job), notification_time'Ä± gelen etkinlikleri kontrol eder ve zamanÄ± geldiÄŸinde gruba bildirim gÃ¶nderir.
Ã–zelleÅŸtirme
[ ] Ekran: Custom Status OluÅŸturma (Premium)
[ ] Action: Premium kullanÄ±cÄ±lar, kendilerine Ã¶zel durum ifadeleri (statuses) oluÅŸturabilir (is_custom=true, owner_id=kullanÄ±cÄ±_id).
[ ] Action: OluÅŸturulan custom status'lar, default status'lar ile birlikte listede gÃ¶sterilir.
[ ] Action: Custom status'larÄ± dÃ¼zenleyebilir ve silebilir.
[ ] Ekran: Custom Mood OluÅŸturma (Premium)
[ ] Action: Premium kullanÄ±cÄ±lar, kendilerine Ã¶zel duygu durumlarÄ± (moods) oluÅŸturabilir (owner_id=kullanÄ±cÄ±_id).
[ ] Action: OluÅŸturulan custom mood'lar, default mood'lar ile birlikte listede gÃ¶sterilir.
[ ] Action: Custom mood'larÄ± dÃ¼zenleyebilir ve silebilir.
[ ] Backend: VeritabanÄ±: moods tablosuna owner_id kolonu eklenmeli (nullable, FK to users.id).
5. GeliÅŸtirme Yol HaritasÄ± (Fazlar)
Faz 1: AltyapÄ± ve Ã‡ekirdek MVP (Sprint 1-2) âœ… TAMAMLANDI
Hedef: KullanÄ±cÄ±larÄ±n giriÅŸ yapÄ±p, grup kurup, anlÄ±k durumlarÄ±nÄ± gÃ¶rebildiÄŸi temel bir uygulama.
Tamamlanan GÃ¶revler:
âœ… TÃ¼m servislerin (Supabase, OneSignal, Firebase, Adapty) projelerini oluÅŸtur ve konfigÃ¼rasyonlarÄ±nÄ± yap.
âœ… Expo projesini baÅŸlat, navigasyon yapÄ±sÄ±nÄ± kur.
âœ… supabase_setup.sql betiÄŸini Ã§alÄ±ÅŸtÄ±rarak veritabanÄ±nÄ± oluÅŸtur.
âœ… Supabase Auth ile Google GiriÅŸini entegre et. handle_new_user trigger'Ä±nÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± doÄŸrula.
âœ… Profil ekranÄ±nÄ± ve kullanÄ±cÄ± bilgilerini gÃ¼ncelleme iÅŸlevini tamamla.
âœ… Grup oluÅŸturma ve gruptan ayrÄ±lma akÄ±ÅŸÄ±nÄ± tamamla.
âœ… Ana ekranda grup Ã¼yelerini ve durumlarÄ±nÄ± Supabase Realtime ile anlÄ±k olarak gÃ¶ster.
âœ… HÄ±zlÄ± eylem butonlarÄ± ile durum gÃ¼ncelleme iÅŸlevini tamamla.
âœ… Default status ve mood listelerini gÃ¶sterme.
âœ… Mood gÃ¶sterimi ve seÃ§imi.
Faz 2: Grup KatÄ±lma Sistemi ve Bildirimler (Sprint 3)
Hedef: Grup katÄ±lma onay sistemi ve bildirim altyapÄ±sÄ±nÄ± kurmak.
GÃ¶revler:
[ ] VeritabanÄ±: group_join_requests tablosunu oluÅŸtur (id, group_id, requester_id, status: 'pending'|'approved'|'rejected', created_at, updated_at).
[ ] Ekran: Grup KatÄ±lma Ä°steÄŸi GÃ¶nderme
[ ] Action: KullanÄ±cÄ± davet kodu girerek katÄ±lma isteÄŸi gÃ¶nderir (group_join_requests tablosuna 'pending' kaydÄ±).
[ ] Backend: Ä°stek gÃ¶nderildiÄŸinde grup kurucusuna bildirim gÃ¶nderilir (OneSignal).
[ ] Ekran: Grup KatÄ±lma Ä°stekleri YÃ¶netimi (Grup Kurucusu iÃ§in)
[ ] Action: Grup kurucusu, gelen katÄ±lma isteklerini listeler (pending durumundakiler).
[ ] Action: Grup kurucusu, isteÄŸi onaylar â†’ group_members'e eklenir, istek 'approved' olur.
[ ] Action: Grup kurucusu, isteÄŸi reddeder â†’ istek 'rejected' olur, kullanÄ±cÄ±ya bildirim gÃ¶nderilir.
[ ] Backend: Realtime ile istek durumu deÄŸiÅŸiklikleri anÄ±nda yansÄ±r.
[ ] Ekran: KullanÄ±cÄ± Arama ve Davet GÃ¶nderme
[ ] Action: KullanÄ±cÄ± custom_user_id ile arama yapar (useUserByCustomId hook kullanÄ±lÄ±r).
[ ] Action: Bulunan kullanÄ±cÄ±ya direkt davet gÃ¶nderme seÃ§eneÄŸi sunulur.
[ ] Backend: Davet gÃ¶nderildiÄŸinde hedef kullanÄ±cÄ±ya bildirim gÃ¶nderilir.
[ ] OneSignal SDK'sÄ±nÄ± entegre et ve kullanÄ±cÄ± onesignal_player_id'sini users tablosuna kaydet.
[ ] Durum gÃ¼ncellendiÄŸinde bildirim gÃ¶nderecek Supabase Edge Function'Ä± yaz ve deploy et.
[ ] Takma isim (nickname) ekleme ve gÃ¶sterme Ã¶zelliÄŸini geliÅŸtir.
[ ] KullanÄ±cÄ± bildirimlerini sessize alma (mute) Ã¶zelliÄŸini geliÅŸtir.
Faz 3: Monetizasyon ve Premium GeÃ§iÅŸ (Sprint 4)
Hedef: Uygulamadan gelir elde etme altyapÄ±sÄ±nÄ± kurmak.
GÃ¶revler:
[ ] Adapty SDK'sÄ±nÄ± entegre et. App Store Connect ve Google Play Console'da Ã¼rÃ¼nleri tanÄ±mla.
[ ] Paywall ekranÄ±nÄ± tasarla ve geliÅŸtir.
[ ] SatÄ±n alma akÄ±ÅŸÄ±nÄ± ve abonelik durumu kontrolÃ¼nÃ¼ (hem client hem backend) tamamla.
[ ] Grup oluÅŸturma ve Ã¼ye ekleme gibi iÅŸlemlerde abonelik durumunu kontrol eden RLS politikalarÄ±nÄ± veya backend mantÄ±ÄŸÄ±nÄ± ekle.
[ ] Premium kontrolÃ¼: Custom status ve mood oluÅŸturma Ã¶zelliklerinde abonelik kontrolÃ¼ ekle.
Faz 4: GeliÅŸmiÅŸ Premium Ã–zellikler (Sprint 5 ve sonrasÄ±)
Hedef: Premium abonelere daha fazla deÄŸer sunmak.
GÃ¶revler:
[ ] VeritabanÄ±: moods tablosuna owner_id kolonu ekle (nullable, FK to users.id).
[ ] Ekran: Custom Status OluÅŸturma ve YÃ¶netimi (Premium)
[ ] Action: Premium kullanÄ±cÄ±lar, kendi Ã¶zel status'larÄ±nÄ± oluÅŸturabilir (is_custom=true, owner_id=kullanÄ±cÄ±_id).
[ ] Action: OluÅŸturulan custom status'lar, StatusSelector'da default status'lar ile birlikte gÃ¶sterilir.
[ ] Action: Custom status'larÄ± dÃ¼zenleyebilir ve silebilir.
[ ] Backend: Status listesi sorgusu: Default statuses (is_custom=false) + KullanÄ±cÄ±nÄ±n custom status'larÄ± (is_custom=true, owner_id=kullanÄ±cÄ±_id) birleÅŸtirilir.
[ ] Ekran: Custom Mood OluÅŸturma ve YÃ¶netimi (Premium)
[ ] Action: Premium kullanÄ±cÄ±lar, kendi Ã¶zel mood'larÄ±nÄ± oluÅŸturabilir (owner_id=kullanÄ±cÄ±_id).
[ ] Action: OluÅŸturulan custom mood'lar, mood seÃ§ici listede default mood'lar ile birlikte gÃ¶sterilir.
[ ] Action: Custom mood'larÄ± dÃ¼zenleyebilir ve silebilir.
[ ] Backend: Mood listesi sorgusu: Default moods (owner_id IS NULL) + KullanÄ±cÄ±nÄ±n custom mood'larÄ± (owner_id=kullanÄ±cÄ±_id) birleÅŸtirilir.
[ ] ZamanlanmÄ±ÅŸ etkinlik oluÅŸturma ekranÄ±nÄ± ve akÄ±ÅŸÄ±nÄ± geliÅŸtir.
[ ] ZamanlanmÄ±ÅŸ bildirimler iÃ§in cron job mantÄ±ÄŸÄ±nÄ± Supabase Edge Function ile kur.
[ ] KullanÄ±cÄ± geri bildirimlerine gÃ¶re yeni Ã¶zellikler planla.
</file>

<file path="hooks/useManageStatusMood.ts">
import { useCreateMood, useDeleteMood } from '@/api/moods';
import { useCreateStatus, useDeleteStatus } from '@/api/statuses';
import { useAuth } from '@/contexts/AuthContext';
import { usePay } from '@/contexts/PayContext';
import { Alert } from 'react-native';

export function useManageStatusMood(groupId: string) {
  const { user } = useAuth();

  // Mutations
  const createStatus = useCreateStatus();
  const deleteStatus = useDeleteStatus();
  const createMood = useCreateMood();
  const deleteMood = useDeleteMood();

  const { isSubscribed, showPaywall } = usePay();
  const handleAddStatus = async (text: string, emoji?: string) => {
    if (!user) return;
    try {
      await createStatus.mutateAsync({
        text,
        emoji,
        owner_id: user.id,
        group_id: groupId,
        is_custom: true,
        notifies: false,
      });
    } catch (error) {
      console.error('Status ekleme hatasÄ±:', error);
      Alert.alert('Hata', 'Status eklenirken bir hata oluÅŸtu.');
    }
  };

  const handleAddMood = async (text: string, emoji: string) => {
    if (!user) return;

    if (!isSubscribed) {
      showPaywall({
        onSuccess: async () => {
          // Abone olduktan sonra iÅŸlemi tekrar dene
          try {
            await createMood.mutateAsync({
              text,
              emoji,
              group_id: groupId,
            });
          } catch (error) {
            console.error('Mood ekleme hatasÄ± (paywall sonrasÄ±):', error);
            Alert.alert('Hata', 'Mood eklenirken bir hata oluÅŸtu.');
          }
        }
      });
      return;
    }

    try {
      await createMood.mutateAsync({
        text,
        emoji,
        group_id: groupId,
      });
    } catch (error) {
      console.error('Mood ekleme hatasÄ±:', error);
      Alert.alert('Hata', 'Mood eklenirken bir hata oluÅŸtu.');
    }
  };

  const handleDeleteStatus = (id: number) => {
    Alert.alert(
      'Status Sil',
      'Bu statusu silmek istediÄŸinize emin misiniz?',
      [
        { text: 'Ä°ptal', style: 'cancel' },
        {
          text: 'Sil',
          style: 'destructive',
          onPress: async () => {
            try {
              await deleteStatus.mutateAsync(id);
            } catch (error) {
              console.error('Status silme hatasÄ±:', error);
              Alert.alert('Hata', 'Status silinirken bir hata oluÅŸtu.');
            }
          }
        }
      ]
    );
  };

  const handleDeleteMood = (id: number) => {
    Alert.alert(
      'Mood Sil',
      'Bu moodu silmek istediÄŸinize emin misiniz?',
      [
        { text: 'Ä°ptal', style: 'cancel' },
        {
          text: 'Sil',
          style: 'destructive',
          onPress: async () => {
            try {
              await deleteMood.mutateAsync(id);
            } catch (error) {
              console.error('Mood silme hatasÄ±:', error);
              Alert.alert('Hata', 'Mood silinirken bir hata oluÅŸtu.');
            }
          }
        }
      ]
    );
  };

  const checkSubscriptionAndProceed = (onProceed: () => void) => {
    if (isSubscribed) {
      onProceed();
    } else {
      showPaywall({
        onSuccess: () => {
          onProceed();
        }
      });
    }
  };

  return {
    handleAddStatus,
    handleAddMood,
    handleDeleteStatus,
    handleDeleteMood,
    checkSubscriptionAndProceed,
    isCreatingStatus: createStatus.isPending,
    isCreatingMood: createMood.isPending,
  };
}
</file>

<file path="localization/en.json">
{
  "appName": "Geliom"
}
</file>

<file path="localization/tr.json">
{
    "appName": "Geliom"
  }
</file>

<file path="theme/typography.ts">
export interface Fonts {
    light: string;
    regular: string;
    medium: string;
    semibold: string;
    bold: string;
}

interface TypographyVariant {
    fontSize: number;
    lineHeight: number;
    defaultFontWeight: keyof Fonts;
    letterSpacing?: number;
    fontVariant?: string[];
}

export type TypographyKeys = {
    // BaÅŸlÄ±k seviyeleri - Geliom iÃ§in optimize edilmiÅŸ
    h1: TypographyVariant;      // Ana baÅŸlÄ±k (Geliom logo, ana ekran)
    h2: TypographyVariant;      // Sayfa baÅŸlÄ±klarÄ±
    h3: TypographyVariant;      // BÃ¶lÃ¼m baÅŸlÄ±klarÄ±
    h4: TypographyVariant;      // Alt baÅŸlÄ±klar
    h5: TypographyVariant;      // KÃ¼Ã§Ã¼k baÅŸlÄ±klar
    h6: TypographyVariant;      // Mini baÅŸlÄ±klar
    
    // GÃ¶vde metinleri - Sosyal etkileÅŸim iÃ§in optimize
    body: TypographyVariant;    // Ana metin (mesajlar, aÃ§Ä±klamalar)
    bodyLarge: TypographyVariant; // BÃ¼yÃ¼k gÃ¶vde metni
    bodySmall: TypographyVariant; // KÃ¼Ã§Ã¼k gÃ¶vde metni
    
    // Ã–zel kullanÄ±mlar
    caption: TypographyVariant; // KÃ¼Ã§Ã¼k aÃ§Ä±klamalar, zaman damgalarÄ±
    button: TypographyVariant;  // Buton metinleri
    label: TypographyVariant;   // Form etiketleri
    
    // Sosyal Ã¶zellikler iÃ§in
    status: TypographyVariant;  // Durum metinleri ("MÃ¼saitim", "MeÅŸgulÃ¼m")
    nickname: TypographyVariant; // Takma isimler
    groupName: TypographyVariant; // Grup isimleri
};

// Comfortaa font ailesi - Geliom'un doÄŸal ve samimi hissi iÃ§in
export const fonts: Fonts = {
    light: 'Comfortaa-Light',
    regular: 'Comfortaa-Regular',
    medium: 'Comfortaa-Medium',
    semibold: 'Comfortaa-SemiBold',
    bold: 'Comfortaa-Bold',
};

export const typography: TypographyKeys = {
    // Ana baÅŸlÄ±k - Geliom logo ve hoÅŸ geldin mesajlarÄ± iÃ§in
    h1: {
        fontSize: 32,
        lineHeight: 40,
        defaultFontWeight: 'bold',
        letterSpacing: -0.5,
    },
    
    // Sayfa baÅŸlÄ±klarÄ± - "GruplarÄ±m", "Profilim" gibi
    h2: {
        fontSize: 28,
        lineHeight: 36,
        defaultFontWeight: 'semibold',
        letterSpacing: -0.3,
    },
    
    // BÃ¶lÃ¼m baÅŸlÄ±klarÄ± - "ArkadaÅŸlar", "Aile" gibi grup kategorileri
    h3: {
        fontSize: 24,
        lineHeight: 32,
        defaultFontWeight: 'semibold',
        letterSpacing: -0.2,
    },
    
    // Alt baÅŸlÄ±klar - Grup isimleri, etkinlik baÅŸlÄ±klarÄ±
    h4: {
        fontSize: 20,
        lineHeight: 28,
        defaultFontWeight: 'medium',
        letterSpacing: 0,
    },
    
    // KÃ¼Ã§Ã¼k baÅŸlÄ±klar - Ayar kategorileri
    h5: {
        fontSize: 18,
        lineHeight: 24,
        defaultFontWeight: 'medium',
        letterSpacing: 0,
    },
    
    // Mini baÅŸlÄ±klar - Form baÅŸlÄ±klarÄ±
    h6: {
        fontSize: 16,
        lineHeight: 22,
        defaultFontWeight: 'medium',
        letterSpacing: 0,
    },
    
    // Ana gÃ¶vde metni - AÃ§Ä±klamalar, mesajlar
    body: {
        fontSize: 16,
        lineHeight: 24,
        defaultFontWeight: 'regular',
        letterSpacing: 0,
    },
    
    // BÃ¼yÃ¼k gÃ¶vde metni - Ã–nemli aÃ§Ä±klamalar
    bodyLarge: {
        fontSize: 18,
        lineHeight: 26,
        defaultFontWeight: 'regular',
        letterSpacing: 0,
    },
    
    // KÃ¼Ã§Ã¼k gÃ¶vde metni - Ä°kincil bilgiler
    bodySmall: {
        fontSize: 14,
        lineHeight: 20,
        defaultFontWeight: 'regular',
        letterSpacing: 0,
    },
    
    // KÃ¼Ã§Ã¼k aÃ§Ä±klamalar - Zaman damgalarÄ±, yardÄ±mcÄ± metinler
    caption: {
        fontSize: 12,
        lineHeight: 16,
        defaultFontWeight: 'regular',
        letterSpacing: 0.2,
    },
    
    // Buton metinleri - CTA butonlarÄ±
    button: {
        fontSize: 16,
        lineHeight: 20,
        defaultFontWeight: 'semibold',
        letterSpacing: 0.1,
    },
    
    // Form etiketleri
    label: {
        fontSize: 14,
        lineHeight: 18,
        defaultFontWeight: 'medium',
        letterSpacing: 0,
    },
    
    // Durum metinleri - "MÃ¼saitim", "MeÅŸgulÃ¼m" gibi
    status: {
        fontSize: 15,
        lineHeight: 20,
        defaultFontWeight: 'medium',
        letterSpacing: 0,
    },
    
    // Takma isimler - KiÅŸiselleÅŸtirilmiÅŸ isimler
    nickname: {
        fontSize: 16,
        lineHeight: 22,
        defaultFontWeight: 'medium',
        letterSpacing: 0,
    },
    
    // Grup isimleri - Grup kartlarÄ±nda
    groupName: {
        fontSize: 18,
        lineHeight: 24,
        defaultFontWeight: 'semibold',
        letterSpacing: -0.1,
    },
};
</file>

<file path="types/user.ts">
// Geliom User Types - Supabase schema'ya uygun
// NOT: custom_user_id kaldÄ±rÄ±ldÄ± - Supabase auth.users UUID direkt kullanÄ±lÄ±yor

import type { User } from './database';

// GeliomUser artÄ±k database.ts'deki User tipini kullanÄ±yor
// Eski kullanÄ±mlar iÃ§in backward compatibility
export type GeliomUser = User & {
  email?: string; // Auth'dan gelen email (users tablosunda yok)
  current_mood_id?: string; // mood_id ile aynÄ± (string format)
};

export interface UserMood {
  id: string;
  name: string;
  emoji: string;
  color: string;
}

export interface UserStatus {
  id: string;
  user_id: string;
  status_id: string;
  created_at: string;
  status: {
    id: string;
    name: string;
    emoji: string;
    color: string;
    notifies: boolean;
    is_custom: boolean;
  };
}

// Mock Data
export const MOCK_MOODS: UserMood[] = [
  { id: '1', name: 'Mutlu', emoji: 'ğŸ˜Š', color: '#4CAF50' },
  { id: '2', name: 'HeyecanlÄ±', emoji: 'ğŸ¤©', color: '#FF9800' },
  { id: '3', name: 'Sakin', emoji: 'ğŸ˜Œ', color: '#2196F3' },
  { id: '4', name: 'Yorgun', emoji: 'ğŸ˜´', color: '#9E9E9E' },
  { id: '5', name: 'Enerjik', emoji: 'âš¡', color: '#FFEB3B' },
];

export const MOCK_STATUSES = [
  { id: '1', name: 'MÃ¼saitim', emoji: 'âœ…', color: '#4CAF50', notifies: true, is_custom: false },
  { id: '2', name: 'MeÅŸgulÃ¼m', emoji: 'ğŸ”´', color: '#F44336', notifies: true, is_custom: false },
  { id: '3', name: 'DÄ±ÅŸarÄ±dayÄ±m', emoji: 'ğŸš¶', color: '#2196F3', notifies: false, is_custom: false },
  { id: '4', name: 'Evdeyim', emoji: 'ğŸ ', color: '#795548', notifies: false, is_custom: false },
  { id: '5', name: 'Ã‡alÄ±ÅŸÄ±yorum', emoji: 'ğŸ’»', color: '#607D8B', notifies: true, is_custom: false },
];

export const MOCK_USER: GeliomUser = {
  id: 'mock-user-123',
  custom_user_id: 'MOCK1234',
  email: 'hakan@geliom.app',
  display_name: 'Hakan Dursun',
  show_mood: true,
  current_mood_id: '1', // Mutlu
  onesignal_player_id: undefined,
  updated_at: new Date().toISOString(),
};

export const MOCK_SESSION = {
  access_token: 'mock-access-token',
  refresh_token: 'mock-refresh-token',
  expires_in: 3600,
  token_type: 'bearer',
  user: {
    id: MOCK_USER.id,
    email: MOCK_USER.email,
    user_metadata: {
      full_name: MOCK_USER.display_name,
      avatar_url: null,
    },
    app_metadata: {},
    aud: 'authenticated',
    created_at: MOCK_USER.created_at,
    updated_at: MOCK_USER.updated_at,
  },
};
</file>

<file path="utils/storage.ts">
import AsyncStorage from '@react-native-async-storage/async-storage';

// Storage Keys
const STATUS_ORDER_KEY = (userId: string) => `status_order_${userId}`;
const MOOD_ORDER_KEY = (userId: string) => `mood_order_${userId}`;
export const SELECTED_GROUP_STORAGE_KEY = '@geliom:selected_group_id';

/**
 * SeÃ§ili grup ID'sini AsyncStorage'dan alÄ±r
 * @returns SeÃ§ili grup ID'si veya null
 */
export const getSelectedGroupId = async (): Promise<string | null> => {
  try {
    const groupId = await AsyncStorage.getItem(SELECTED_GROUP_STORAGE_KEY);
    return groupId;
  } catch (error) {
    console.error('Selected group ID okuma hatasÄ±:', error);
    return null;
  }
};

/**
 * SeÃ§ili grup ID'sini AsyncStorage'a kaydeder
 * @param groupId Grup ID'si (null ise kaldÄ±rÄ±r)
 */
export const setSelectedGroupId = async (groupId: string | null): Promise<void> => {
  try {
    if (groupId) {
      await AsyncStorage.setItem(SELECTED_GROUP_STORAGE_KEY, groupId);
    } else {
      await AsyncStorage.removeItem(SELECTED_GROUP_STORAGE_KEY);
    }
  } catch (error) {
    console.error('Selected group ID kaydetme hatasÄ±:', error);
  }
};

/**
 * KullanÄ±cÄ±nÄ±n status sÄ±ralamasÄ±nÄ± local storage'dan alÄ±r
 * @param userId KullanÄ±cÄ± ID'si
 * @returns Status ID'lerinin sÄ±ralÄ± dizisi
 */
export const getStatusOrder = async (userId: string): Promise<number[]> => {
  try {
    const stored = await AsyncStorage.getItem(STATUS_ORDER_KEY(userId));
    if (stored) {
      return JSON.parse(stored);
    }
    return [];
  } catch (error) {
    console.error('Status order okuma hatasÄ±:', error);
    return [];
  }
};

/**
 * KullanÄ±cÄ±nÄ±n status sÄ±ralamasÄ±nÄ± local storage'a kaydeder
 * @param userId KullanÄ±cÄ± ID'si
 * @param order Status ID'lerinin sÄ±ralÄ± dizisi
 */
export const saveStatusOrder = async (userId: string, order: number[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(STATUS_ORDER_KEY(userId), JSON.stringify(order));
  } catch (error) {
    console.error('Status order kaydetme hatasÄ±:', error);
  }
};

/**
 * KullanÄ±cÄ±nÄ±n mood sÄ±ralamasÄ±nÄ± local storage'dan alÄ±r
 * @param userId KullanÄ±cÄ± ID'si
 * @returns Mood ID'lerinin sÄ±ralÄ± dizisi
 */
export const getMoodOrder = async (userId: string): Promise<number[]> => {
  try {
    const stored = await AsyncStorage.getItem(MOOD_ORDER_KEY(userId));
    if (stored) {
      return JSON.parse(stored);
    }
    return [];
  } catch (error) {
    console.error('Mood order okuma hatasÄ±:', error);
    return [];
  }
};

/**
 * KullanÄ±cÄ±nÄ±n mood sÄ±ralamasÄ±nÄ± local storage'a kaydeder
 * @param userId KullanÄ±cÄ± ID'si
 * @param order Mood ID'lerinin sÄ±ralÄ± dizisi
 */
export const saveMoodOrder = async (userId: string, order: number[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(MOOD_ORDER_KEY(userId), JSON.stringify(order));
  } catch (error) {
    console.error('Mood order kaydetme hatasÄ±:', error);
  }
};
</file>

<file path=".gitignore">
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts


# Native
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

app-example

# generated native folders
/ios
/android


# for repomix
/app/(drawer)/api-test.tsx
/docs/Green-Color-Palette.md
</file>

<file path="api/provider-auth.ts">
import type { User } from '@supabase/supabase-js';
import * as AppleAuthentication from 'expo-apple-authentication';
import * as AuthSession from 'expo-auth-session';
import Constants from 'expo-constants';
import * as WebBrowser from 'expo-web-browser';
import { Platform } from 'react-native';
import type {
  AuthError,
  AuthProvider,
  NormalizedUserData,
  SupabaseUserMetadata
} from '../types/auth';
import type { UpdateUser } from '../types/database';
import { supabase } from './supabase';

// WebBrowser'Ä± kapatmak iÃ§in
WebBrowser.maybeCompleteAuthSession();

/**
 * OAuth Redirect URL
 * app.json'daki scheme kullanÄ±lÄ±r: geliom://
 * NOT: (auth) grubu URL'de gÃ¶rÃ¼nmez, bu yÃ¼zden path sadece 'callback'
 */
const REDIRECT_URL = AuthSession.makeRedirectUri({
  scheme: 'geliom',
  path: 'auth/callback',
});

/**
 * Google ile giriÅŸ yap
 * Supabase OAuth kullanarak Google authentication
 */
export async function signInWithGoogle(): Promise<{ error: AuthError | null }> {
  try {
    console.log('ğŸ”µ signInWithGoogle baÅŸlatÄ±lÄ±yor...');
    console.log('ğŸ”µ Redirect URL:', REDIRECT_URL);

    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: 'google',
      options: {
        redirectTo: REDIRECT_URL,
        queryParams: {
          access_type: 'offline',
          prompt: 'consent',
        },
      },
    });

    console.log('ğŸ”µ OAuth response - data:', data);
    console.log('ğŸ”µ OAuth response - error:', error);

    if (error) {
      console.error('âŒ OAuth error:', error);
      return {
        error: {
          code: 'PROVIDER_ERROR',
          message: error.message,
          originalError: error,
        },
      };
    }

    if (!data?.url) {
      console.error('âŒ OAuth URL alÄ±namadÄ±');
      return {
        error: {
          code: 'PROVIDER_ERROR',
          message: 'OAuth URL alÄ±namadÄ±',
        },
      };
    }

    console.log('âœ… OAuth URL alÄ±ndÄ±, web browser aÃ§Ä±lÄ±yor:', data.url);

    // Web browser'da OAuth URL'ini aÃ§
    const result = await WebBrowser.openAuthSessionAsync(
      data.url,
      REDIRECT_URL
    );

    console.log('ğŸ”µ WebBrowser result:', result);

    if (result.type === 'cancel') {
      console.log('â„¹ï¸ KullanÄ±cÄ± OAuth iÅŸlemini iptal etti');
      return {
        error: {
          code: 'CANCELLED',
          message: 'GiriÅŸ iptal edildi',
        },
      };
    }

    if (result.type === 'success' && result.url) {
      console.log('âœ… OAuth callback URL alÄ±ndÄ±:', result.url);

      // URL'den hash fragment'i Ã§Ä±kar (React Native'de query params yerine hash kullanÄ±lÄ±r)
      const hashParams = new URLSearchParams(result.url.split('#')[1] || '');
      const accessToken = hashParams.get('access_token');
      const refreshToken = hashParams.get('refresh_token');

      console.log('ğŸ”µ Access token var mÄ±:', !!accessToken);
      console.log('ğŸ”µ Refresh token var mÄ±:', !!refreshToken);

      if (accessToken && refreshToken) {
        console.log('âœ… Tokens alÄ±ndÄ±, session oluÅŸturuluyor...');
        console.log('ğŸ”µ Access token (ilk 20 karakter):', accessToken.substring(0, 20));
        console.log('ğŸ”µ Refresh token (ilk 20 karakter):', refreshToken.substring(0, 20));

        try {
          // Session'Ä± set et
          const { data: sessionData, error: sessionError } = await supabase.auth.setSession({
            access_token: accessToken,
            refresh_token: refreshToken,
          });

          if (sessionError) {
            console.error('âŒ Session oluÅŸturma hatasÄ±:', sessionError);
            console.error('âŒ Session error code:', sessionError.code);
            console.error('âŒ Session error message:', sessionError.message);
            return {
              error: {
                code: 'PROVIDER_ERROR',
                message: sessionError.message,
                originalError: sessionError,
              },
            };
          }

          if (!sessionData?.session) {
            console.error('âŒ Session data yok!');
            return {
              error: {
                code: 'PROVIDER_ERROR',
                message: 'Session oluÅŸturulamadÄ± - session data yok',
              },
            };
          }

          console.log('âœ… Session baÅŸarÄ±yla oluÅŸturuldu');
          console.log('âœ… Session user:', sessionData.session.user?.email);
          console.log('âœ… Session expires at:', sessionData.session.expires_at);

          // Session'Ä±n gerÃ§ekten set edildiÄŸini doÄŸrula (polling, max 3 saniye)
          const maxWaitTime = 3000; // 3 saniye
          const pollInterval = 100; // 100ms
          const startTime = Date.now();
          let verified = false;

          while (Date.now() - startTime < maxWaitTime && !verified) {
            const { data: { session: verifySession }, error: verifyError } = await supabase.auth.getSession();

            if (verifySession && verifySession.user?.id === sessionData.session.user?.id) {
              console.log('âœ… Session doÄŸrulandÄ±, user:', verifySession.user?.email);
              verified = true;
              break;
            }

            if (verifyError) {
              console.error('âŒ Session doÄŸrulama hatasÄ±:', verifyError);
            }

            // Bir sonraki kontrol iÃ§in bekle
            await new Promise(resolve => setTimeout(resolve, pollInterval));
          }

          if (!verified) {
            console.error('âŒ Session doÄŸrulanamadÄ± - timeout');
            return {
              error: {
                code: 'PROVIDER_ERROR',
                message: 'Session doÄŸrulanamadÄ±. LÃ¼tfen tekrar deneyin.',
              },
            };
          }

          // Auth state change listener otomatik tetiklenecek
          return { error: null };
        } catch (error) {
          console.error('âŒ setSession exception:', error);
          return {
            error: {
              code: 'PROVIDER_ERROR',
              message: 'Session oluÅŸturulurken hata oluÅŸtu',
              originalError: error,
            },
          };
        }
      } else {
        // EÄŸer hash'te yoksa, query params'ta olabilir
        const queryParams = new URLSearchParams(result.url.split('?')[1]?.split('#')[0] || '');
        const queryAccessToken = queryParams.get('access_token');
        const queryRefreshToken = queryParams.get('refresh_token');

        if (queryAccessToken && queryRefreshToken) {
          console.log('âœ… Tokens query params\'tan alÄ±ndÄ±, session oluÅŸturuluyor...');

          const { data: sessionData, error: sessionError } = await supabase.auth.setSession({
            access_token: queryAccessToken,
            refresh_token: queryRefreshToken,
          });

          if (sessionError) {
            console.error('âŒ Session oluÅŸturma hatasÄ±:', sessionError);
            return {
              error: {
                code: 'PROVIDER_ERROR',
                message: sessionError.message,
                originalError: sessionError,
              },
            };
          }

          if (!sessionData?.session) {
            console.error('âŒ Session data yok!');
            return {
              error: {
                code: 'PROVIDER_ERROR',
                message: 'Session oluÅŸturulamadÄ± - session data yok',
              },
            };
          }

          console.log('âœ… Session baÅŸarÄ±yla oluÅŸturuldu');
          console.log('âœ… Session user:', sessionData.session.user?.email);

          // Session'Ä±n gerÃ§ekten set edildiÄŸini doÄŸrula (polling, max 3 saniye)
          const maxWaitTime = 3000; // 3 saniye
          const pollInterval = 100; // 100ms
          const startTime = Date.now();
          let verified = false;

          while (Date.now() - startTime < maxWaitTime && !verified) {
            const { data: { session: verifySession }, error: verifyError } = await supabase.auth.getSession();

            if (verifySession && verifySession.user?.id === sessionData.session.user?.id) {
              console.log('âœ… Session doÄŸrulandÄ±, user:', verifySession.user?.email);
              verified = true;
              break;
            }

            if (verifyError) {
              console.error('âŒ Session doÄŸrulama hatasÄ±:', verifyError);
            }

            // Bir sonraki kontrol iÃ§in bekle
            await new Promise(resolve => setTimeout(resolve, pollInterval));
          }

          if (!verified) {
            console.error('âŒ Session doÄŸrulanamadÄ± - timeout');
            return {
              error: {
                code: 'PROVIDER_ERROR',
                message: 'Session doÄŸrulanamadÄ±. LÃ¼tfen tekrar deneyin.',
              },
            };
          }

          return { error: null };
        }

        console.error('âŒ Tokens bulunamadÄ±. URL:', result.url);
        return {
          error: {
            code: 'PROVIDER_ERROR',
            message: 'OAuth token\'larÄ± alÄ±namadÄ±',
          },
        };
      }
    }

    console.error('âŒ Beklenmeyen OAuth sonucu:', result);
    return {
      error: {
        code: 'UNKNOWN_ERROR',
        message: 'OAuth iÅŸlemi tamamlanamadÄ±',
      },
    };
  } catch (error) {
    console.error('âŒ signInWithGoogle exception:', error);
    return {
      error: {
        code: 'UNKNOWN_ERROR',
        message: 'Google ile giriÅŸ yapÄ±lamadÄ±',
        originalError: error,
      },
    };
  }
}

/**
 * Apple ile giriÅŸ yap
 * Native Apple Sign In kullanarak (sadece iOS)
 */
export async function signInWithApple(): Promise<{ error: AuthError | null }> {
  // Sadece iOS'ta Ã§alÄ±ÅŸÄ±r
  if (Platform.OS !== 'ios') {
    return {
      error: {
        code: 'PROVIDER_ERROR',
        message: 'Apple Sign In sadece iOS cihazlarda kullanÄ±labilir',
      },
    };
  }

  try {
    // Apple native authentication
    const credential = await AppleAuthentication.signInAsync({
      requestedScopes: [
        AppleAuthentication.AppleAuthenticationScope.FULL_NAME,
        AppleAuthentication.AppleAuthenticationScope.EMAIL,
      ],
    });

    if (!credential.identityToken) {
      return {
        error: {
          code: 'INVALID_TOKEN',
          message: 'Apple identity token alÄ±namadÄ±',
        },
      };
    }

    // Bundle identifier'Ä± al (Supabase Apple provider client_id olarak kullanÄ±lÄ±r)
    const bundleIdentifier = Constants.expoConfig?.ios?.bundleIdentifier || 'com.eoist.geliom';

    console.log('ğŸ Apple login - Bundle identifier:', bundleIdentifier);
    console.log('ğŸ Apple login - Identity token alÄ±ndÄ±');

    // Supabase'e identity token ile giriÅŸ yap
    // client_id parametresi, Supabase'deki Apple provider'Ä±n Service ID'si ile eÅŸleÅŸmeli
    const { data, error } = await supabase.auth.signInWithIdToken({
      provider: 'apple',
      token: credential.identityToken,
      // client_id: bundleIdentifier, // Supabase'in signInWithIdToken'Ä± client_id'yi desteklemiyor
      // Bunun yerine Supabase dashboard'da Apple provider'Ä±n Service ID'si bundle identifier ile eÅŸleÅŸmeli
    });

    if (error) {
      // "Unacceptable audience" hatasÄ± genellikle Expo Go kullanÄ±mÄ±ndan veya Supabase yapÄ±landÄ±rmasÄ±ndan kaynaklanÄ±r
      let errorMessage = error.message;

      if (error.message?.includes('Unacceptable audience') || error.message?.includes('audience')) {
        errorMessage = `Apple login hatasÄ±: Token audience uyumsuzluÄŸu. 
        
Bu hata genellikle ÅŸu durumlardan kaynaklanÄ±r:
1. Expo Go kullanÄ±yorsanÄ±z, development build kullanmanÄ±z gerekiyor
2. Supabase dashboard'da Apple provider'Ä±n Service ID'si "${bundleIdentifier}" ile eÅŸleÅŸmeli
3. Apple Developer Console'da Service ID'nin bundle identifier'Ä± "${bundleIdentifier}" olmalÄ±

LÃ¼tfen Supabase dashboard'da Apple provider ayarlarÄ±nÄ± kontrol edin.`;
      }

      console.error('âŒ Apple sign in error:', error);
      console.error('âŒ Bundle identifier:', bundleIdentifier);

      return {
        error: {
          code: 'PROVIDER_ERROR',
          message: errorMessage,
          originalError: error,
        },
      };
    }

    if (!data?.session) {
      console.error('âŒ Apple sign in: Session data yok!');
      return {
        error: {
          code: 'PROVIDER_ERROR',
          message: 'Session oluÅŸturulamadÄ± - session data yok',
        },
      };
    }

    console.log('âœ… Apple sign in: Session baÅŸarÄ±yla oluÅŸturuldu');
    console.log('âœ… Session user:', data.session.user?.email);

    // Session'Ä±n gerÃ§ekten set edildiÄŸini doÄŸrula (polling, max 3 saniye)
    const maxWaitTime = 3000; // 3 saniye
    const pollInterval = 100; // 100ms
    const startTime = Date.now();
    let verified = false;

    while (Date.now() - startTime < maxWaitTime && !verified) {
      const { data: { session: verifySession }, error: verifyError } = await supabase.auth.getSession();

      if (verifySession && verifySession.user?.id === data.session.user?.id) {
        console.log('âœ… Apple sign in: Session doÄŸrulandÄ±, user:', verifySession.user?.email);
        verified = true;
        break;
      }

      if (verifyError) {
        console.error('âŒ Apple sign in: Session doÄŸrulama hatasÄ±:', verifyError);
      }

      // Bir sonraki kontrol iÃ§in bekle
      await new Promise(resolve => setTimeout(resolve, pollInterval));
    }

    if (!verified) {
      console.error('âŒ Apple sign in: Session doÄŸrulanamadÄ± - timeout');
      return {
        error: {
          code: 'PROVIDER_ERROR',
          message: 'Session doÄŸrulanamadÄ±. LÃ¼tfen tekrar deneyin.',
        },
      };
    }

    return { error: null };
  } catch (error: any) {
    // KullanÄ±cÄ± iptal etti
    if (error.code === 'ERR_REQUEST_CANCELED') {
      return {
        error: {
          code: 'CANCELLED',
          message: 'GiriÅŸ iptal edildi',
          originalError: error,
        },
      };
    }

    return {
      error: {
        code: 'UNKNOWN_ERROR',
        message: 'Apple ile giriÅŸ yapÄ±lamadÄ±',
        originalError: error,
      },
    };
  }
}

/**
 * Supabase User objesinden normalized data Ã§Ä±kar
 * Apple ve Google metadata farklarÄ±nÄ± handle eder
 */
export function normalizeUserData(
  supabaseUser: User,
  provider: AuthProvider
): NormalizedUserData {
  const metadata = supabaseUser.user_metadata as SupabaseUserMetadata;
  const appMetadata = supabaseUser.app_metadata || {};

  // Display name: full_name, name veya email'den extract
  let displayName: string | null = null;
  if (metadata?.full_name) {
    displayName = metadata.full_name;
  } else if (metadata?.name) {
    displayName = metadata.name;
  } else if (supabaseUser.email) {
    // Email'den kullanÄ±cÄ± adÄ± Ã§Ä±kar (Ã¶rn: hakan@gmail.com -> hakan)
    displayName = supabaseUser.email.split('@')[0];
  }

  // Photo URL: avatar_url veya picture
  const photoUrl: string | null =
    metadata?.avatar_url || metadata?.picture || null;

  return {
    id: supabaseUser.id, // UUID - Supabase auth.users'dan
    email: supabaseUser.email || null,
    displayName: displayName || null,
    photoUrl: photoUrl || null,
    provider,
  };
}

/**
 * KullanÄ±cÄ± profilini oluÅŸtur veya gÃ¼ncelle
 * NOT: custom_user_id database trigger/function tarafÄ±ndan otomatik oluÅŸturulur
 * Bu fonksiyon sadece email ve diÄŸer profil bilgilerini gÃ¼nceller
 */
export async function createOrUpdateUserProfile(
  normalizedData: NormalizedUserData
): Promise<{ data: any | null; error: AuthError | null }> {
  try {
    console.log('ğŸ”µ createOrUpdateUserProfile baÅŸlatÄ±ldÄ±, user ID:', normalizedData.id);

    // Database trigger anÄ±nda Ã§alÄ±ÅŸtÄ±ÄŸÄ± iÃ§in kullanÄ±cÄ± zaten oluÅŸturulmuÅŸ olmalÄ±
    // Sadece profil bilgilerini gÃ¼ncelle
    const updateData: UpdateUser = {
      email: normalizedData.email ?? undefined,
      display_name: normalizedData.displayName ?? undefined,
      photo_url: normalizedData.photoUrl ?? undefined,
      // custom_user_id gÃ¼ncellenmez - database trigger tarafÄ±ndan oluÅŸturulur
    };

    // Sadece undefined olmayan alanlarÄ± gÃ¼ncelle
    const filteredUpdateData: UpdateUser = Object.fromEntries(
      Object.entries(updateData).filter(([_, value]) => value !== undefined)
    ) as UpdateUser;

    if (Object.keys(filteredUpdateData).length === 0) {
      console.log('â„¹ï¸ GÃ¼ncellenecek alan yok, mevcut profili getir...');
      // GÃ¼ncellenecek alan yoksa mevcut profili getir
      const { data: existingUser, error: fetchError } = await supabase
        .from('users')
        .select('*')
        .eq('id', normalizedData.id)
        .single();

      if (fetchError) {
        console.error('âŒ User fetch error:', fetchError);
        return {
          data: null,
          error: {
            code: 'PROVIDER_ERROR',
            message: `KullanÄ±cÄ± profili bulunamadÄ±: ${fetchError.message}`,
            originalError: fetchError,
          },
        };
      }

      return { data: existingUser, error: null };
    }

    console.log('ğŸ”µ Update data:', filteredUpdateData);

    const { data, error } = await supabase
      .from('users')
      .update(filteredUpdateData)
      .eq('id', normalizedData.id)
      .select()
      .single();

    if (error) {
      // EÄŸer kullanÄ±cÄ± bulunamadÄ±ysa (PGRST116), database trigger henÃ¼z Ã§alÄ±ÅŸmamÄ±ÅŸ olabilir
      // Bu durumda kÄ±sa bir bekleme yap ve tekrar dene (sadece 1 kez)
      if (error.code === 'PGRST116') {
        console.log('â³ User profile henÃ¼z oluÅŸturulmamÄ±ÅŸ, kÄ±sa bir bekleme...');
        await new Promise(resolve => setTimeout(resolve, 500));

        const { data: retryData, error: retryError } = await supabase
          .from('users')
          .update(filteredUpdateData)
          .eq('id', normalizedData.id)
          .select()
          .single();

        if (retryError) {
          // Retry sonrasÄ± hala bulunamadÄ±ysa, kullanÄ±cÄ± DB'den silinmiÅŸ olabilir
          // Bu durumda Ã¶zel error code dÃ¶ndÃ¼r, AuthContext logout yapacak
          if (retryError.code === 'PGRST116') {
            console.warn('âš ï¸ KullanÄ±cÄ± DB\'de bulunamadÄ± (retry sonrasÄ±), logout gerekli');
            return {
              data: null,
              error: {
                code: 'USER_NOT_FOUND',
                message: 'KullanÄ±cÄ± veritabanÄ±nda bulunamadÄ±',
                originalError: retryError,
              },
            };
          }
          
          console.error('âŒ User update retry error:', retryError);
          return {
            data: null,
            error: {
              code: 'PROVIDER_ERROR',
              message: `KullanÄ±cÄ± profili gÃ¼ncellenemedi: ${retryError.message}`,
              originalError: retryError,
            },
          };
        }

        console.log('âœ… User profile gÃ¼ncellendi (retry):', retryData?.id);
        return { data: retryData, error: null };
      }

      console.error('âŒ User update error:', error);
      return {
        data: null,
        error: {
          code: 'PROVIDER_ERROR',
          message: `KullanÄ±cÄ± profili gÃ¼ncellenemedi: ${error.message}`,
          originalError: error,
        },
      };
    }

    console.log('âœ… User profile gÃ¼ncellendi:', data?.id);
    return { data, error: null };
  } catch (error) {
    console.error('âŒ createOrUpdateUserProfile exception:', error);
    return {
      data: null,
      error: {
        code: 'UNKNOWN_ERROR',
        message: 'KullanÄ±cÄ± profili iÅŸlemi baÅŸarÄ±sÄ±z',
        originalError: error,
      },
    };
  }
}

/**
 * Provider'dan provider tipini belirle
 */
export function getProviderFromUser(user: User): AuthProvider {
  const providers = user.app_metadata?.providers || [];

  if (providers.includes('apple')) {
    return 'apple';
  }

  if (providers.includes('google')) {
    return 'google';
  }

  // Default olarak google dÃ¶ndÃ¼r
  return 'google';
}
</file>

<file path="api/users.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import type {
  CreateUser,
  UpdateUser,
  User
} from '../types/database';
import { supabase } from './supabase';

// Query Keys
export const userKeys = {
  all: ['users'] as const,
  lists: () => [...userKeys.all, 'list'] as const,
  list: (filters: string) => [...userKeys.lists(), { filters }] as const,
  details: () => [...userKeys.all, 'detail'] as const,
  detail: (id: string) => [...userKeys.details(), id] as const,
  current: () => [...userKeys.all, 'current'] as const,
};

// Queries
export const useUsers = () => {
  return useQuery({
    queryKey: userKeys.lists(),
    queryFn: async (): Promise<User[]> => {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .order('display_name');
      
      if (error) throw error;
      return data || [];
    },
  });
};

export const useUser = (id: string) => {
  return useQuery({
    queryKey: userKeys.detail(id),
    queryFn: async (): Promise<User | null> => {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('id', id)
        .single();
      
      if (error) throw error;
      return data;
    },
    enabled: !!id,
  });
};

export const useCurrentUser = () => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: userKeys.current(),
    queryFn: async (): Promise<User | null> => {
      // Session kontrolÃ¼
      const { data: { session } } = await supabase.auth.getSession();
      if (!session?.user) {
        console.log('ğŸ”µ useCurrentUser: Session yok');
        return null;
      }

      const userId = session.user.id;
      console.log('ğŸ”µ useCurrentUser: User profile fetch ediliyor, user ID:', userId);
      
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('id', userId)
        .single();
      
      if (error) {
        // EÄŸer kullanÄ±cÄ± bulunamadÄ±ysa (PGRST116), database trigger henÃ¼z Ã§alÄ±ÅŸmamÄ±ÅŸ olabilir
        if (error.code === 'PGRST116') {
          console.log('â³ useCurrentUser: User profile henÃ¼z oluÅŸturulmamÄ±ÅŸ, database trigger bekleniyor...');
          return null;
        }
        console.error('âŒ useCurrentUser: Error:', error);
        throw error;
      }
      
      console.log('âœ… useCurrentUser: User profile bulundu:', data?.id);
      return data;
    },
    // Session kontrolÃ¼ queryFn iÃ§inde yapÄ±lÄ±yor, enabled her zaman true
    enabled: true,
    retry: (failureCount, error: any) => {
      // PGRST116 hatasÄ± iÃ§in retry yap (database trigger henÃ¼z Ã§alÄ±ÅŸmamÄ±ÅŸ olabilir)
      // Ama retry sonrasÄ± hala bulunamazsa, kullanÄ±cÄ± DB'den silinmiÅŸ olabilir
      if (error?.code === 'PGRST116' && failureCount < 3) {
        return true;
      }
      // Retry sonrasÄ± hala PGRST116 gelirse, kullanÄ±cÄ± DB'den silinmiÅŸ olabilir
      // Ã–zel error code ile throw et, AuthContext logout yapacak
      if (error?.code === 'PGRST116' && failureCount >= 3) {
        const userNotFoundError = new Error('User not found in database after retries');
        (userNotFoundError as any).code = 'USER_NOT_FOUND';
        (userNotFoundError as any).originalError = error;
        throw userNotFoundError;
      }
      // DiÄŸer hatalar iÃ§in retry yapma
      return false;
    },
    retryDelay: (attemptIndex) => Math.min(500 * 2 ** attemptIndex, 2000), // Exponential backoff (max 2 saniye)
    refetchOnWindowFocus: false, // Window focus'ta refetch yapma
    refetchOnMount: true, // Mount'ta refetch yap
    staleTime: 0, // Her zaman fresh data iste
  });
};

export const useUserByCustomId = (customUserId: string) => {
  return useQuery({
    queryKey: [...userKeys.details(), 'custom', customUserId],
    queryFn: async (): Promise<User | null> => {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('custom_user_id', customUserId)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      return data || null;
    },
    enabled: !!customUserId,
  });
};

// Mutations
export const useCreateUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (userData: CreateUser): Promise<User> => {
      const { data, error } = await supabase
        .from('users')
        .insert(userData)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.all });
    },
  });
};

export const useUpdateUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ id, updates }: { id: string; updates: UpdateUser }): Promise<User> => {
      const { data, error } = await supabase
        .from('users')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) {
        // KullanÄ±cÄ± bulunamadÄ±ysa (DB'den silinmiÅŸse), Ã¶zel error code ile throw et
        // AuthContext bu hatayÄ± yakalayÄ±p logout yapacak
        if (error.code === 'PGRST116') {
          const userNotFoundError = new Error('User not found in database');
          (userNotFoundError as any).code = 'USER_NOT_FOUND';
          (userNotFoundError as any).originalError = error;
          throw userNotFoundError;
        }
        throw error;
      }
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: userKeys.all });
      queryClient.invalidateQueries({ queryKey: userKeys.detail(data.id) });
    },
  });
};

export const useDeleteUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (id: string): Promise<void> => {
      const { error } = await supabase
        .from('users')
        .delete()
        .eq('id', id);
      
      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.all });
    },
  });
};

export const useUpdateUserAvatar = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ userId, avatar }: { userId: string; avatar: string | null }): Promise<User> => {
      const { data, error } = await supabase
        .from('users')
        .update({ avatar })
        .eq('id', userId)
        .select()
        .single();
      
      if (error) {
        if (error.code === 'PGRST116') {
          const userNotFoundError = new Error('User not found in database');
          (userNotFoundError as any).code = 'USER_NOT_FOUND';
          (userNotFoundError as any).originalError = error;
          throw userNotFoundError;
        }
        throw error;
      }
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: userKeys.all });
      queryClient.invalidateQueries({ queryKey: userKeys.detail(data.id) });
      queryClient.invalidateQueries({ queryKey: userKeys.current() });
    },
  });
};

// Realtime Subscription Hook
export const useUsersRealtime = () => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['users-realtime'],
    queryFn: () => {
      const channel = supabase
        .channel('users-changes')
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'users',
          },
          () => {
            queryClient.invalidateQueries({ queryKey: userKeys.all });
          }
        )
        .subscribe();

      return channel;
    },
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};
</file>

<file path="app/(auth)/login.tsx">
import { signInWithApple, signInWithGoogle } from "@/api/provider-auth";
import { Typography } from "@/components/shared";
import { useTheme } from "@/contexts/ThemeContext";
import { Ionicons } from '@expo/vector-icons';
import * as AppleAuthentication from 'expo-apple-authentication';
import React, { useState } from 'react';
import {
  ActivityIndicator,
  Alert,
  Image,
  Platform,
  StyleSheet,
  TouchableOpacity,
  View,
} from "react-native";
import { SafeAreaView } from 'react-native-safe-area-context';

export default function Login() {
  const { colors } = useTheme();
  const [isLoadingGoogle, setIsLoadingGoogle] = useState(false);
  const [isLoadingApple, setIsLoadingApple] = useState(false);

  // Helper to manage loading state for both
  const isLoading = isLoadingGoogle || isLoadingApple;

  // Google ile giriÅŸ
  const handleGoogleLogin = async () => {
    // EÄŸer zaten loading ise, duplicate tÄ±klamayÄ± engelle
    if (isLoadingGoogle) {
      console.log('âš ï¸ Google login zaten baÅŸlatÄ±lmÄ±ÅŸ, duplicate tÄ±klama engellendi');
      return;
    }

    try {
      console.log('ğŸ”µ Google login baÅŸlatÄ±lÄ±yor...');
      setIsLoadingGoogle(true);

      const result = await signInWithGoogle();
      console.log('ğŸ”µ Google login sonucu:', result);

      if (result.error) {
        console.error('âŒ Google login hatasÄ±:', result.error);
        if (result.error.code === 'CANCELLED') {
          console.log('â„¹ï¸ KullanÄ±cÄ± giriÅŸi iptal etti');
          setIsLoadingGoogle(false); // Stop loading on cancel
          return;
        }

        Alert.alert('Hata', result.error.message || 'Google ile giriÅŸ yapÄ±lamadÄ±');
        setIsLoadingGoogle(false); // Stop loading on error
        return;
      }

      console.log('âœ… OAuth flow baÅŸarÄ±yla tamamlandÄ±, routing bekleniyor...');
      // Loading state'i false yapmÄ±yoruz, _layout routing yapacak
      // ve kullanÄ±cÄ± otomatik yÃ¶nlendirilecek
    } catch (error) {
      console.error('âŒ Google login exception:', error);
      Alert.alert('Hata', 'Google ile giriÅŸ yapÄ±lamadÄ±');
      setIsLoadingGoogle(false); // Stop loading on exception
    }
  };

  // Apple ile giriÅŸ
  const handleAppleLogin = async () => {
    // EÄŸer zaten loading ise, duplicate tÄ±klamayÄ± engelle
    if (isLoadingApple) {
      console.log('âš ï¸ Apple login zaten baÅŸlatÄ±lmÄ±ÅŸ, duplicate tÄ±klama engellendi');
      return;
    }

    try {
      setIsLoadingApple(true);

      const { error } = await signInWithApple();

      if (error) {
        if (error.code === 'CANCELLED') {
          console.log('â„¹ï¸ KullanÄ±cÄ± Apple giriÅŸi iptal etti');
          // Important: Set loading to false on cancel
          setIsLoadingApple(false);
          return;
        }

        Alert.alert('Hata', error.message || 'Apple ile giriÅŸ yapÄ±lamadÄ±');
        setIsLoadingApple(false); // Stop loading on error
        return;
      }

      console.log('âœ… Apple login baÅŸarÄ±lÄ±, routing bekleniyor...');
      // Loading state'i false yapmÄ±yoruz, _layout routing yapacak
    } catch (error) {
      Alert.alert('Hata', 'Apple ile giriÅŸ yapÄ±lamadÄ±');
      console.error('Apple login error:', error);
      setIsLoadingApple(false); // Stop loading on exception
    }
  };

  return (
    // Use the theme background color
    <SafeAreaView
      style={[styles.container, { backgroundColor: colors.background }]}
      edges={['top', 'bottom']}
    >
      {/* Main content area, centered and balanced */}
      <View style={styles.contentContainer}>

        {/* Top section with app icon, name, and description */}
        <View style={styles.topSection}>
          {/* Nature-themed icon */}
          <Image source={require('@/assets/images/icon.png')} style={styles.logoIcon} />
          <Typography variant="h2" color={colors.text} style={styles.appName}>
            Geliom
          </Typography>
          <Typography variant="bodyLarge" color={colors.secondaryText} style={styles.description}>
            ArkadaÅŸlarÄ±nla ve ailenle anlÄ±k baÄŸlantÄ± kur
          </Typography>
        </View>

        {/* Bottom section with login buttons and terms */}
        <View style={styles.bottomSection}>
          <View style={styles.buttonContainer}>
            {/* Google Login Button */}
            <TouchableOpacity
              style={[
                styles.loginButton,
                {
                  // Use cardBackground for better dark mode compatibility
                  backgroundColor: colors.cardBackground,
                  borderColor: colors.stroke,
                  shadowColor: colors.shadow,
                },
              ]}
              onPress={handleGoogleLogin}
              disabled={isLoading}
              activeOpacity={0.8}
            >
              {isLoadingGoogle ? (
                <ActivityIndicator size="small" color={colors.primary} />
              ) : (
                <Ionicons name="logo-google" size={24} color="#4285F4" />
              )}
              <Typography
                variant="button"
                color={colors.text}
                style={styles.buttonText}
              >
                Google ile GiriÅŸ Yap
              </Typography>
              {/* Spacer view to keep text centered */}
              <View style={styles.buttonIconSpacer} />
            </TouchableOpacity>

            {/* Apple Login - Only show on iOS */}
            {Platform.OS === 'ios' && (
              <AppleAuthentication.AppleAuthenticationButton
                buttonType={AppleAuthentication.AppleAuthenticationButtonType.SIGN_IN}
                // WHITE_OUTLINE looks much better on light/dark themed backgrounds
                buttonStyle={AppleAuthentication.AppleAuthenticationButtonStyle.WHITE_OUTLINE}
                cornerRadius={16}
                style={styles.appleButton}
                onPress={handleAppleLogin}
                // Note: The Apple button has its own loading state,
                // so we don't need to check isLoadingApple here.
              />
            )}
          </View>

          {/* Terms and privacy */}
          <Typography variant="caption" color={colors.secondaryText} style={styles.termsText}>
            GiriÅŸ yaparak KullanÄ±m ÅartlarÄ± ve Gizlilik PolitikasÄ±'nÄ± kabul etmiÅŸ olursunuz
          </Typography>
        </View>
      </View>
    </SafeAreaView>
  );
}

// A more compact, centered, and theme-aware stylesheet
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  contentContainer: {
    flex: 1,
    justifyContent: 'space-around', // Balances top and bottom sections
    paddingHorizontal: 24,
    paddingVertical: 32,
  },
  topSection: {
    alignItems: 'center',
  },
  logoIcon: {
    width: 80,
    height: 80,
    marginBottom: 16,
  },
  appName: {
    textAlign: 'center',
    marginBottom: 8,
  },
  description: {
    textAlign: 'center',
    paddingHorizontal: 20,
  },
  bottomSection: {
    width: '100%',
  },
  buttonContainer: {
    width: '100%',
    gap: 16, // Space between buttons
    marginBottom: 24,
  },
  loginButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 18,
    paddingHorizontal: 24,
    borderRadius: 16,
    minHeight: 56, // Match Apple button height
    borderWidth: 1,
    // Shadow for depth
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 5,
    elevation: 3, // for Android
  },
  buttonText: {
    flex: 1, // Allows text to be centered
    textAlign: 'center',
    marginLeft: 12,
  },
  // This spacer helps center the text when the icon is on the left
  buttonIconSpacer: {
    width: 24, // Same width as the icon
  },
  appleButton: {
    height: 56, // Standard height
    width: '100%',
  },
  termsText: {
    textAlign: 'center',
    lineHeight: 18,
    paddingHorizontal: 20,
  },
});
</file>

<file path="app/(drawer)/(group)/_layout.tsx">
import { useGroupJoinRequests } from '@/api';
import { useAuth } from '@/contexts/AuthContext';
import { useGroupContext } from '@/contexts/GroupContext';
import { useTheme } from '@/contexts/ThemeContext';
import { router, Stack } from 'expo-router';
import React from 'react';
import { StyleSheet } from 'react-native';

export default function GroupStackLayout() {
  const { selectedGroup } = useGroupContext();
  const { user } = useAuth();
  const { colors } = useTheme();
  const isOwner = selectedGroup?.owner_id === user?.id;
  const { data: joinRequests = [] } = useGroupJoinRequests(selectedGroup?.id || '', 'pending');
  const pendingRequestsCount = joinRequests.length;
  const handleJoinRequestsPress = () => {
    if (selectedGroup) {
      router.push('/(drawer)/(group)/join-requests');
    }
  };


  return (
    <Stack
      screenOptions={{
        headerShown: false, // TÃ¼m stack ekranlarÄ±nda header kapalÄ±
      }}
    >
      <Stack.Screen
        name="create-group"

      />
      <Stack.Screen
        name="join-group"

      />
      <Stack.Screen
        name="join-requests"

      />
      <Stack.Screen
        name="search-user"

      />
      <Stack.Screen
        name="manage-members"

      />
      <Stack.Screen
        name="group-management"
      />
    </Stack>
  );
}

const styles = StyleSheet.create({
  headerRight: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    paddingRight: 16,
  },
  actionButton: {
    width: 36,
    height: 36,
    borderRadius: 18,
    borderWidth: 1,
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
  },
  badge: {
    position: 'absolute',
    top: -4,
    right: -4,
    minWidth: 18,
    height: 18,
    borderRadius: 9,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 4,
  },
  badgeText: {
    fontSize: 10,
    fontWeight: 'bold',
  },
});
</file>

<file path="components/dashboard/MemberCard.tsx">
import { Typography } from '@/components/shared';
import { useTheme } from '@/contexts/ThemeContext';
import type { GroupMemberWithUser, UserGroupMoodWithMood, UserStatusWithStatus } from '@/types/database';
import { getAvatarSource } from '@/utils/avatar';
import { Ionicons } from '@expo/vector-icons';
import React, { useEffect } from 'react';
import { Image, StyleSheet, View } from 'react-native';
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withRepeat,
  withSequence,
  withSpring,
  withTiming
} from 'react-native-reanimated';

interface MemberCardProps {
  member: GroupMemberWithUser;
  status?: UserStatusWithStatus;
  mood?: UserGroupMoodWithMood;
  isMe?: boolean;
  nickname?: string;
  variant?: 'default' | 'large'; // 'large' is now the "Minimalist Status Header"
}

export default function MemberCard({
  member,
  status,
  mood,
  isMe,
  nickname,
  variant = 'default'
}: MemberCardProps) {
  const { colors } = useTheme();
  const user = member.user;

  // Animation Values
  const moodScale = useSharedValue(1);
  const statusOpacity = useSharedValue(0);

  // Status deÄŸiÅŸtiÄŸinde glow efekti
  useEffect(() => {
    if (status?.status?.text) {
      statusOpacity.value = withSequence(
        withTiming(1, { duration: 300 }),
        withRepeat(withTiming(0.5, { duration: 800 }), 2, true),
        withTiming(0, { duration: 300 })
      );
    }
  }, [status?.status?.id]); // ID deÄŸiÅŸtiÄŸinde tetikle

  // Mood deÄŸiÅŸtiÄŸinde scale efekti
  useEffect(() => {
    if (mood?.mood?.emoji) {
      moodScale.value = withSequence(
        withSpring(1.5),
        withSpring(1)
      );
    }
  }, [mood?.mood?.id]);

  const animatedMoodStyle = useAnimatedStyle(() => ({
    transform: [{ scale: moodScale.value }],
  }));

  const animatedStatusGlowStyle = useAnimatedStyle(() => ({
    opacity: statusOpacity.value,
  }));

  if (!user) return null;

  // GÃ¶rÃ¼ntÃ¼lenecek isim: nickname varsa onu, yoksa display_name veya custom_user_id
  const displayName = nickname || user.display_name || user.custom_user_id;
  const realName = nickname ? (user.display_name || user.custom_user_id) : undefined;

  // Durum rengi ve ikonu (VarsayÄ±lan: gri/bilinmiyor)
  const statusColor = status?.status?.is_custom ? colors.primary : (status?.status?.notifies ? colors.warning : colors.secondaryText);
  const statusText = status?.status?.text;

  const isLarge = variant === 'large';

  return (
    <View style={[
      styles.container,
      isLarge && styles.largeContainer,
      {
        backgroundColor: isLarge
          ? 'transparent' // Minimalist: No background
          : (isMe ? colors.tertiary + '20' : colors.cardBackground),
        borderColor: isLarge ? 'transparent' : (isMe ? colors.primary : colors.stroke),
        borderWidth: isLarge ? 0 : 1,
      }
    ]}>
      {/* Glow Effect Background (for status change) - Only for default cards or subtle for large */}
      {!isLarge && (
        <Animated.View
          style={[
            StyleSheet.absoluteFill,
            { backgroundColor: statusColor, borderRadius: 16 },
            animatedStatusGlowStyle
          ]}
        />
      )}

      {/* Ä°Ã§erik Container */}
      <View style={[styles.contentWrapper, isLarge && styles.largeContentWrapper]}>
        {/* Avatar BÃ¶lÃ¼mÃ¼ */}
        <View style={[
          styles.avatarContainer,
          isLarge && styles.largeAvatarContainer,
          { backgroundColor: colors.tertiary }
        ]}>
          <Image
            source={getAvatarSource(user.avatar)}
            style={[styles.avatarImage, isLarge && styles.largeAvatarImage]}
            resizeMode="cover"
          />

          {/* Mood Emojisi (AvatarÄ±n kÃ¶ÅŸesinde) */}
          {mood?.mood?.emoji && (
            <Animated.View style={[
              styles.moodBadge,
              isLarge && styles.largeMoodBadge,
              animatedMoodStyle
            ]}>
              <Typography variant={isLarge ? "h5" : "h6"}>{mood.mood.emoji}</Typography>
            </Animated.View>
          )}
        </View>

        {/* Ä°sim ve Durum */}
        <View style={[styles.infoContainer, isLarge && styles.largeInfoContainer]}>
          <View style={[styles.nameRow, isLarge && styles.largeNameRow]}>
            <View style={{ flex: 1 }}>
              {/* Minimalist Header: Name is smaller, Status is HUGE */}
              {isLarge ? (
                <>
                  <Typography
                    variant="caption"
                    color={colors.secondaryText}
                    numberOfLines={1}
                    style={{ marginBottom: 4 }}
                  >
                    Merhaba, {displayName} ğŸ‘‹
                  </Typography>
                  <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                    <Typography
                      variant="h5"
                      color={statusText ? colors.text : colors.secondaryText}
                      numberOfLines={1}
                      style={{ fontWeight: '700' }}
                    >
                      {statusText || 'Durum ayarla...'}
                    </Typography>
                    {statusText && (
                      <Animated.View style={[{ marginLeft: 8 }, animatedStatusGlowStyle]}>
                        <Ionicons name="radio-button-on" size={16} color={statusColor} />
                      </Animated.View>
                    )}
                  </View>
                </>
              ) : (
                <>
                  <Typography
                    variant="body"
                    fontWeight="semibold"
                    color={colors.text}
                    numberOfLines={1}
                  >
                    {displayName} {isMe && '(Sen)'}
                  </Typography>
                  {realName && (
                    <Typography
                      variant="caption"
                      color={colors.secondaryText}
                      numberOfLines={1}
                      style={{ marginTop: 2 }}
                    >
                      {realName}
                    </Typography>
                  )}
                </>
              )}
            </View>
          </View>

          {/* Durum GÃ¶stergesi (Only for default cards) */}
          {!isLarge && (
            statusText ? (
              <View style={styles.statusRow}>
                <Ionicons name="radio-button-on" size={12} color={statusColor} />
                <Typography
                  variant="caption"
                  color={statusColor}
                  numberOfLines={1}
                  style={{ marginLeft: 4, flex: 1 }}
                >
                  {statusText}
                </Typography>
              </View>
            ) : (
              <Typography variant="caption" color={colors.secondaryText} style={{ fontStyle: 'italic' }}>
                Durum yok
              </Typography>
            )
          )}
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    borderRadius: 16,
    borderWidth: 1,
    marginBottom: 12,
    // GÃ¶lge efekti
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 3.84,
    elevation: 2,
    overflow: 'hidden', // Glow efekti iÃ§in
  },
  largeContainer: {
    marginBottom: 16,
    borderRadius: 0,
    borderWidth: 0,
    shadowOpacity: 0,
    elevation: 0,
    backgroundColor: 'transparent',
  },
  contentWrapper: {
    flexDirection: 'row',
    padding: 12,
    alignItems: 'center',
    backgroundColor: 'transparent', // Glow'u gÃ¶rmek iÃ§in
  },
  largeContentWrapper: {
    padding: 0,
    paddingVertical: 8,
    gap: 16,
  },
  avatarContainer: {
    width: 50,
    height: 50,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
    overflow: 'visible',
  },
  largeAvatarContainer: {
    width: 56,
    height: 56,
    borderRadius: 28,
  },
  avatarImage: {
    width: 50,
    height: 50,
    borderRadius: 25,
  },
  largeAvatarImage: {
    width: 56,
    height: 56,
    borderRadius: 28,
  },
  moodBadge: {
    position: 'absolute',
    bottom: 0,
    right: 0,
    backgroundColor: 'white',
    borderRadius: 10,
    width: 20,
    height: 20,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1.41,
    elevation: 2,
    zIndex: 10,
  },
  largeMoodBadge: {
    width: 24,
    height: 24,
    borderRadius: 12,
    bottom: -2,
    right: -2,
  },
  infoContainer: {
    flex: 1,
    marginLeft: 12,
    justifyContent: 'center',
  },
  largeInfoContainer: {
    marginLeft: 0,
    justifyContent: 'center',
  },
  nameRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  largeNameRow: {
    marginBottom: 0,
  },
  statusRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  largeStatusRow: {
    // Not used in minimalist
  },
});
</file>

<file path="components/CustomDrawerContent.tsx">
import { useUpdateUser } from '@/api/users';
import { Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useBottomSheet } from '@/contexts/BottomSheetContext';
import { useTheme } from '@/contexts/ThemeContext';
import { openPrivacyPolicy, openTermsOfUse } from '@/utils/linking';
import { Ionicons } from '@expo/vector-icons';
import { DrawerContentComponentProps, DrawerContentScrollView, DrawerItem } from '@react-navigation/drawer';
import { useRouter } from 'expo-router';
import React, { useEffect, useState } from 'react';
import { Alert, Modal, StyleSheet, Switch, TextInput, TouchableOpacity, View } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

const CustomDrawerContent: React.FC<DrawerContentComponentProps> = (props) => {
    const { colors, toggleTheme, isDark } = useTheme();
    const { user, signOut } = useAuth();
    const { closeBottomSheet } = useBottomSheet();
    const insets = useSafeAreaInsets();
    const router = useRouter();
    const [editNameModalVisible, setEditNameModalVisible] = useState(false);
    const [newDisplayName, setNewDisplayName] = useState('');
    const updateUserMutation = useUpdateUser();

    // Drawer aÃ§Ä±ldÄ±ÄŸÄ±nda bottom sheet'i kapat
    useEffect(() => {
        closeBottomSheet();
    }, [closeBottomSheet]);

    const handleSignOut = () => {
        props.navigation.closeDrawer();
        signOut();
    };

    const handleSettings = () => {
        props.navigation.closeDrawer();
        router.push('/(drawer)/settings');
    };

    const handleHelpSupport = () => {
        props.navigation.closeDrawer();
        router.push('/(drawer)/help-support');
    };

    const handlePrivacy = () => {
        props.navigation.closeDrawer();
        openPrivacyPolicy();
    };

    const handleTerms = () => {
        props.navigation.closeDrawer();
        openTermsOfUse();
    };

    const handleEditName = () => {
        setNewDisplayName(user?.display_name || '');
        setEditNameModalVisible(true);
    };

    const handleSaveDisplayName = () => {
        if (!user?.id) return;
        if (!newDisplayName.trim()) {
            Alert.alert('Hata', 'Ä°sim boÅŸ olamaz');
            return;
        }

        updateUserMutation.mutate(
            { id: user.id, updates: { display_name: newDisplayName.trim() } },
            {
                onSuccess: () => {
                    setEditNameModalVisible(false);
                    Alert.alert('BaÅŸarÄ±lÄ±', 'Ä°sminiz gÃ¼ncellendi');
                },
                onError: (error) => {
                    Alert.alert('Hata', 'Ä°sim gÃ¼ncellenirken bir hata oluÅŸtu');
                    console.error('Display name update error:', error);
                },
            }
        );
    };

    return (
        <View style={[styles.container, { backgroundColor: colors.background }]}>
            {/* Profil BÃ¶lÃ¼mÃ¼ */}
            <View
                style={[
                    styles.profileSection,
                    {
                        borderBottomColor: colors.stroke,
                        paddingTop: insets.top + 20,
                    }
                ]}
            >
                <View style={[styles.avatar, { backgroundColor: colors.primary }]}>
                    <Typography variant="h4" color={colors.white}>
                        {user?.display_name?.charAt(0).toUpperCase() || 'G'}
                    </Typography>
                </View>
                <View style={styles.profileInfo}>
                    <View style={styles.nameContainer}>
                        <Typography variant="h5" color={colors.text} style={styles.profileName}>
                            {user?.display_name || 'Geliom User'}
                        </Typography>
                        <TouchableOpacity onPress={handleEditName} style={styles.editIcon}>
                            <Ionicons name="pencil" size={16} color={colors.secondaryText} />
                        </TouchableOpacity>
                    </View>
                    <Typography variant="caption" color={colors.secondaryText}>
                        {user?.email || 'user@geliom.app'}
                    </Typography>
                </View>
            </View>

            {/* Navigation Items */}
            <DrawerContentScrollView {...props} contentContainerStyle={styles.scrollContent}>
                <DrawerItem
                    label="Gruplar"
                    onPress={() => props.navigation.navigate('home')}
                    icon={({ color, size }) => <Ionicons name="people" size={size} color={color} />}
                    labelStyle={[styles.drawerLabel, { color: colors.text }]}
                    focused={props.state.index === 0}
                    activeTintColor={colors.primary}
                    inactiveTintColor={colors.secondaryText}
                />

                {/* Tema DeÄŸiÅŸikliÄŸi with Switch */}
                <View style={[styles.themeItem, { backgroundColor: 'transparent' }]}>
                    <View style={styles.themeLeft}>
                        <Ionicons 
                            name={isDark ? "moon" : "sunny"} 
                            size={22} 
                            color={colors.secondaryText} 
                            style={styles.themeIcon}
                        />
                        <Typography variant="body" color={colors.text} style={styles.drawerLabel}>
                            Tema
                        </Typography>
                    </View>
                    <Switch
                        value={isDark}
                        onValueChange={toggleTheme}
                        trackColor={{ false: colors.stroke, true: colors.primary + '80' }}
                        thumbColor={isDark ? colors.primary : colors.white}
                    />
                </View>

                <DrawerItem
                    label="Gizlilik PolitikasÄ±"
                    onPress={handlePrivacy}
                    icon={({ color, size }) => <Ionicons name="shield-checkmark" size={size} color={color} />}
                    labelStyle={[styles.drawerLabel, { color: colors.text }]}
                    activeTintColor={colors.primary}
                    inactiveTintColor={colors.secondaryText}
                    style={styles.externalLinkItem}
                />

                <DrawerItem
                    label="KullanÄ±m ÅartlarÄ±"
                    onPress={handleTerms}
                    icon={({ color, size }) => <Ionicons name="document-text" size={size} color={color} />}
                    labelStyle={[styles.drawerLabel, { color: colors.text }]}
                    activeTintColor={colors.primary}
                    inactiveTintColor={colors.secondaryText}
                    style={styles.externalLinkItem}
                />

                <DrawerItem
                    label="YardÄ±m & Destek"
                    onPress={handleHelpSupport}
                    icon={({ color, size }) => <Ionicons name="help-circle" size={size} color={color} />}
                    labelStyle={[styles.drawerLabel, { color: colors.text }]}
                    activeTintColor={colors.primary}
                    inactiveTintColor={colors.secondaryText}
                />

                <DrawerItem
                    label="Ayarlar"
                    onPress={handleSettings}
                    icon={({ color, size }) => <Ionicons name="settings" size={size} color={color} />}
                    labelStyle={[styles.drawerLabel, { color: colors.text }]}
                    activeTintColor={colors.primary}
                    inactiveTintColor={colors.secondaryText}
                />
            </DrawerContentScrollView>

            {/* Alt BÃ¶lÃ¼m */}
            <View style={[styles.bottomSection, { paddingBottom: insets.bottom + 20 }]}>
                <DrawerItem
                    label="Ã‡Ä±kÄ±ÅŸ Yap"
                    onPress={handleSignOut}
                    icon={({ color, size }) => <Ionicons name="log-out" size={size} color={color} />}
                    labelStyle={[styles.drawerLabel, { color: colors.error }]}
                    activeTintColor={colors.error}
                    inactiveTintColor={colors.error}
                />

                <View style={[styles.appInfo, { borderTopColor: colors.stroke }]}>
                    <Typography variant="caption" color={colors.secondaryText} style={styles.appVersion}>
                        Geliom v1.0.0
                    </Typography>
                    <Typography variant="caption" color={colors.secondaryText}>
                        ğŸ‘¥ Birlikte daha gÃ¼Ã§lÃ¼
                    </Typography>
                </View>
            </View>

            {/* Edit Display Name Modal */}
            <Modal
                visible={editNameModalVisible}
                transparent
                animationType="fade"
                onRequestClose={() => setEditNameModalVisible(false)}
            >
                <TouchableOpacity
                    style={styles.modalOverlay}
                    activeOpacity={1}
                    onPress={() => setEditNameModalVisible(false)}
                >
                    <View style={[styles.modalContent, { backgroundColor: colors.cardBackground }]}>
                        <Typography variant="h4" color={colors.text} style={styles.modalTitle}>
                            Ä°sminizi DÃ¼zenleyin
                        </Typography>
                        
                        <TextInput
                            style={[styles.textInput, { 
                                backgroundColor: colors.background, 
                                color: colors.text,
                                borderColor: colors.stroke 
                            }]}
                            value={newDisplayName}
                            onChangeText={setNewDisplayName}
                            placeholder="Ä°sminiz"
                            placeholderTextColor={colors.secondaryText}
                            autoFocus
                            maxLength={50}
                        />

                        <View style={styles.modalButtons}>
                            <TouchableOpacity
                                style={[styles.modalButton, { backgroundColor: colors.stroke }]}
                                onPress={() => setEditNameModalVisible(false)}
                            >
                                <Typography variant="body" color={colors.text}>
                                    Ä°ptal
                                </Typography>
                            </TouchableOpacity>
                            
                            <TouchableOpacity
                                style={[styles.modalButton, { backgroundColor: colors.primary }]}
                                onPress={handleSaveDisplayName}
                                disabled={updateUserMutation.isPending}
                            >
                                <Typography variant="body" color={colors.white}>
                                    {updateUserMutation.isPending ? 'Kaydediliyor...' : 'Kaydet'}
                                </Typography>
                            </TouchableOpacity>
                        </View>
                    </View>
                </TouchableOpacity>
            </Modal>
        </View>
    );
};

const styles = StyleSheet.create({
    container: {
        flex: 1,
    },
    profileSection: {
        flexDirection: 'row',
        alignItems: 'center',
        paddingHorizontal: 20,
        paddingBottom: 20,
        marginBottom: 20,
        borderBottomWidth: 1,
    },
    avatar: {
        width: 60,
        height: 60,
        borderRadius: 30,
        justifyContent: 'center',
        alignItems: 'center',
        marginRight: 16,
    },
    profileInfo: {
        flex: 1,
    },
    nameContainer: {
        flexDirection: 'row',
        alignItems: 'center',
        gap: 8,
    },
    profileName: {
        marginBottom: 4,
    },
    editIcon: {
        padding: 4,
    },
    scrollContent: {
        paddingTop: 0,
    },
    drawerLabel: {
        fontFamily: 'Comfortaa-Medium',
        fontSize: 16,
        marginLeft: 4,
    },
    themeItem: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        paddingHorizontal: 16,
        paddingVertical: 12,
        marginHorizontal: 8,
        marginVertical: 4,
    },
    themeLeft: {
        flexDirection: 'row',
        alignItems: 'center',
        flex: 1,
    },
    themeIcon: {
        marginRight: 4,
    },
    externalLinkItem: {
        position: 'relative',
    },
    bottomSection: {
        borderTopWidth: 1,
        borderTopColor: '#E0E0E0',
    },
    appInfo: {
        paddingHorizontal: 20,
        paddingTop: 16,
        borderTopWidth: 1,
        alignItems: 'center',
    },
    appVersion: {
        marginBottom: 4,
    },
    modalOverlay: {
        flex: 1,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        justifyContent: 'center',
        alignItems: 'center',
        padding: 20,
    },
    modalContent: {
        width: '100%',
        maxWidth: 400,
        borderRadius: 20,
        padding: 24,
    },
    modalTitle: {
        marginBottom: 20,
        textAlign: 'center',
    },
    textInput: {
        borderWidth: 1,
        borderRadius: 12,
        padding: 12,
        fontSize: 16,
        fontFamily: 'Comfortaa-Medium',
        marginBottom: 20,
    },
    modalButtons: {
        flexDirection: 'row',
        gap: 12,
    },
    modalButton: {
        flex: 1,
        paddingVertical: 12,
        borderRadius: 12,
        alignItems: 'center',
    },
});

export default CustomDrawerContent;
</file>

<file path="components/NotificationHandler.tsx">
import { groupKeys } from '@/api/groups';
import { useAuth } from '@/contexts/AuthContext';
import { useGroupContext } from '@/contexts/GroupContext';
import { setSelectedGroupId } from '@/utils/storage';
import { useQueryClient } from '@tanstack/react-query';
import { useRouter } from 'expo-router';
import { useEffect, useRef } from 'react';
import { OneSignal } from 'react-native-onesignal';

/**
 * NotificationHandler Component
 * 
 * OneSignal bildirimlerini handle eder:
 * - Bildirime tÄ±klandÄ±ÄŸÄ±nda ilgili gruba yÃ¶nlendirir
 * - GroupContext'i kullanarak grubu seÃ§er
 * - AsyncStorage'Ä± gÃ¼nceller
 * - Grup bulunamadÄ±ÄŸÄ±nda gruplarÄ± refresh eder
 */
export function NotificationHandler() {
  const router = useRouter();
  const { user } = useAuth();
  const { setSelectedGroup, groups } = useGroupContext();
  const queryClient = useQueryClient();
  const groupsRef = useRef(groups);
  const pendingGroupIdRef = useRef<string | null>(null);
  const retryCountRef = useRef<number>(0);
  const MAX_RETRY = 3;

  // Update ref when groups change
  useEffect(() => {
    groupsRef.current = groups;

    // Check if we have a pending navigation
    if (pendingGroupIdRef.current && groups.length > 0) {
      const group = groups.find((g: any) => g.id === pendingGroupIdRef.current);
      if (group) {
        console.log('ğŸ”„ Pending navigation executing for group:', group.name);
        handleGroupNavigation(group);
        pendingGroupIdRef.current = null;
      }
    }
  }, [groups]);

  const handleGroupNavigation = async (group: any) => {
    try {
      // Grubu seÃ§ (context)
      await setSelectedGroup(group);
      console.log('âœ… Grup seÃ§ildi:', group.name);

      // AsyncStorage'Ä± da gÃ¼ncelle
      await setSelectedGroupId(group.id);
      console.log('âœ… AsyncStorage gÃ¼ncellendi:', group.id);

      // Retry counter'Ä± sÄ±fÄ±rla
      retryCountRef.current = 0;

      // Ana sayfaya yÃ¶nlendir
      router.push('/(drawer)/home');
      console.log('âœ… Ana sayfaya yÃ¶nlendirildi');
    } catch (error) {
      console.error('âŒ Grup seÃ§me hatasÄ±:', error);
    }
  };

  useEffect(() => {
    // Notification click handler
    const clickHandler = async (event: any) => {
      console.log('ğŸ”” OneSignal notification clicked:', event);

      // additionalData'dan grup bilgisini al
      const additionalData = event.notification.additionalData;
      const groupId = additionalData?.group_id as string | undefined;
      const groupName = additionalData?.group_name as string | undefined;

      if (!groupId) {
        console.warn('âš ï¸ Bildirimde group_id bulunamadÄ±');
        return;
      }

      console.log('âœ… Grup bilgisi alÄ±ndÄ±:', { groupId, groupName });

      const currentGroups = groupsRef.current;

      // Gruplar yÃ¼klÃ¼ deÄŸilse bekle
      if (currentGroups.length === 0) {
        console.warn('âš ï¸ Gruplar henÃ¼z yÃ¼klenmedi, navigasyon kuyruÄŸa alÄ±ndÄ±...');
        pendingGroupIdRef.current = groupId;
        return;
      }

      // Grubu bul
      const group = currentGroups.find(g => g.id === groupId);
      if (!group) {
        console.warn('âš ï¸ Grup bulunamadÄ± (listede yok):', groupId);
        
        // Retry mekanizmasÄ±: GruplarÄ± refresh et
        if (retryCountRef.current < MAX_RETRY && user?.id) {
          retryCountRef.current += 1;
          console.log(`ğŸ”„ GruplarÄ± yenileme denemesi ${retryCountRef.current}/${MAX_RETRY}`);
          
          // GruplarÄ± refresh et
          await queryClient.invalidateQueries({ queryKey: groupKeys.userGroups(user.id) });
          
          // Pending'e ekle, bir sonraki gÃ¼ncelleme geldiÄŸinde denenecek
          pendingGroupIdRef.current = groupId;
          
          // Biraz bekle ve tekrar dene
          setTimeout(() => {
            const refreshedGroups = groupsRef.current;
            const foundGroup = refreshedGroups.find(g => g.id === groupId);
            if (foundGroup) {
              console.log('âœ… Grup refresh sonrasÄ± bulundu:', foundGroup.name);
              handleGroupNavigation(foundGroup);
              pendingGroupIdRef.current = null;
            }
          }, 1000);
          return;
        }
        
        // Max retry'a ulaÅŸÄ±ldÄ±ysa veya user yoksa
        console.error('âŒ Grup bulunamadÄ± ve retry limit aÅŸÄ±ldÄ±:', groupId);
        retryCountRef.current = 0;
        pendingGroupIdRef.current = null;
        return;
      }

      handleGroupNavigation(group);
    };

    // Event listener'Ä± gÃ¼venli ÅŸekilde ekle
    try {
      OneSignal.Notifications.addEventListener('click', clickHandler);
      console.log('âœ… NotificationHandler: Click listener eklendi');
    } catch (error) {
      console.error('âŒ NotificationHandler: Click listener eklenemedi, OneSignal henÃ¼z hazÄ±r deÄŸil:', error);
    }

    // Cleanup
    return () => {
      try {
        OneSignal.Notifications.removeEventListener('click', clickHandler);
      } catch (error) {
        // Ignore cleanup errors
      }
    };
  }, []); // Empty dependency array - handler is stable

  // Bu component gÃ¶rÃ¼nmez (sadece handler)
  return null;
}
</file>

<file path="contexts/PayContext.tsx">
import { FIRST_SUBSCRIPTION_PLACEMENT } from '@/constants/adapty';
import { createContext, useContext, useEffect, useRef, useState } from 'react';
import { Linking } from 'react-native';
import { AdaptyPaywall, AdaptyProfile, adapty } from 'react-native-adapty';
import { createPaywallView } from 'react-native-adapty/dist/ui';

// Global singleton flags - Adapty'nin yalnÄ±zca bir kez activate edilmesini garanti eder
let isAdaptyActivating = false;
let isAdaptyActivated = false;
let activationPromise: Promise<void> | null = null;

const activateAdapty = async (): Promise<void> => {
  // EÄŸer zaten activate edildiyse, hemen dÃ¶n
  if (isAdaptyActivated) {
    return;
  }

  // EÄŸer ÅŸu anda activate ediliyorsa, mevcut promise'i bekle
  if (isAdaptyActivating && activationPromise) {
    return activationPromise;
  }

  isAdaptyActivating = true;

  activationPromise = (async () => {
    const key = process.env.EXPO_PUBLIC_ADAPTY_PUBLIC_SDK_KEY || '';
    if (!key) {
      console.warn('âš ï¸ Adapty key bulunamadÄ±!');
      isAdaptyActivating = false;
      isAdaptyActivated = true;
      throw new Error('Adapty key not found');
    }

    try {
      console.log('ğŸ”µ Adapty activate ediliyor...');
      
      // Timeout ile Adapty activation - 10 saniye iÃ§inde tamamlanmazsa devam et
      const timeoutPromise = new Promise<void>((_, reject) => {
        setTimeout(() => reject(new Error('Adapty activation timeout')), 10000);
      });
      
      const activationPromise = adapty.activate(key, { lockMethodsUntilReady: false });
      
      try {
        await Promise.race([activationPromise, timeoutPromise]);
        console.log('âœ… Adapty baÅŸarÄ±yla activate edildi');
      } catch (timeoutError) {
        console.warn('âš ï¸ Adapty activation timeout, devam ediliyor...');
        // Timeout olsa bile devam et
      }
      
      isAdaptyActivated = true;
      isAdaptyActivating = false;
    } catch (error: any) {
      console.error('âŒ Adapty activation hatasÄ±:', error);
      isAdaptyActivating = false;
      isAdaptyActivated = true; // Hata durumunda da flag'i set et ki tekrar denemesin
      // Hata olsa bile throw etme, app Ã§alÄ±ÅŸmaya devam etsin
    }
  })();

  return activationPromise;
};

// Yeni arayÃ¼zler ve tipler
interface ShowPaywallOptions {
    placementId?: string;
    condition?: () => Promise<boolean>;
    onSuccess?: (purchase: any) => void;
    onFailure?: (error: Error) => void;
    onClose?: () => void;
    onPresent?: (paywall: AdaptyPaywall) => void;
    trackingContext?: Record<string, any>;
}

interface PayContextType {
    isSubscribed: boolean;
    loading: boolean;
    error: Error | null;
    isReady: boolean;
    checkSubscription: () => Promise<void>;
    showPaywall: (options: ShowPaywallOptions) => Promise<void>;
    reStorePurchases: () => Promise<void>;
}

const PayContext = createContext<PayContextType | undefined>(undefined);

const PayProvider = ({ children }: { children: React.ReactNode }) => {
    const [isSubscribed, setIsSubscribed] = useState<boolean>(false);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<Error | null>(null);
    const [isReady, setIsReady] = useState<boolean>(isAdaptyActivated);

    // Paywall view'Ä± iÃ§in ref'i tutuyoruz, sadece bir tane aktif olabilir.
    const paywallViewRef = useRef<any | null>(null);

    // Adapty'yi initialize et
    useEffect(() => {
        let isMounted = true;

        const initialize = async () => {
            try {
                await activateAdapty();
                if (isMounted) {
                    setIsReady(true);
                }
            } catch (err) {
                if (isMounted) {
                    setError(err as Error);
                    setIsReady(true); // Hata durumunda da devam et
                }
            }
        };

        initialize();

        return () => {
            isMounted = false;
        };
    }, []);

    const checkSubscription = async () => {
        if (!isReady) return;
        setLoading(true);
        try {
            const profile: AdaptyProfile = await adapty.getProfile();
            const hasActiveSubscription = Object.values(profile.accessLevels || {}).some(level => level.isActive);
            setIsSubscribed(hasActiveSubscription);
        } catch (err) {
            setError(err instanceof Error ? err : new Error('Unknown error checking subscription'));
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        if (isReady) {
            checkSubscription();
        }
    }, [isReady]);

    const showPaywall = async (options: ShowPaywallOptions) => {
        const {
            placementId = FIRST_SUBSCRIPTION_PLACEMENT,
            condition,
            onSuccess,
            onFailure,
            onClose,
            onPresent,
            trackingContext = {}
        } = options;
        if (condition && !(await condition())) {
            return;
        }
        setLoading(true);
        setError(null);
        try {
            const paywall = await adapty.getPaywall(placementId);
            console.log('Paywall fetched:', JSON.stringify(paywall, null, 2));

            try {
                const products = await adapty.getPaywallProducts(paywall);
                console.log('Paywall products fetched:', JSON.stringify(products, null, 2));
            } catch (productError) {
                console.error('Error fetching paywall products explicitly:', productError);
            }

            const view = await createPaywallView(paywall);
            paywallViewRef.current = view;
            console.log('Paywall view created:', view);
            // 3. Olay dinleyicilerini (event handlers) ayarla
            view.registerEventHandlers({
                onPurchaseCompleted: (purchase: any) => {
                    if (purchase?.profile?.accessLevels?.['premium']?.isActive) {
                        setIsSubscribed(true);
                        onSuccess?.(purchase);
                    } else {
                        // SatÄ±n alma baÅŸarÄ±lÄ± ama yetki gelmedi durumu
                        onFailure?.(new Error('Purchase succeeded but no access level was granted.'));
                    }
                    view.dismiss();
                },
                onPurchaseFailed: (err) => {
                    setError(err);
                    onFailure?.(err);
                    view.dismiss();
                },
                onPaywallClosed: () => {
                    onClose?.();
                },
                onUrlPress: (url) => {
                    Linking.openURL(url);
                    return false; // Paywall'u aÃ§Ä±k tut
                }
            });

            // 4. Paywall'u gÃ¶ster
            await view.present();
            setLoading(false);
            onPresent?.(paywall);

        } catch (err: any) {
            console.error('err paywall4', err);
            setError(err);
            setLoading(false);
            onFailure?.(err);
        }
    };

    const reStorePurchases = async (): Promise<void> => {
        setLoading(true);
        try {
            await adapty.restorePurchases();
            await checkSubscription();
        } catch (err) {
            setError(err instanceof Error ? err : new Error('Unknown error during restore'));
        } finally {
            setLoading(false);
        }
    };

    const value = {
        isSubscribed,
        loading,
        error,
        isReady,
        checkSubscription,
        showPaywall,
        reStorePurchases
    };

    return <PayContext.Provider value={value}>{children}</PayContext.Provider>;
};

const usePay = () => {
    const context = useContext(PayContext);
    if (context === undefined) {
        throw new Error('usePay must be used within a PayProvider');
    }
    return context;
};

export { usePay };
export default PayProvider;
</file>

<file path="README.md">
# Welcome to your Expo app ğŸ‘‹

This is an [Expo](https://expo.dev) project created with [`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
   npx expo start
   ```

In the output, you'll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## Learn more

To learn more about developing your project with Expo, look at the following resources:

- [Expo documentation](https://docs.expo.dev/): Learn fundamentals, or go into advanced topics with our [guides](https://docs.expo.dev/guides).
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/): Follow a step-by-step tutorial where you'll create a project that runs on Android, iOS, and the web.

## Join the community

Join our community of developers creating universal apps.

- [Expo on GitHub](https://github.com/expo/expo): View our open source platform and contribute.
- [Discord community](https://chat.expo.dev): Chat with Expo users and ask questions.
# geliom
# geliom
</file>

<file path="api/groups.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import type {
  CreateGroup,
  CreateGroupJoinRequest,
  CreateGroupMember,
  Group,
  GroupJoinRequest,
  GroupJoinRequestWithDetails,
  GroupMember,
  GroupMemberWithUser,
  GroupWithOwner,
  UpdateGroup
} from '../types/database';
import { supabase } from './supabase';

// Query Keys
export const groupKeys = {
  all: ['groups'] as const,
  lists: () => [...groupKeys.all, 'list'] as const,
  list: (filters: string) => [...groupKeys.lists(), { filters }] as const,
  details: () => [...groupKeys.all, 'detail'] as const,
  detail: (id: string) => [...groupKeys.details(), id] as const,
  members: (groupId: string) => [...groupKeys.detail(groupId), 'members'] as const,
  userGroups: (userId: string) => [...groupKeys.all, 'user', userId] as const,
  joinRequests: (groupId: string) => [...groupKeys.detail(groupId), 'join-requests'] as const,
  myJoinRequests: (userId: string) => [...groupKeys.all, 'join-requests', 'user', userId] as const,
};

// Group Queries
export const useGroups = () => {
  return useQuery({
    queryKey: groupKeys.lists(),
    queryFn: async (): Promise<GroupWithOwner[]> => {
      const { data, error } = await supabase
        .from('groups')
        .select(`
          *,
          owner:users!groups_owner_id_fkey(*)
        `)
        .order('created_at', { ascending: false });
      
      if (error) throw error;
      return data || [];
    },
  });
};

export const useGroup = (id: string) => {
  return useQuery({
    queryKey: groupKeys.detail(id),
    queryFn: async (): Promise<GroupWithOwner | null> => {
      const { data, error } = await supabase
        .from('groups')
        .select(`
          *,
          owner:users!groups_owner_id_fkey(*)
        `)
        .eq('id', id)
        .single();
      
      if (error) throw error;
      return data;
    },
    enabled: !!id,
  });
};

export const useGroupByInviteCode = (inviteCode: string) => {
  return useQuery({
    queryKey: [...groupKeys.lists(), { inviteCode }],
    queryFn: async (): Promise<GroupWithOwner | null> => {
      const { data, error } = await supabase
        .from('groups')
        .select(`
          *,
          owner:users!groups_owner_id_fkey(*)
        `)
        .eq('invite_code', inviteCode)
        .single();
      
      if (error) throw error;
      return data;
    },
    enabled: !!inviteCode,
  });
};

export const useUserGroups = (userId: string) => {
  return useQuery({
    queryKey: groupKeys.userGroups(userId),
    queryFn: async (): Promise<GroupWithOwner[]> => {
      if (!userId) {
        return [];
      }
      
      // Ã–nce kullanÄ±cÄ±nÄ±n gruplarÄ±nÄ± al
      const { data: memberData, error: memberError } = await supabase
        .from('group_members')
        .select(`
          group_id,
          group:groups(
            *,
            owner:users!groups_owner_id_fkey(*)
          )
        `)
        .eq('user_id', userId);
      
      if (memberError) {
        console.error('Error fetching user groups:', memberError);
        throw memberError;
      }
      
      if (!memberData || memberData.length === 0) {
        return [];
      }

      // Her grup iÃ§in Ã¼ye sayÄ±sÄ±nÄ± al
      const groupIds = memberData.map(item => item.group_id).filter(Boolean) as string[];
      
      if (groupIds.length === 0) {
        return [];
      }
      
      const { data: countData, error: countError } = await supabase
        .from('group_members')
        .select('group_id')
        .in('group_id', groupIds);
      
      if (countError) {
        console.error('Error fetching group member counts:', countError);
        throw countError;
      }

      // Ãœye sayÄ±larÄ±nÄ± hesapla
      const memberCounts: Record<string, number> = {};
      countData?.forEach(item => {
        if (item.group_id) {
          memberCounts[item.group_id] = (memberCounts[item.group_id] || 0) + 1;
        }
      });

      // GruplarÄ± Ã¼ye sayÄ±larÄ± ile birleÅŸtir
      const groups = memberData
        .map(item => {
          const group = item.group;
          if (!group) return null;
          return {
            ...group,
            member_count: memberCounts[item.group_id] || 0,
          };
        })
        .filter(Boolean) as unknown as GroupWithOwner[];
      
      return groups;
    },
    enabled: !!userId,
    staleTime: 5 * 60 * 1000, // 5 dakika - cache'teki veri 5 dk boyunca fresh sayÄ±lÄ±r, tekrar fetch etmez
    structuralSharing: false, // Her zaman yeni array referansÄ± - context gÃ¼ncellemeleri iÃ§in gerekli
  });
};

// Group Member Queries
export const useGroupMembers = (groupId: string) => {
  return useQuery({
    queryKey: groupKeys.members(groupId),
    queryFn: async (): Promise<GroupMemberWithUser[]> => {
      const { data, error } = await supabase
        .from('group_members')
        .select(`
          *,
          user:users(*)
        `)
        .eq('group_id', groupId)
        .order('joined_at');
      
      if (error) throw error;
      return data || [];
    },
    enabled: !!groupId,
  });
};

export const useIsGroupMember = (groupId: string, userId: string) => {
  return useQuery({
    queryKey: [...groupKeys.members(groupId), 'check', userId],
    queryFn: async (): Promise<boolean> => {
      const { data, error } = await supabase
        .from('group_members')
        .select('user_id')
        .eq('group_id', groupId)
        .eq('user_id', userId)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      return !!data;
    },
    enabled: !!(groupId && userId),
  });
};

// Group Mutations
export const useCreateGroup = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (groupData: CreateGroup): Promise<Group> => {
      const { data, error } = await supabase
        .from('groups')
        .insert(groupData)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: groupKeys.all });
    },
  });
};

export const useUpdateGroup = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ id, updates }: { id: string; updates: UpdateGroup }): Promise<Group> => {
      const { data, error } = await supabase
        .from('groups')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: groupKeys.all });
      queryClient.invalidateQueries({ queryKey: groupKeys.detail(data.id) });
      queryClient.invalidateQueries({ queryKey: groupKeys.members(data.id) });
    },
  });
};

// Transfer group ownership (sadece mevcut owner yapabilir)
export const useTransferGroupOwnership = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ groupId, newOwnerId }: { groupId: string; newOwnerId: string }): Promise<Group> => {
      const { data, error } = await supabase
        .from('groups')
        .update({ owner_id: newOwnerId })
        .eq('id', groupId)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: groupKeys.all });
      queryClient.invalidateQueries({ queryKey: groupKeys.detail(data.id) });
      queryClient.invalidateQueries({ queryKey: groupKeys.members(data.id) });
    },
  });
};

export const useDeleteGroup = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (id: string): Promise<void> => {
      const { error } = await supabase
        .from('groups')
        .delete()
        .eq('id', id);
      
      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: groupKeys.all });
    },
  });
};

// Group Member Mutations
export const useJoinGroup = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (memberData: CreateGroupMember): Promise<GroupMember> => {
      const { data, error } = await supabase
        .from('group_members')
        .insert(memberData)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: groupKeys.all });
      queryClient.invalidateQueries({ queryKey: groupKeys.members(data.group_id) });
      queryClient.invalidateQueries({ queryKey: groupKeys.userGroups(data.user_id) });
    },
  });
};

export const useLeaveGroup = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async ({ groupId, userId }: { groupId: string; userId: string }): Promise<void> => {
      // Ã–nce grup Ã¼yeliÄŸini sil
      const { error: memberError } = await supabase
        .from('group_members')
        .delete()
        .eq('group_id', groupId)
        .eq('user_id', userId);
      
      if (memberError) throw memberError;

      // KullanÄ±cÄ± gruptan atÄ±ldÄ±ÄŸÄ±nda, group_join_requests'teki approved/rejected kayÄ±tlarÄ±nÄ± sil
      // Bu sayede kullanÄ±cÄ± tekrar istek atabilir
      const { error: joinRequestError } = await supabase
        .from('group_join_requests')
        .delete()
        .eq('group_id', groupId)
        .eq('requester_id', userId)
        .in('status', ['approved', 'rejected']);

      if (joinRequestError) {
        console.error('Join request temizleme hatasÄ± (non-blocking):', joinRequestError);
        // Hata olsa bile devam et (non-blocking)
      } else {
        console.log('âœ… Join request kayÄ±tlarÄ± temizlendi:', { groupId, userId });
      }
    },
    onSuccess: (_, { groupId, userId }) => {
      queryClient.invalidateQueries({ queryKey: groupKeys.all });
      queryClient.invalidateQueries({ queryKey: groupKeys.members(groupId) });
      queryClient.invalidateQueries({ queryKey: groupKeys.userGroups(userId) });
      queryClient.invalidateQueries({ queryKey: groupKeys.joinRequests(groupId) });
      queryClient.invalidateQueries({ queryKey: groupKeys.myJoinRequests(userId) });
    },
  });
};

// Realtime Subscription Hooks
export const useGroupsRealtime = () => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['groups-realtime'],
    queryFn: () => {
      const channel = supabase
        .channel('groups-changes')
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'groups',
          },
          () => {
            queryClient.invalidateQueries({ queryKey: groupKeys.all });
          }
        )
        .subscribe();

      return channel;
    },
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};

export const useGroupMembersRealtime = (groupId: string) => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['group-members-realtime', groupId],
    queryFn: () => {
      const channel = supabase
        .channel(`group-members-changes-${groupId}`)
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'group_members',
            filter: `group_id=eq.${groupId}`,
          },
          () => {
            queryClient.invalidateQueries({ queryKey: groupKeys.members(groupId) });
          }
        )
        .subscribe();

      return channel;
    },
    enabled: !!groupId,
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};

// Group Join Request Queries
export const useGroupJoinRequests = (groupId: string, status?: 'pending' | 'approved' | 'rejected') => {
  return useQuery({
    queryKey: [...groupKeys.joinRequests(groupId), status],
    queryFn: async (): Promise<GroupJoinRequestWithDetails[]> => {
      let query = supabase
        .from('group_join_requests')
        .select(`
          *,
          group:groups(
            *,
            owner:users!groups_owner_id_fkey(*)
          ),
          requester:users!group_join_requests_requester_id_fkey(*)
        `)
        .eq('group_id', groupId)
        .order('created_at', { ascending: false });

      if (status) {
        query = query.eq('status', status);
      }

      const { data, error } = await query;

      if (error) throw error;
      return data || [];
    },
    enabled: !!groupId,
  });
};

export const useMyJoinRequests = (userId: string) => {
  return useQuery({
    queryKey: groupKeys.myJoinRequests(userId),
    queryFn: async (): Promise<GroupJoinRequestWithDetails[]> => {
      const { data, error } = await supabase
        .from('group_join_requests')
        .select(`
          *,
          group:groups(
            *,
            owner:users!groups_owner_id_fkey(*)
          ),
          requester:users!group_join_requests_requester_id_fkey(*)
        `)
        .eq('requester_id', userId)
        .order('created_at', { ascending: false });

      if (error) throw error;
      return data || [];
    },
    enabled: !!userId,
  });
};

// Realtime Subscription Hooks for Join Requests
export const useGroupJoinRequestsRealtime = (groupId: string) => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['group-join-requests-realtime', groupId],
    queryFn: () => {
      const channel = supabase
        .channel(`group-join-requests-changes-${groupId}`)
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'group_join_requests',
            filter: `group_id=eq.${groupId}`,
          },
          () => {
            // TÃ¼m status'ler iÃ§in query'leri invalidate et
            queryClient.invalidateQueries({ queryKey: groupKeys.joinRequests(groupId) });
            queryClient.invalidateQueries({ queryKey: [...groupKeys.joinRequests(groupId), 'pending'] });
            queryClient.invalidateQueries({ queryKey: [...groupKeys.joinRequests(groupId), 'approved'] });
            queryClient.invalidateQueries({ queryKey: [...groupKeys.joinRequests(groupId), 'rejected'] });
          }
        )
        .subscribe();

      return channel;
    },
    enabled: !!groupId,
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};

export const useMyJoinRequestsRealtime = (userId: string) => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['my-join-requests-realtime', userId],
    queryFn: () => {
      const channel = supabase
        .channel(`my-join-requests-changes-${userId}`)
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'group_join_requests',
            filter: `requester_id=eq.${userId}`,
          },
          () => {
            queryClient.invalidateQueries({ queryKey: groupKeys.myJoinRequests(userId) });
          }
        )
        .subscribe();

      return channel;
    },
    enabled: !!userId,
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};

// Group Join Request Mutations
export const useCreateJoinRequest = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (request: CreateGroupJoinRequest & { invite_code: string }): Promise<GroupJoinRequest> => {
      // RPC fonksiyonunu Ã§aÄŸÄ±r
      const { data, error } = await supabase.rpc('create_join_request', {
        p_group_id: request.group_id,
        p_requester_id: request.requester_id,
        p_invite_code: request.invite_code,
      });

      if (error) throw error;

      if (!data.success) {
        throw new Error(data.error || 'Bilinmeyen bir hata oluÅŸtu');
      }

      // BaÅŸarÄ±lÄ± iÅŸlem sonucunda dÃ¶nen veriyi formatla
      // RPC'den dÃ¶nen data.data iÃ§inde id, group_id, requester_id, status var
      // Ancak tam GroupJoinRequest objesi iÃ§in created_at vb. eksik olabilir
      // Bu yÃ¼zden basitÃ§e dÃ¶nen veriyi kullanÄ±yoruz veya tekrar fetch edebiliriz
      // Performans iÃ§in dÃ¶nen veriyi kullanÄ±p eksikleri client'ta tamamlayabiliriz
      return {
        ...data.data,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      } as GroupJoinRequest;
    },
    onSuccess: async (data) => {
      // Ä°lgili query'leri invalidate et
      queryClient.invalidateQueries({ queryKey: groupKeys.joinRequests(data.group_id) });
      queryClient.invalidateQueries({ queryKey: groupKeys.myJoinRequests(data.requester_id) });

      // Bildirim gÃ¶nder (async, hata olsa bile devam et)
      try {
        // Grup bilgilerini ve sahibini al
        const { data: groupData } = await supabase
          .from('groups')
          .select(`
            name,
            owner_id,
            owner:users!groups_owner_id_fkey(
              id,
              onesignal_player_id
            )
          `)
          .eq('id', data.group_id)
          .single();

        // Ä°stek yapan kullanÄ±cÄ±nÄ±n bilgilerini al
        const { data: requesterData } = await supabase
          .from('users')
          .select('display_name, custom_user_id')
          .eq('id', data.requester_id)
          .single();

        if (groupData?.owner_id && groupData?.name && requesterData) {
          const { sendJoinRequestNotification } = await import('./notifications');
          await sendJoinRequestNotification(
            groupData.owner_id, // Supabase user ID (external_id olarak kullanÄ±lacak)
            data.group_id,
            groupData.name,
            requesterData.display_name || requesterData.custom_user_id,
            data.requester_id // Rate limiting iÃ§in
          );
        }
      } catch (error) {
        console.error('Bildirim gÃ¶nderme hatasÄ± (non-blocking):', error);
      }
    },
  });
};

export const useApproveJoinRequest = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ requestId, groupId }: { requestId: string; groupId: string }): Promise<void> => {
      // Ä°steÄŸi onayla
      const { data: request, error: requestError } = await supabase
        .from('group_join_requests')
        .select('requester_id')
        .eq('id', requestId)
        .single();

      if (requestError) throw requestError;
      if (!request) throw new Error('Ä°stek bulunamadÄ±');

      // Gruba Ã¼ye ekle
      const { error: memberError } = await supabase
        .from('group_members')
        .insert({
          group_id: groupId,
          user_id: request.requester_id,
        });

      if (memberError) throw memberError;

      // Ä°stek durumunu gÃ¼ncelle
      const { error: updateError } = await supabase
        .from('group_join_requests')
        .update({ status: 'approved', updated_at: new Date().toISOString() })
        .eq('id', requestId);

      if (updateError) throw updateError;
    },
    onSuccess: async (_, variables) => {
      // Ä°stek bilgilerini al (requester_id iÃ§in)
      const { data: requestData } = await supabase
        .from('group_join_requests')
        .select('requester_id, group_id')
        .eq('id', variables.requestId)
        .single();

      // Ä°lgili query'leri invalidate et
      queryClient.invalidateQueries({ queryKey: groupKeys.joinRequests(variables.groupId) });
      queryClient.invalidateQueries({ queryKey: groupKeys.members(variables.groupId) });
      queryClient.invalidateQueries({ queryKey: groupKeys.userGroups(variables.groupId) });
      
      // Requester'Ä±n gruplarÄ± listesini invalidate et (Ã¶nemli: yeni gruba katÄ±ldÄ±ÄŸÄ± iÃ§in)
      if (requestData?.requester_id) {
        queryClient.invalidateQueries({ queryKey: groupKeys.userGroups(requestData.requester_id) });
      }

      // Bildirim gÃ¶nder (async, hata olsa bile devam et)
      try {
        if (!requestData) return;

        // Grup bilgilerini al (owner_id dahil)
        const { data: groupData } = await supabase
          .from('groups')
          .select('name, owner_id')
          .eq('id', requestData.group_id)
          .single();

        if (groupData?.name && groupData?.owner_id && requestData.requester_id) {
          const { sendJoinRequestStatusNotification } = await import('./notifications');
          await sendJoinRequestStatusNotification(
            requestData.requester_id, // Supabase user ID (external_id olarak kullanÄ±lacak)
            variables.groupId,
            groupData.name,
            'approved',
            groupData.owner_id // Rate limiting iÃ§in
          );
        }
      } catch (error) {
        console.error('Bildirim gÃ¶nderme hatasÄ± (non-blocking):', error);
      }
    },
  });
};

export const useRejectJoinRequest = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ requestId, groupId }: { requestId: string; groupId: string }): Promise<void> => {
      const { error } = await supabase
        .from('group_join_requests')
        .update({ status: 'rejected', updated_at: new Date().toISOString() })
        .eq('id', requestId);

      if (error) throw error;
    },
    onSuccess: async (_, variables) => {
      // Ä°lgili query'leri invalidate et
      queryClient.invalidateQueries({ queryKey: groupKeys.joinRequests(variables.groupId) });
      queryClient.invalidateQueries({ queryKey: groupKeys.myJoinRequests(variables.groupId) });

      // Bildirim gÃ¶nder (async, hata olsa bile devam et)
      try {
        // Ä°stek bilgilerini al
        const { data: requestData } = await supabase
          .from('group_join_requests')
          .select('requester_id, group_id')
          .eq('id', variables.requestId)
          .single();

        if (!requestData) return;

        // Grup bilgilerini al (owner_id dahil)
        const { data: groupData } = await supabase
          .from('groups')
          .select('name, owner_id')
          .eq('id', requestData.group_id)
          .single();

        if (groupData?.name && groupData?.owner_id && requestData.requester_id) {
          const { sendJoinRequestStatusNotification } = await import('./notifications');
          await sendJoinRequestStatusNotification(
            requestData.requester_id, // Supabase user ID (external_id olarak kullanÄ±lacak)
            variables.groupId,
            groupData.name,
            'rejected',
            groupData.owner_id // Rate limiting iÃ§in
          );
        }
      } catch (error) {
        console.error('Bildirim gÃ¶nderme hatasÄ± (non-blocking):', error);
      }
    },
  });
};
</file>

<file path="app/(drawer)/home.tsx">
import { useGroupEventsRealtime } from "@/api/events";
import { useGroupMoodsRealtime } from "@/api/moods";
import { useGroupStatusesRealtime } from "@/api/statuses";
import { DashboardView, EmptyStateView } from "@/components/dashboard";
import { BaseLayout } from "@/components/shared";
import { useGroupContext } from "@/contexts/GroupContext";
import { useTheme } from "@/contexts/ThemeContext";
import React from "react";
import { ActivityIndicator, View } from "react-native";

export default function HomeScreen() {
    const { selectedGroup, isLoading } = useGroupContext();
    const { colors } = useTheme();

    // SeÃ§ili grup iÃ§in realtime subscription'larÄ± baÅŸlat
    // Bu hooklar arka planda Supabase listener'larÄ±nÄ± yÃ¶netir
    // selectedGroup deÄŸiÅŸtiÄŸinde otomatik olarak yeni grubu dinlemeye baÅŸlar
    useGroupStatusesRealtime(selectedGroup?.id || '');
    useGroupMoodsRealtime(selectedGroup?.id || '');
    useGroupEventsRealtime(selectedGroup?.id || '');

    // Loading durumu
    if (isLoading) {
        return (
            <BaseLayout headerShow={false}>
                <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: colors.background }}>
                    <ActivityIndicator size="large" color={colors.primary} />
                </View>
            </BaseLayout>
        );
    }

    return (
        <BaseLayout
            headerShow={false} // Drawer navigation kendi header'Ä±nÄ± kullanÄ±yor (GroupHeader sayesinde)
            backgroundColor={colors.background}
        >
            {selectedGroup ? (
                // Bir grup seÃ§iliyse Dashboard'u gÃ¶ster
                <DashboardView group={selectedGroup} />
            ) : (
                // Grup yoksa veya seÃ§ilmediyse Empty State gÃ¶ster
                <EmptyStateView />
            )}
        </BaseLayout>
    );
}
</file>

<file path="app/Provider.tsx">
import { NotificationHandler } from '@/components/NotificationHandler';
import { AuthProvider } from '@/contexts/AuthContext';
import { BottomSheetProvider } from '@/contexts/BottomSheetContext';
import { GroupProvider } from '@/contexts/GroupContext';
import PayProvider from '@/contexts/PayContext';
import { ThemeProvider } from '@/contexts/ThemeContext';
import { initializeOneSignal, initializeOneSignalSDK } from '@/services/onesignal';
import NetInfo from '@react-native-community/netinfo';
import { onlineManager, QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useFonts } from "expo-font";
import * as SplashScreen from 'expo-splash-screen';
import React, { useEffect } from 'react';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { SafeAreaProvider } from 'react-native-safe-area-context';

// OneSignal SDK'yÄ± synchronous olarak initialize et (modÃ¼l yÃ¼klenirken)
// Bu sayede NotificationHandler render edilmeden Ã¶nce SDK hazÄ±r olur
initializeOneSignalSDK();

// Network durumunu TanStack Query ile senkronize et
onlineManager.setEventListener((setOnline: (online: boolean) => void) => {
  return NetInfo.addEventListener((state) => {
    setOnline(!!state.isConnected)
  })
})

// Splash screen'i manuel olarak gizlememiz gerekiyor
SplashScreen.preventAutoHideAsync();

// TanStack Query client'Ä± oluÅŸtur.
// Bu component dÄ±ÅŸÄ±nda oluÅŸturulur ki her render'da yeniden oluÅŸmasÄ±n.
const queryClient = new QueryClient();

// Merkezi Provider Component'i - Sadece provider'larÄ± wrap eder
export default function Provider({ children }: { children: React.ReactNode }) {
  const [fontsLoaded, error] = useFonts({
    'Comfortaa-Light': require('@/assets/fonts/Comfortaa-Light.ttf'),
    'Comfortaa-Regular': require('@/assets/fonts/Comfortaa-Regular.ttf'),
    'Comfortaa-Medium': require('@/assets/fonts/Comfortaa-Medium.ttf'),
    'Comfortaa-SemiBold': require('@/assets/fonts/Comfortaa-SemiBold.ttf'),
    'Comfortaa-Bold': require('@/assets/fonts/Comfortaa-Bold.ttf'),
  });

  // OneSignal'i initialize et (uygulama baÅŸladÄ±ÄŸÄ±nda bir kez)
  // Not: initializeOneSignal() iÃ§inde singleton var, birden fazla Ã§aÄŸrÄ± gÃ¼venli
  useEffect(() => {
    initializeOneSignal().catch((error) => {
      console.error('âŒ OneSignal initialization hatasÄ±:', error);
    });
  }, []);

  if (!fontsLoaded && !error) {
    return null;
  }

  return (
    <SafeAreaProvider>
      <GestureHandlerRootView style={{ flex: 1 }}>
        <QueryClientProvider client={queryClient}>
          <ThemeProvider>
            <PayProvider>
              <AuthProvider>
                <GroupProvider>
                  <BottomSheetProvider>
                    <NotificationHandler />
                    {children}
                  </BottomSheetProvider>
                </GroupProvider>
              </AuthProvider>
            </PayProvider>
          </ThemeProvider>
        </QueryClientProvider>
      </GestureHandlerRootView>
    </SafeAreaProvider>
  );
}
</file>

<file path="components/shared/GroupListBottomSheet.tsx">
import { getAvatarSource } from '@/utils/avatar';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import React, { useCallback, useState } from 'react';
import { ActivityIndicator, Image, Modal, ScrollView, StyleSheet, TouchableOpacity, View } from 'react-native';
import { useBottomSheet } from '../../contexts/BottomSheetContext';
import { useGroupContext } from '../../contexts/GroupContext';
import { useTheme } from '../../contexts/ThemeContext';
import { BouncyButton } from '../anim/AnimatedComponents';
import Typography from './Typography';

function GroupListBottomSheetComponent() {
  // Context'ten gerÃ§ek verileri al
  const { selectedGroup, setSelectedGroup, groups, isLoading } = useGroupContext();
  const { closeBottomSheet } = useBottomSheet();
  const { colors } = useTheme();
  const router = useRouter();
  const [actionModalVisible, setActionModalVisible] = useState(false);

  const handleGroupSelect = useCallback(async (group: typeof groups[0]) => {
    await setSelectedGroup(group);
    closeBottomSheet();
  }, [setSelectedGroup, closeBottomSheet]);

  const handleCreateGroup = useCallback(() => {
    setActionModalVisible(false);
    closeBottomSheet();
    // Bottom sheet tamamen kapandÄ±ktan sonra navigate et
    setTimeout(() => {
      router.push('/(drawer)/(group)/create-group');
    }, 300);
  }, [closeBottomSheet, router]);

  const handleJoinGroup = useCallback(() => {
    setActionModalVisible(false);
    closeBottomSheet();
    // Bottom sheet tamamen kapandÄ±ktan sonra navigate et
    setTimeout(() => {
      router.push('/(drawer)/(group)/join-group');
    }, 300);
  }, [closeBottomSheet, router]);

  // Gruplar yÃ¼klenirken gÃ¶sterilecek iÃ§erik
  if (isLoading) {
    return (
      <View style={[styles.container, { backgroundColor: colors.background, justifyContent: 'center', alignItems: 'center' }]}>
        <ActivityIndicator size="large" color={colors.primary} />
        <Typography variant="caption" color={colors.secondaryText} style={{ marginTop: 12 }}>
          Gruplar yÃ¼kleniyor...
        </Typography>
      </View>
    );
  }

  return (
    <View style={[styles.container, { backgroundColor: colors.background }]}>
      <View style={styles.header}>
        <Typography variant="h3" color={colors.text} style={styles.headerTitle}>
          GruplarÄ±m
        </Typography>
        <TouchableOpacity
          onPress={() => setActionModalVisible(true)}
          style={[styles.addButton, { backgroundColor: colors.primary }]}
        >
          <Ionicons name="add" size={24} color={colors.white} />
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
        {groups.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Ionicons name="people-outline" size={48} color={colors.secondaryText} />
            <Typography variant="body" color={colors.secondaryText} style={styles.emptyText}>
              HenÃ¼z bir grupta deÄŸilsin.
            </Typography>
          </View>
        ) : (
          <View style={styles.groupsList}>
            {groups.map((group) => {
              const isSelected = selectedGroup?.id === group.id;
              return (
                <BouncyButton
                  key={group.id}
                  onPress={() => handleGroupSelect(group)}
                  style={[
                    styles.groupItem,
                    {
                      backgroundColor: isSelected ? colors.tertiary + '30' : colors.cardBackground,
                      borderColor: isSelected ? colors.primary : colors.stroke,
                    },
                  ]}
                >
                  <View style={styles.groupItemContent}>
                    {group.owner ? (
                      <View style={styles.avatarContainer}>
                        <Image
                          source={getAvatarSource(group.owner.avatar)}
                          style={styles.avatarImage}
                          resizeMode="cover"
                        />
                      </View>
                    ) : (
                      <View style={[
                        styles.iconBadge, 
                        { 
                          backgroundColor: isSelected ? colors.primary : colors.cardBackground, 
                          borderColor: colors.stroke, 
                          borderWidth: isSelected ? 0 : 1 
                        }
                      ]}>
                        <Ionicons 
                          name={group.type === 'family' ? 'home' : group.type === 'work' ? 'briefcase' : 'people'} 
                          size={20} 
                          color={isSelected ? 'white' : colors.secondaryText} 
                        />
                      </View>
                    )}
                    <View style={styles.groupInfo}>
                      <Typography variant="h5" color={colors.text} style={styles.groupName} numberOfLines={1}>
                        {group.name}
                      </Typography>
                      <Typography variant="caption" color={colors.secondaryText} style={styles.groupType}>
                         {(group as any).member_count ? `${(group as any).member_count} Ãœye` : 'Grup'} â€¢ {
                           group.type === 'family' ? 'Aile' : 
                           group.type === 'friends' ? 'ArkadaÅŸlar' : 
                           group.type === 'work' ? 'Ä°ÅŸ' : 
                           'DiÄŸer'
                         }
                      </Typography>
                    </View>
                    {isSelected && <Ionicons name="checkmark-circle" size={24} color={colors.primary} />}
                  </View>
                </BouncyButton>
              );
            })}
          </View>
        )}
        
        <View style={{ height: 40 }} />
      </ScrollView>

      {/* Action Modal */}
      <Modal
        visible={actionModalVisible}
        transparent
        animationType="fade"
        onRequestClose={() => setActionModalVisible(false)}
      >
        <TouchableOpacity
          style={styles.modalOverlay}
          activeOpacity={1}
          onPress={() => setActionModalVisible(false)}
        >
          <View style={[styles.modalContent, { backgroundColor: colors.cardBackground }]}>
            <TouchableOpacity
              style={[styles.modalOption, { borderBottomColor: colors.stroke }]}
              onPress={handleCreateGroup}
            >
              <Ionicons name="add-circle" size={24} color={colors.primary} />
              <Typography variant="h5" color={colors.text} style={{ marginLeft: 12 }}>
                Yeni Grup OluÅŸtur
              </Typography>
            </TouchableOpacity>
            
            <TouchableOpacity
              style={styles.modalOption}
              onPress={handleJoinGroup}
            >
              <Ionicons name="person-add" size={24} color={colors.secondary} />
              <Typography variant="h5" color={colors.text} style={{ marginLeft: 12 }}>
                Gruba KatÄ±l
              </Typography>
            </TouchableOpacity>
          </View>
        </TouchableOpacity>
      </Modal>
    </View>
  );
}

// React.memo kaldÄ±rÄ±ldÄ± - her aÃ§Ä±lÄ±ÅŸta yeni key ile render ediliyor
// Bu sayede context gÃ¼ncellemeleri her zaman yansÄ±r
export default GroupListBottomSheetComponent;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingTop: 10,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 24,
    paddingBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0,0,0,0.05)',
  },
  headerTitle: {
    fontWeight: 'bold',
  },
  addButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scrollView: {
    flex: 1,
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 40,
    paddingHorizontal: 24,
  },
  emptyText: {
    marginTop: 16,
    textAlign: 'center',
  },
  groupsList: {
    padding: 16,
    gap: 12,
  },
  groupItem: {
    borderRadius: 20,
    borderWidth: 1.5,
    padding: 16,
  },
  groupItemContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  iconBadge: {
      width: 44,
      height: 44,
      borderRadius: 22,
      justifyContent: 'center',
      alignItems: 'center',
      marginRight: 16,
  },
  avatarContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    marginRight: 16,
    overflow: 'hidden',
  },
  avatarImage: {
    width: 44,
    height: 44,
    borderRadius: 22,
  },
  groupInfo: {
    flex: 1,
    marginRight: 12,
  },
  groupName: {
    marginBottom: 2,
    fontWeight: '600',
  },
  groupType: {
    textTransform: 'capitalize',
    opacity: 0.8,
  },
  bottomButtons: {
    paddingHorizontal: 16,
    paddingTop: 16,
    gap: 12,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 16,
    paddingHorizontal: 24,
    borderRadius: 20,
    gap: 8,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  actionButtonText: {
    fontWeight: 'bold',
    fontSize: 16,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '80%',
    maxWidth: 300,
    borderRadius: 20,
    overflow: 'hidden',
  },
  modalOption: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 20,
    borderBottomWidth: 1,
  },
});
</file>

<file path="contexts/AuthContext.tsx">
import { createOrUpdateUserProfile, getProviderFromUser, normalizeUserData } from '@/api/provider-auth';
import { supabase } from '@/api/supabase';
import { useCurrentUser, useUpdateUser, userKeys } from '@/api/users';
import { getOneSignalPlayerId, loginOneSignal, logoutOneSignal } from '@/services/onesignal';
import type { User as DatabaseUser } from '@/types/database';
import { Session } from '@supabase/supabase-js';
import { useQueryClient } from '@tanstack/react-query';
import React, { createContext, useCallback, useContext, useEffect, useState } from 'react';

// Auth Context'i oluÅŸtur.
// Bu context, sadece oturum bilgilerini ve kullanÄ±cÄ± profilini tutacak.
// Geri kalan tÃ¼m verileri (gruplar, durumlar vb.) TanStack Query yÃ¶netecek.
const AuthContext = createContext({
  session: null as Session | null,
  user: null as DatabaseUser | null,
  isLoading: true,
  initializeAuth: async () => {},
  signOut: async () => {},
});

// Auth Provider Component'i
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [session, setSession] = useState<Session | null>(null);
  const [user, setUser] = useState<DatabaseUser | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Mevcut kullanÄ±cÄ± profilini fetch et
  const { 
    data: currentUserProfile, 
    refetch: refetchUserProfile, 
    error: currentUserError,
    isLoading: currentUserLoading,
    isError: currentUserIsError
  } = useCurrentUser();
  const queryClient = useQueryClient();
  const updateUser = useUpdateUser();

  // Ã‡Ä±kÄ±ÅŸ yapma fonksiyonu
  const signOut = useCallback(async () => {
    try {
      console.log('ğŸ”µ SignOut baÅŸlatÄ±lÄ±yor...');
      setIsLoading(true);
      
      const { error } = await supabase.auth.signOut();
      
      if (error) {
        console.error('âŒ Sign out error:', error);
        throw error;
      }
      
      console.log('âœ… SignOut baÅŸarÄ±lÄ±, state temizleniyor...');
      // onAuthStateChange listener otomatik olarak SIGNED_OUT event'ini tetikleyecek
      // Orada state temizlenecek, burada sadece log'layalÄ±m
    } catch (error) {
      console.error('âŒ Unexpected sign out error:', error);
      // Hata olsa bile state'i temizle
      setSession(null);
      setUser(null);
      setIsLoading(false);
      throw error;
    }
  }, []);

  // Auth initialization fonksiyonu
  const initializeAuth = useCallback(async () => {
    try {
      setIsLoading(true);
      
      // Mevcut session'Ä± kontrol et
      const { data: { session: currentSession } } = await supabase.auth.getSession();
      
      if (currentSession) {
        setSession(currentSession);
        // User profile'Ä± fetch et
        await refetchUserProfile();
        
        // Session varsa OneSignal login yap (app aÃ§Ä±ldÄ±ÄŸÄ±nda kullanÄ±cÄ± zaten login ise)
        const supabaseUser = currentSession.user;
        if (supabaseUser?.id) {
          console.log('ğŸ”µ App aÃ§Ä±ldÄ±ÄŸÄ±nda session var, OneSignal login yapÄ±lÄ±yor...');
          loginOneSignal(supabaseUser.id)
            .then(async () => {
              console.log('âœ… OneSignal login baÅŸarÄ±lÄ± (initializeAuth), Player ID kaydediliyor...');
              
              // Login baÅŸarÄ±lÄ± olduktan sonra Player ID'yi al ve kaydet
              // Biraz bekle, SDK'nÄ±n internal state'ini gÃ¼ncellemesi iÃ§in
              await new Promise(resolve => setTimeout(resolve, 500));
              
              const playerId = await getOneSignalPlayerId();
              if (playerId && supabaseUser.id) {
                try {
                  await updateUser.mutateAsync({
                    id: supabaseUser.id,
                    updates: { onesignal_player_id: playerId },
                  });
                  console.log('âœ… OneSignal Player ID kaydedildi (initializeAuth):', playerId);
                } catch (error: any) {
                  // KullanÄ±cÄ± bulunamadÄ±ysa (DB'den silinmiÅŸse), logout yap
                  if (error?.code === 'USER_NOT_FOUND' || error?.code === 'PGRST116') {
                    console.warn('âš ï¸ KullanÄ±cÄ± DB\'de bulunamadÄ±, logout yapÄ±lÄ±yor...');
                    await signOut();
                  } else {
                    console.error('âŒ OneSignal Player ID kaydetme hatasÄ± (initializeAuth):', error);
                    // Player ID kaydetme hatasÄ± kritik deÄŸil, devam et
                  }
                }
              } else {
                console.warn('âš ï¸ OneSignal Player ID alÄ±namadÄ±, kaydedilemedi (initializeAuth). Subscription henÃ¼z oluÅŸmamÄ±ÅŸ olabilir.');
                // Player ID yoksa, subscription oluÅŸunca otomatik olarak kaydedilecek
              }
            })
            .catch((error) => {
              console.error('âŒ OneSignal login hatasÄ± (initializeAuth, non-blocking):', error);
              // OneSignal login hatasÄ± kritik deÄŸil, uygulama Ã§alÄ±ÅŸmaya devam eder
              console.warn('âš ï¸ OneSignal login baÅŸarÄ±sÄ±z oldu (initializeAuth). KullanÄ±cÄ± bildirimleri alamayabilir. Hata:', error.message || error);
            });
        }
      } else {
        setSession(null);
        setUser(null);
      }
    } catch (error) {
      console.error('Auth initialization error:', error);
      setSession(null);
      setUser(null);
    } finally {
      setIsLoading(false);
    }
  }, [refetchUserProfile, updateUser, signOut]);

  // Auth state change listener - sadece session state'ini yÃ¶netir
  useEffect(() => {
    // Ä°lk session kontrolÃ¼
    initializeAuth();

    // Auth state deÄŸiÅŸikliklerini dinle
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange(async (event, currentSession) => {
      console.log('ğŸ”µ Auth state changed:', event, currentSession?.user?.email);

      setSession(currentSession);

      if (currentSession?.user) {
        console.log('âœ… Auth state: User var, profil gÃ¼ncelleniyor...');
        const supabaseUser = currentSession.user;
        const provider = getProviderFromUser(supabaseUser);
        const normalizedData = normalizeUserData(supabaseUser, provider);

        // Profil bilgilerini gÃ¼ncelle (useCurrentUser hook'u profile'Ä± fetch edecek)
        createOrUpdateUserProfile(normalizedData).then((result) => {
          // KullanÄ±cÄ± bulunamadÄ±ysa (DB'den silinmiÅŸse), logout yap
          const errorCode = (result.error as any)?.code;
          if (result.error && errorCode === 'USER_NOT_FOUND') {
            console.warn('âš ï¸ KullanÄ±cÄ± DB\'de bulunamadÄ±, logout yapÄ±lÄ±yor...');
            signOut().catch((error) => {
              console.error('âŒ Logout hatasÄ±:', error);
            });
          }
        }).catch((error) => {
          console.error('âŒ Profile update error (non-blocking):', error);
        });

        // OneSignal'e kullanÄ±cÄ±yÄ± login et (external ID olarak Supabase auth ID)
        // Bu, OneSignal Dashboard'da kullanÄ±cÄ±yÄ± external ID ile bulmamÄ±zÄ± saÄŸlar
        // loginOneSignal iÃ§inde zaten Player ID hazÄ±r olana kadar bekliyor ve retry mekanizmasÄ± var
        loginOneSignal(supabaseUser.id)
          .then(async () => {
            console.log('âœ… OneSignal login baÅŸarÄ±lÄ±, Player ID kaydediliyor...');
            
            // Login baÅŸarÄ±lÄ± olduktan sonra Player ID'yi al ve kaydet
            // Biraz bekle, SDK'nÄ±n internal state'ini gÃ¼ncellemesi iÃ§in
            await new Promise(resolve => setTimeout(resolve, 500));
            
            const playerId = await getOneSignalPlayerId();
            if (playerId && supabaseUser.id) {
              try {
                await updateUser.mutateAsync({
                  id: supabaseUser.id,
                  updates: { onesignal_player_id: playerId },
                });
                console.log('âœ… OneSignal Player ID kaydedildi:', playerId);
              } catch (error: any) {
                // KullanÄ±cÄ± bulunamadÄ±ysa (DB'den silinmiÅŸse), logout yap
                if (error?.code === 'USER_NOT_FOUND' || error?.code === 'PGRST116') {
                  console.warn('âš ï¸ KullanÄ±cÄ± DB\'de bulunamadÄ±, logout yapÄ±lÄ±yor...');
                  await signOut();
                } else {
                  console.error('âŒ OneSignal Player ID kaydetme hatasÄ±:', error);
                  // Player ID kaydetme hatasÄ± kritik deÄŸil, devam et
                }
              }
            } else {
              console.warn('âš ï¸ OneSignal Player ID alÄ±namadÄ±, kaydedilemedi. Subscription henÃ¼z oluÅŸmamÄ±ÅŸ olabilir.');
              // Player ID yoksa, subscription oluÅŸunca otomatik olarak kaydedilecek
            }
          })
          .catch((error) => {
            console.error('âŒ OneSignal login hatasÄ± (non-blocking):', error);
            // OneSignal login hatasÄ± kritik deÄŸil, uygulama Ã§alÄ±ÅŸmaya devam eder
            // Ama kullanÄ±cÄ± bildirimleri alamayabilir
            console.warn('âš ï¸ OneSignal login baÅŸarÄ±sÄ±z oldu. KullanÄ±cÄ± bildirimleri alamayabilir. Hata:', error.message || error);
          });

        // Session deÄŸiÅŸtiÄŸinde query'yi invalidate et (useCurrentUser hook'u refetch yapacak)
        queryClient.invalidateQueries({ queryKey: userKeys.current() });
      } else {
        // SIGNED_OUT veya TOKEN_REFRESHED (session null) event'i
        console.log('ğŸ”µ Auth state: Session yok, cache temizleniyor...');
        setUser(null);
        
        // OneSignal'den logout et
        logoutOneSignal();
        
        // User ile ilgili tÃ¼m query'leri temizle
        queryClient.removeQueries({ queryKey: userKeys.all });
        console.log('âœ… User query cache temizlendi');
      }
    });

    return () => {
      subscription.unsubscribe();
    };
  }, [queryClient]);

  // Current user profile deÄŸiÅŸtiÄŸinde state'i gÃ¼ncelle
  useEffect(() => {
    if (currentUserProfile) {
      console.log('âœ… AuthContext: User profile set edildi:', currentUserProfile.id);
      setUser(currentUserProfile);
    } else {
      setUser(null);
    }
  }, [currentUserProfile]);

  // KullanÄ±cÄ± bulunamadÄ±ÄŸÄ±nda (DB'den silinmiÅŸse) logout yap
  useEffect(() => {
    const errorCode = (currentUserError as any)?.code;
    if (currentUserError && errorCode === 'USER_NOT_FOUND' && session) {
      console.warn('âš ï¸ KullanÄ±cÄ± DB\'de bulunamadÄ± (useCurrentUser), logout yapÄ±lÄ±yor...');
      signOut().catch((error) => {
        console.error('âŒ Logout hatasÄ±:', error);
      });
    }
  }, [currentUserError, session, signOut]);

  // Loading state logic
  useEffect(() => {
    if (!session) {
      // Session yoksa loading false
      setIsLoading(false);
    } else if (session && currentUserProfile) {
      // Session var ve profile geldiyse loading false
      setIsLoading(false);
    } else if (session && !currentUserProfile) {
      // Session var ama profile henÃ¼z yok
      // EÄŸer query hala loading ise â†’ loading true
      // EÄŸer query tamamlandÄ±ysa (isLoading false) â†’ loading false
      // Ama eÄŸer error varsa ve USER_NOT_FOUND ise â†’ logout yapÄ±lacak (yukarÄ±daki useEffect'te)
      setIsLoading(currentUserLoading);
      
      // EÄŸer query tamamlandÄ± ama profile hala null ise ve error yoksa
      // Bu durumda database trigger henÃ¼z Ã§alÄ±ÅŸmamÄ±ÅŸ olabilir, biraz bekle
      if (!currentUserLoading && !currentUserError && !currentUserProfile) {
        console.log('â³ Session var ama profile henÃ¼z yok, database trigger bekleniyor...');
        // Bu durumda loading false yap (Ã§Ã¼nkÃ¼ query tamamlandÄ±)
        // Ama kullanÄ±cÄ± gÃ¶sterilemez, bu normal (database trigger Ã§alÄ±ÅŸana kadar)
      }
    }
  }, [session, currentUserProfile, currentUserLoading, currentUserError]);

  const value = React.useMemo(() => ({
    session,
    user,
    isLoading,
    initializeAuth,
    signOut
  }), [session, user, isLoading, initializeAuth, signOut]);

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

// Context'i kolayca kullanmak iÃ§in custom hook.
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
</file>

<file path="contexts/GroupContext.tsx">
import { useUserGroups } from '@/api/groups';
import { useAuth } from '@/contexts/AuthContext';
import type { GroupWithOwner } from '@/types/database';
import AsyncStorage from '@react-native-async-storage/async-storage';
import React, { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react';

export const SELECTED_GROUP_STORAGE_KEY = '@geliom:selected_group_id';

interface GroupContextValue {
  selectedGroup: GroupWithOwner | null;
  setSelectedGroup: (group: GroupWithOwner | null) => Promise<void>;
  isLoading: boolean;
  groups: GroupWithOwner[];
}

const GroupContext = createContext<GroupContextValue>({
  selectedGroup: null,
  setSelectedGroup: async () => {},
  isLoading: true,
  groups: [],
});

export function GroupProvider({ children }: { children: React.ReactNode }) {
  const { user } = useAuth();
  const [selectedGroup, setSelectedGroupState] = useState<GroupWithOwner | null>(null);

  // KullanÄ±cÄ±nÄ±n tÃ¼m gruplarÄ±nÄ± fetch et
  const { data: groups = [], isLoading: groupsLoading, error: groupsError } = useUserGroups(user?.id || '');

  // AsyncStorage'dan seÃ§ili grup ID'sini yÃ¼kle (sadece bir kez, gruplar yÃ¼klendiÄŸinde)
  useEffect(() => {
    const loadSelectedGroup = async () => {
      if (!user?.id || groupsLoading || groups.length === 0) return;

      try {
        const storedGroupId = await AsyncStorage.getItem(SELECTED_GROUP_STORAGE_KEY);
        
        if (storedGroupId) {
          const group = groups.find(g => g.id === storedGroupId);
          if (group) {
            setSelectedGroupState(group);
            return;
          }
        }

        // EÄŸer stored group bulunamadÄ±ysa veya yoksa, ilk grubu seÃ§
        if (groups.length > 0) {
          const firstGroup = groups[0];
          setSelectedGroupState(firstGroup);
          await AsyncStorage.setItem(SELECTED_GROUP_STORAGE_KEY, firstGroup.id);
        }
      } catch (error) {
        console.error('Error loading selected group:', error);
      }
    };

    loadSelectedGroup();
  }, [user?.id, groups, groupsLoading]);

  // SeÃ§ili grubu set et ve AsyncStorage'a kaydet
  const setSelectedGroup = useCallback(async (group: GroupWithOwner | null) => {
    try {
      setSelectedGroupState(group);
      if (group) {
        await AsyncStorage.setItem(SELECTED_GROUP_STORAGE_KEY, group.id);
      } else {
        await AsyncStorage.removeItem(SELECTED_GROUP_STORAGE_KEY);
      }
    } catch (error) {
      console.error('Error saving selected group:', error);
    }
  }, []);

  // Gruplar deÄŸiÅŸtiÄŸinde, seÃ§ili grup hala geÃ§erli mi kontrol et
  useEffect(() => {
    if (selectedGroup && groups.length > 0) {
      const isStillValid = groups.some(g => g.id === selectedGroup.id);
      if (!isStillValid) {
        // SeÃ§ili grup artÄ±k geÃ§erli deÄŸilse, ilk grubu seÃ§
        if (groups.length > 0) {
          setSelectedGroup(groups[0]);
        } else {
          setSelectedGroup(null);
        }
      }
    } else if (!selectedGroup && groups.length > 0) {
      // EÄŸer seÃ§ili grup yoksa ama gruplar varsa, ilkini seÃ§
      setSelectedGroup(groups[0]);
    }
  }, [groups, selectedGroup, setSelectedGroup]);

  // Context value'yu memoize et - groups array referansÄ± deÄŸiÅŸtiÄŸinde gÃ¼ncellenir
  // structuralSharing: false sayesinde her zaman yeni array referansÄ± gelir
  const value: GroupContextValue = useMemo(() => {
    // EÄŸer gruplar cache'ten gelip dolu ise, loading false olsun
    // Bu sayede cache'ten hemen veri gÃ¶sterebiliriz
    const effectiveLoading = groupsLoading && groups.length === 0;
    
    return {
      selectedGroup,
      setSelectedGroup,
      isLoading: effectiveLoading,
      groups,
    };
  }, [selectedGroup, setSelectedGroup, groupsLoading, groups]);

  return <GroupContext.Provider value={value}>{children}</GroupContext.Provider>;
}

export const useGroupContext = (): GroupContextValue => {
  const context = useContext(GroupContext);
  if (!context) {
    throw new Error('useGroupContext must be used within a GroupProvider');
  }
  
  return context;
};
</file>

<file path="types/database.ts">
export interface User {
  id: string; // UUID - auth.users'dan referans
  custom_user_id: string; // TEXT UK - 8 karakterli unique kod (grup davetiyesi iÃ§in)
  email?: string; // TEXT - KullanÄ±cÄ± email adresi
  display_name?: string; // TEXT
  photo_url?: string; // TEXT
  avatar?: string | null; // TEXT - Avatar dosya adÄ± (Ã¶rn: "bear.png", "man-1.png")
  /** @deprecated Use user_group_moods table instead. This field is kept for backward compatibility. */
  mood_id?: number; // INT FK - moods tablosuna referans (DEPRECATED - use user_group_moods)
  show_mood?: boolean; // BOOLEAN
  onesignal_player_id?: string; // TEXT
  updated_at?: string; // TIMESTAMPTZ
}

export interface Mood {
  id: number; // INT PK
  text: string; // TEXT UK
  emoji?: string; // TEXT
  group_id?: string; // UUID FK - Custom mood'lar iÃ§in grup ID'si (NULL ise tÃ¼m gruplar iÃ§in geÃ§erli)
}

export interface Group {
  id: string; // UUID PK
  owner_id: string; // UUID FK
  type: string; // TEXT NOT NULL
  name: string; // TEXT
  invite_code: string; // TEXT UK
  member_limit?: number; // INT
  created_at?: string; // TIMESTAMPTZ
}

export interface GroupMember {
  group_id: string; // UUID PK, FK
  user_id: string; // UUID PK, FK
  joined_at?: string; // TIMESTAMPTZ
}

export interface Nickname {
  group_id: string; // UUID PK, FK
  setter_user_id: string; // UUID PK, FK
  target_user_id: string; // UUID PK, FK
  nickname: string; // TEXT
}

export interface Status {
  id: number; // INT PK
  text: string; // TEXT
  notifies: boolean; // BOOLEAN NOT NULL DEFAULT false
  is_custom: boolean; // BOOLEAN NOT NULL DEFAULT false
  owner_id?: string; // UUID FK - EÄŸer custom ise sahibi
  group_id?: string; // UUID FK - Custom status'ler iÃ§in grup ID'si (NULL ise tÃ¼m gruplar iÃ§in geÃ§erli)
  emoji?: string; // TEXT - Status emoji'si
  messages?: string[]; // TEXT[] - Bildirim mesajlarÄ± (rastgele seÃ§ilecek)
}

export interface UserStatus {
  user_id: string; // UUID PK, FK
  group_id?: string; // UUID FK - NULL ise global status (tÃ¼m gruplar iÃ§in geÃ§erli)
  status_id: number; // INT FK
  updated_at?: string; // TIMESTAMPTZ
}

export interface UserGroupMood {
  user_id: string; // UUID PK, FK
  group_id?: string; // UUID FK - NULL ise global mood (tÃ¼m gruplar iÃ§in geÃ§erli)
  mood_id: number; // INT FK
  updated_at?: string; // TIMESTAMPTZ
}

export interface MutedNotification {
  muter_user_id: string; // UUID PK, FK
  muted_user_id: string; // UUID PK, FK
}

export interface Subscription {
  user_id: string; // UUID PK, FK
  status: string; // TEXT
  expires_at?: string; // TIMESTAMPTZ
}

export interface ScheduledEvent {
  id: string; // UUID PK
  group_id: string; // UUID FK
  creator_id: string; // UUID FK
  title: string; // TEXT
  event_time: string; // TIMESTAMPTZ
  notification_time?: string; // TIMESTAMPTZ
  created_at?: string; // TIMESTAMPTZ
}

export interface GroupJoinRequest {
  id: string; // UUID PK
  group_id: string; // UUID FK
  requester_id: string; // UUID FK
  status: 'pending' | 'approved' | 'rejected'; // TEXT
  created_at?: string; // TIMESTAMPTZ
  updated_at?: string; // TIMESTAMPTZ
}

// Create/Update types (without auto-generated fields)
export type CreateUser = Omit<User, 'id' | 'updated_at'>;
export type UpdateUser = Partial<Omit<User, 'id'>>;

export type CreateMood = Omit<Mood, 'id'>;
export type UpdateMood = Partial<Omit<Mood, 'id'>>;

export type CreateGroup = Omit<Group, 'id' | 'created_at'>;
export type UpdateGroup = Partial<Omit<Group, 'id' | 'created_at'>>;

export type CreateGroupMember = Omit<GroupMember, 'joined_at'>;

export type CreateNickname = Nickname;
export type UpdateNickname = Partial<Omit<Nickname, 'group_id' | 'setter_user_id' | 'target_user_id'>>;

export type CreateStatus = Omit<Status, 'id'>;
export type UpdateStatus = Partial<Omit<Status, 'id'>>;

export type CreateUserStatus = Omit<UserStatus, 'updated_at'>;
export type UpdateUserStatus = Partial<Omit<UserStatus, 'user_id' | 'group_id' | 'updated_at'>>;

export type CreateUserGroupMood = Omit<UserGroupMood, 'updated_at'>;
export type UpdateUserGroupMood = Partial<Omit<UserGroupMood, 'user_id' | 'group_id' | 'updated_at'>>;

export type CreateMutedNotification = MutedNotification;

export type CreateSubscription = Subscription;
export type UpdateSubscription = Partial<Omit<Subscription, 'user_id'>>;

export type CreateScheduledEvent = Omit<ScheduledEvent, 'id' | 'created_at'>;
export type UpdateScheduledEvent = Partial<Omit<ScheduledEvent, 'id' | 'created_at'>>;

export type CreateGroupJoinRequest = Omit<GroupJoinRequest, 'id' | 'created_at' | 'updated_at' | 'status'>;
export type UpdateGroupJoinRequest = Partial<Omit<GroupJoinRequest, 'id' | 'group_id' | 'requester_id' | 'created_at'>>;

// Response types with relations
export interface UserWithMood extends User {
  mood?: Mood;
}

export interface GroupWithOwner extends Group {
  owner?: User;
  members?: GroupMember[];
}

export interface GroupMemberWithUser extends GroupMember {
  user?: User;
}

export interface UserStatusWithStatus extends UserStatus {
  status?: Status;
}

export interface UserGroupMoodWithMood extends UserGroupMood {
  mood?: Mood;
}

export interface ScheduledEventWithDetails extends ScheduledEvent {
  group?: Group;
  creator?: User;
}

export interface GroupJoinRequestWithDetails extends GroupJoinRequest {
  group?: GroupWithOwner;
  requester?: User;
}

export interface PendingNotification {
  id: string; // UUID PK
  sender_id: string; // UUID FK
  receiver_ids: string[]; // UUID[]
  group_id: string; // UUID FK
  status_id: number; // INT FK
  scheduled_at: string; // TIMESTAMPTZ
  created_at?: string; // TIMESTAMPTZ
  updated_at?: string; // TIMESTAMPTZ
}

export type CreatePendingNotification = Omit<PendingNotification, 'id' | 'created_at' | 'updated_at'>;
export type UpdatePendingNotification = Partial<Omit<PendingNotification, 'id' | 'sender_id' | 'group_id' | 'created_at'>>;
</file>

<file path="api/moods.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import React from 'react';
import type {
  CreateMood,
  CreateUserGroupMood,
  Mood,
  UpdateMood,
  UserGroupMood,
  UserGroupMoodWithMood
} from '../types/database';
import { supabase } from './supabase';

// Query Keys
export const moodKeys = {
  all: ['moods'] as const,
  lists: () => [...moodKeys.all, 'list'] as const,
  list: (filters: string) => [...moodKeys.lists(), { filters }] as const,
  details: () => [...moodKeys.all, 'detail'] as const,
  detail: (id: number) => [...moodKeys.details(), id] as const,
};

export const userGroupMoodKeys = {
  all: ['user-group-moods'] as const,
  user: (userId: string, groupId?: string) => [...userGroupMoodKeys.all, 'user', userId, groupId || 'global'] as const,
  group: (groupId: string) => [...userGroupMoodKeys.all, 'group', groupId] as const,
};

// Queries
export const useMoods = (groupId?: string) => {
  return useQuery({
    queryKey: [...moodKeys.lists(), groupId || 'all'],
    queryFn: async (): Promise<Mood[]> => {
      let query = supabase.from('moods').select('*');

      if (groupId) {
        // Grup Ã¶zel mood'lar + default mood'lar (group_id IS NULL)
        query = query.or(`group_id.eq.${groupId},group_id.is.null`);
      }

      const { data, error } = await query.order('text');

      if (error) throw error;
      return data || [];
    },
  });
};

export const useMood = (id: number) => {
  return useQuery({
    queryKey: moodKeys.detail(id),
    queryFn: async (): Promise<Mood | null> => {
      const { data, error } = await supabase
        .from('moods')
        .select('*')
        .eq('id', id)
        .single();

      if (error) throw error;
      return data;
    },
    enabled: !!id,
  });
};

export const useMoodByText = (text: string) => {
  return useQuery({
    queryKey: [...moodKeys.lists(), { text }],
    queryFn: async (): Promise<Mood | null> => {
      const { data, error } = await supabase
        .from('moods')
        .select('*')
        .eq('text', text)
        .single();

      if (error) throw error;
      return data;
    },
    enabled: !!text,
  });
};

// Mutations
export const useCreateMood = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (moodData: CreateMood): Promise<Mood> => {
      const { data, error } = await supabase
        .from('moods')
        .insert(moodData)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: moodKeys.all });
      // Custom mood oluÅŸturulduysa, o grubun mood'larÄ±nÄ± da invalidate et
      if (data.group_id) {
        queryClient.invalidateQueries({ queryKey: [...moodKeys.lists(), data.group_id] });
      }
    },
  });
};

export const useUpdateMood = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ id, updates }: { id: number; updates: UpdateMood }): Promise<Mood> => {
      const { data, error } = await supabase
        .from('moods')
        .update(updates)
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: moodKeys.all });
      queryClient.invalidateQueries({ queryKey: moodKeys.detail(data.id) });
    },
  });
};

export const useDeleteMood = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (id: number): Promise<void> => {
      // Ã–nce bu mood'u kullanan kayÄ±tlarÄ± temizle (Cascade delete simÃ¼lasyonu)
      const { error: cleanupError } = await supabase
        .from('user_group_moods')
        .delete()
        .eq('mood_id', id);

      if (cleanupError) {
        console.error('Mood cleanup error:', cleanupError);
      }

      const { error } = await supabase
        .from('moods')
        .delete()
        .eq('id', id);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: moodKeys.all });
    },
  });
};

// User Group Mood Queries
export const useUserGroupMood = (userId: string, groupId?: string) => {
  return useQuery({
    queryKey: userGroupMoodKeys.user(userId, groupId),
    queryFn: async (): Promise<UserGroupMoodWithMood | null> => {
      let query = supabase
        .from('user_group_moods')
        .select(`
          *,
          mood:moods(*)
        `)
        .eq('user_id', userId);

      // group_id filtresi: NULL ise global, deÄŸilse spesifik grup
      if (groupId) {
        query = query.eq('group_id', groupId);
      } else {
        query = query.is('group_id', null);
      }

      const { data, error } = await query.single();

      if (error && error.code !== 'PGRST116') throw error;
      return data || null;
    },
    enabled: !!userId,
  });
};

// SeÃ§ili grup iÃ§in tÃ¼m kullanÄ±cÄ±larÄ±n mood'larÄ±
export const useGroupUserMoods = (groupId: string) => {
  return useQuery({
    queryKey: userGroupMoodKeys.group(groupId),
    queryFn: async (): Promise<UserGroupMoodWithMood[]> => {
      console.log('ğŸ“¥ Fetching group user moods for group:', groupId);
      // SeÃ§ili grup iÃ§in mood'lar + global mood'lar (group_id IS NULL)
      const { data, error } = await supabase
        .from('user_group_moods')
        .select(`
          *,
          mood:moods(*),
          user:users(*)
        `)
        .or(`group_id.eq.${groupId},group_id.is.null`)
        .order('updated_at', { ascending: false });

      if (error) throw error;
      console.log('âœ… Fetched group user moods:', data?.length || 0, 'moods');
      return data || [];
    },
    enabled: !!groupId,
    // Realtime updates iÃ§in refetch ayarlarÄ±
    refetchOnMount: true,
    refetchOnWindowFocus: false, // Realtime ile gÃ¼ncellendiÄŸi iÃ§in window focus'ta refetch gerekmez
    staleTime: 0, // Her zaman fresh data iste (realtime iÃ§in Ã¶nemli)
  });
};

// User Group Mood Mutations
export const useSetUserGroupMood = () => {
  const queryClient = useQueryClient();

  return useMutation({
    // Optimistic Update: KullanÄ±cÄ± butona basar basmaz UI'Ä± gÃ¼ncelle
    onMutate: async (userGroupMoodData: CreateUserGroupMood) => {
      // Ä°lgili query'leri cancel et (refetch'i engelle)
      await queryClient.cancelQueries({ queryKey: userGroupMoodKeys.all });

      // Mevcut cache'i al
      const previousMoods: UserGroupMoodWithMood[] = [];
      if (userGroupMoodData.group_id) {
        const previousGroupMoods = queryClient.getQueryData<UserGroupMoodWithMood[]>(
          userGroupMoodKeys.group(userGroupMoodData.group_id)
        );
        if (previousGroupMoods) {
          previousMoods.push(...previousGroupMoods);
        }
      }

      // Optimistic update: Cache'i hemen gÃ¼ncelle
      if (userGroupMoodData.group_id) {
        queryClient.setQueryData<UserGroupMoodWithMood[]>(
          userGroupMoodKeys.group(userGroupMoodData.group_id),
          (old = []) => {
            // Eski mood'u kaldÄ±r, yenisini ekle
            const filtered = old.filter(
              m => !(m.user_id === userGroupMoodData.user_id && m.group_id === userGroupMoodData.group_id)
            );
            // Mood bilgisini almak iÃ§in geÃ§ici bir obje oluÅŸtur
            // GerÃ§ek mood bilgisi mutation tamamlandÄ±ÄŸÄ±nda gelecek
            return [
              ...filtered,
              {
                ...userGroupMoodData,
                updated_at: new Date().toISOString(),
                mood: null, // Mood bilgisi henÃ¼z yok, mutation sonrasÄ± gelecek
                user: null, // User bilgisi henÃ¼z yok
              } as any,
            ];
          }
        );
      }

      // Rollback iÃ§in context dÃ¶ndÃ¼r
      return { previousMoods };
    },
    // Hata durumunda rollback
    onError: (err, userGroupMoodData, context) => {
      console.error('âŒ Mood update hatasÄ±, rollback yapÄ±lÄ±yor:', err);
      if (context?.previousMoods && userGroupMoodData.group_id) {
        queryClient.setQueryData(
          userGroupMoodKeys.group(userGroupMoodData.group_id),
          context.previousMoods
        );
      }
    },
    // BaÅŸarÄ±lÄ± veya hatalÄ± olsun, son durumu kontrol et
    onSettled: (data, error, userGroupMoodData) => {
      // Query'leri invalidate et (gerÃ§ek data ile senkronize et)
      queryClient.invalidateQueries({ queryKey: userGroupMoodKeys.all });
      if (userGroupMoodData.group_id) {
        queryClient.invalidateQueries({ queryKey: userGroupMoodKeys.group(userGroupMoodData.group_id) });
      }
      if (data) {
        queryClient.invalidateQueries({
          queryKey: userGroupMoodKeys.user(data.user_id, data.group_id)
        });
      }
    },
    mutationFn: async (userGroupMoodData: CreateUserGroupMood): Promise<UserGroupMood> => {
      // Composite key iÃ§in upsert: user_id ve group_id
      const conflictColumns = userGroupMoodData.group_id
        ? 'user_id,group_id'
        : 'user_id';

      const { data, error } = await supabase
        .from('user_group_moods')
        .upsert(userGroupMoodData, {
          onConflict: conflictColumns
        })
        .select()
        .single();

      if (error) throw error;
      return data;
    },
  });
};

export const useRemoveUserGroupMood = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ userId, groupId }: { userId: string; groupId?: string }): Promise<void> => {
      let query = supabase
        .from('user_group_moods')
        .delete()
        .eq('user_id', userId);

      if (groupId) {
        query = query.eq('group_id', groupId);
      } else {
        query = query.is('group_id', null);
      }

      const { error } = await query;

      if (error) throw error;
    },
    onSuccess: (_, { userId, groupId }) => {
      queryClient.invalidateQueries({ queryKey: userGroupMoodKeys.all });
      queryClient.invalidateQueries({ queryKey: userGroupMoodKeys.user(userId, groupId) });
      if (groupId) {
        queryClient.invalidateQueries({ queryKey: userGroupMoodKeys.group(groupId) });
      }
    },
  });
};

// Realtime Subscription Hooks
export const useMoodsRealtime = () => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['moods-realtime'],
    queryFn: () => {
      const channel = supabase
        .channel('moods-changes')
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'moods',
          },
          () => {
            queryClient.invalidateQueries({ queryKey: moodKeys.all });
          }
        )
        .subscribe();

      return channel;
    },
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};

// SeÃ§ili grup iÃ§in realtime subscription
export const useGroupMoodsRealtime = (groupId: string) => {
  const queryClient = useQueryClient();

  React.useEffect(() => {
    if (!groupId) {
      console.log('âš ï¸ useGroupMoodsRealtime: groupId yok, subscription kurulmuyor');
      return;
    }

    console.log('ğŸ”Œ Setting up realtime subscription for moods, group:', groupId);
    const channelName = `group-moods-changes-${groupId}`;
    const channel = supabase
      .channel(channelName)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'user_group_moods',
          // Filter kaldÄ±rÄ±ldÄ±: Client-side filtering yapacaÄŸÄ±z
        },
        async (payload) => {
          console.log('ğŸ”„ Realtime mood update received:', payload);

          // Client-side filtering: Sadece ilgili grup iÃ§in iÅŸle
          const newRecord = payload.new as any;
          const oldRecord = payload.old as any;

          // group_id kontrolÃ¼: NULL (global) veya seÃ§ili grup
          const isRelevant =
            newRecord?.group_id === groupId ||
            newRecord?.group_id === null ||
            oldRecord?.group_id === groupId ||
            oldRecord?.group_id === null;

          if (!isRelevant) {
            console.log('â­ï¸ Realtime update ignored (farklÄ± grup):', {
              new_group_id: newRecord?.group_id,
              old_group_id: oldRecord?.group_id,
              target_group_id: groupId,
            });
            return;
          }

          console.log('âœ… Realtime mood update (relevant):', payload.eventType, {
            user_id: newRecord?.user_id || oldRecord?.user_id,
            group_id: newRecord?.group_id || oldRecord?.group_id,
            mood_id: newRecord?.mood_id || oldRecord?.mood_id,
          });

          // Direkt cache gÃ¼ncelleme (invalidate'den Ã¶nce, daha hÄ±zlÄ± UI update)
          if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
            // Mood ve user bilgilerini fetch et
            try {
              const { data: moodData } = await supabase
                .from('moods')
                .select('*')
                .eq('id', newRecord.mood_id)
                .single();

              const { data: userData } = await supabase
                .from('users')
                .select('*')
                .eq('id', newRecord.user_id)
                .single();

              const updatedMood: UserGroupMoodWithMood = {
                ...newRecord,
                mood: moodData || undefined,
                user: userData || undefined,
              } as UserGroupMoodWithMood;

              // Cache'i direkt gÃ¼ncelle
              queryClient.setQueryData<UserGroupMoodWithMood[]>(
                userGroupMoodKeys.group(groupId),
                (old = []) => {
                  if (payload.eventType === 'INSERT') {
                    // Yeni mood ekle
                    return [...old, updatedMood];
                  } else {
                    // Mevcut mood'u gÃ¼ncelle
                    return old.map(m =>
                      m.user_id === updatedMood.user_id &&
                        (m.group_id === updatedMood.group_id || (m.group_id === null && updatedMood.group_id === null))
                        ? updatedMood
                        : m
                    );
                  }
                }
              );
            } catch (error) {
              console.error('âŒ Cache update hatasÄ± (fallback to invalidate):', error);
            }
          } else if (payload.eventType === 'DELETE') {
            // Mood silindi, cache'den kaldÄ±r
            queryClient.setQueryData<UserGroupMoodWithMood[]>(
              userGroupMoodKeys.group(groupId),
              (old = []) =>
                old.filter(m =>
                  !(m.user_id === oldRecord.user_id &&
                    (m.group_id === oldRecord.group_id || (m.group_id === null && oldRecord.group_id === null)))
                )
            );
          }

          // Invalidate et (tam senkronizasyon iÃ§in)
          queryClient.invalidateQueries({
            queryKey: userGroupMoodKeys.group(groupId),
            refetchType: 'active'
          });
          queryClient.invalidateQueries({
            queryKey: userGroupMoodKeys.all,
            refetchType: 'active'
          });
        }
      )
      .subscribe((status, err) => {
        console.log('ğŸ“¡ Realtime subscription status (moods):', status, err);
        if (status === 'SUBSCRIBED') {
          console.log('âœ… Realtime subscription baÅŸarÄ±yla kuruldu:', channelName);
        } else if (status === 'CHANNEL_ERROR') {
          console.error('âŒ Realtime subscription hatasÄ±:', err);
        } else if (status === 'TIMED_OUT') {
          console.error('â±ï¸ Realtime subscription timeout:', channelName);
        } else if (status === 'CLOSED') {
          console.warn('âš ï¸ Realtime subscription kapandÄ±:', channelName);
        }
      });

    return () => {
      console.log('ğŸ”Œ Unsubscribing from mood changes for group:', groupId);
      supabase.removeChannel(channel);
    };
  }, [groupId, queryClient]);
};
</file>

<file path="api/statuses.ts">
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import React from 'react';
import type {
  CreateStatus,
  CreateUserStatus,
  Status,
  UpdateStatus,
  UserStatus,
  UserStatusWithStatus
} from '../types/database';
import { supabase } from './supabase';

// Query Keys
export const statusKeys = {
  all: ['statuses'] as const,
  lists: () => [...statusKeys.all, 'list'] as const,
  list: (filters: string) => [...statusKeys.lists(), { filters }] as const,
  details: () => [...statusKeys.all, 'detail'] as const,
  detail: (id: number) => [...statusKeys.details(), id] as const,
  custom: (groupId: string, ownerId?: string) => [...statusKeys.all, 'custom', groupId, ownerId || 'all'] as const,
  default: () => [...statusKeys.all, 'default'] as const,
};

export const userStatusKeys = {
  all: ['user-statuses'] as const,
  user: (userId: string, groupId?: string) => [...userStatusKeys.all, 'user', userId, groupId || 'global'] as const,
  group: (groupId: string) => [...userStatusKeys.all, 'group', groupId] as const,
};

// Status Queries
export const useStatuses = () => {
  return useQuery({
    queryKey: statusKeys.lists(),
    queryFn: async (): Promise<Status[]> => {
      const { data, error } = await supabase
        .from('statuses')
        .select('*')
        .order('text');

      if (error) throw error;
      return data || [];
    },
  });
};

export const useDefaultStatuses = () => {
  return useQuery({
    queryKey: statusKeys.default(),
    queryFn: async (): Promise<Status[]> => {
      const { data, error } = await supabase
        .from('statuses')
        .select('*')
        .eq('is_custom', false)
        .is('group_id', null) // Default status'ler group_id = NULL olmalÄ±
        .order('text');

      if (error) throw error;
      return data || [];
    },
  });
};

export const useCustomStatuses = (groupId: string, ownerId?: string) => {
  return useQuery({
    queryKey: statusKeys.custom(groupId, ownerId),
    queryFn: async (): Promise<Status[]> => {
      let query = supabase
        .from('statuses')
        .select('*')
        .eq('is_custom', true)
        .eq('group_id', groupId);

      if (ownerId) {
        query = query.eq('owner_id', ownerId);
      }

      const { data, error } = await query.order('text');

      if (error) throw error;
      return data || [];
    },
    enabled: !!groupId,
  });
};

export const useStatus = (id: number) => {
  return useQuery({
    queryKey: statusKeys.detail(id),
    queryFn: async (): Promise<Status | null> => {
      const { data, error } = await supabase
        .from('statuses')
        .select('*')
        .eq('id', id)
        .single();

      if (error) throw error;
      return data;
    },
    enabled: !!id,
  });
};

// User Status Queries
export const useUserStatus = (userId: string, groupId?: string) => {
  return useQuery({
    queryKey: userStatusKeys.user(userId, groupId),
    queryFn: async (): Promise<UserStatusWithStatus | null> => {
      let query = supabase
        .from('user_statuses')
        .select(`
          *,
          status:statuses(*)
        `)
        .eq('user_id', userId);

      // group_id filtresi: NULL ise global, deÄŸilse spesifik grup
      if (groupId) {
        query = query.eq('group_id', groupId);
      } else {
        query = query.is('group_id', null);
      }

      const { data, error } = await query.single();

      if (error && error.code !== 'PGRST116') throw error;
      return data || null;
    },
    enabled: !!userId,
  });
};

// SeÃ§ili grup iÃ§in tÃ¼m kullanÄ±cÄ±larÄ±n status'larÄ±
export const useGroupUserStatuses = (groupId: string) => {
  return useQuery({
    queryKey: userStatusKeys.group(groupId),
    queryFn: async (): Promise<UserStatusWithStatus[]> => {
      console.log('ğŸ“¥ Fetching group user statuses for group:', groupId);
      // SeÃ§ili grup iÃ§in status'lar + global status'lar (group_id IS NULL)
      const { data, error } = await supabase
        .from('user_statuses')
        .select(`
          *,
          status:statuses(*),
          user:users(*)
        `)
        .or(`group_id.eq.${groupId},group_id.is.null`)
        .order('updated_at', { ascending: false });

      if (error) throw error;
      console.log('âœ… Fetched group user statuses:', data?.length || 0, 'statuses');
      return data || [];
    },
    enabled: !!groupId,
    // Realtime updates iÃ§in refetch ayarlarÄ±
    refetchOnMount: true,
    refetchOnWindowFocus: false, // Realtime ile gÃ¼ncellendiÄŸi iÃ§in window focus'ta refetch gerekmez
    staleTime: 0, // Her zaman fresh data iste (realtime iÃ§in Ã¶nemli)
  });
};

export const useUsersWithStatuses = () => {
  return useQuery({
    queryKey: [...userStatusKeys.all, 'with-users'],
    queryFn: async (): Promise<UserStatusWithStatus[]> => {
      const { data, error } = await supabase
        .from('user_statuses')
        .select(`
          *,
          status:statuses(*),
          user:users(*)
        `)
        .order('updated_at', { ascending: false });

      if (error) throw error;
      return data || [];
    },
  });
};

// Status Mutations
export const useCreateStatus = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (statusData: CreateStatus): Promise<Status> => {
      const { data, error } = await supabase
        .from('statuses')
        .insert(statusData)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: statusKeys.all });
      // Custom status oluÅŸturulduysa, o grubun custom status'lerini de invalidate et
      if (data.group_id) {
        queryClient.invalidateQueries({ queryKey: statusKeys.custom(data.group_id) });
      }
    },
  });
};

export const useUpdateStatus = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ id, updates }: { id: number; updates: UpdateStatus }): Promise<Status> => {
      const { data, error } = await supabase
        .from('statuses')
        .update(updates)
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: statusKeys.all });
      queryClient.invalidateQueries({ queryKey: statusKeys.detail(data.id) });
    },
  });
};

export const useDeleteStatus = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (id: number): Promise<void> => {
      // Ã–nce bu status'u kullanan kayÄ±tlarÄ± temizle (Cascade delete simÃ¼lasyonu)
      const { error: cleanupError } = await supabase
        .from('user_statuses')
        .delete()
        .eq('status_id', id);

      if (cleanupError) {
        console.error('Status cleanup error:', cleanupError);
        // RLS veya baÅŸka bir hata olabilir, ama ana silme iÅŸlemini denemeye devam edelim
      }

      const { error } = await supabase
        .from('statuses')
        .delete()
        .eq('id', id);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: statusKeys.all });
      queryClient.invalidateQueries({ queryKey: userStatusKeys.all });
    },
  });
};

// User Status Mutations
export const useSetUserStatus = () => {
  const queryClient = useQueryClient();

  return useMutation({
    // Optimistic Update: KullanÄ±cÄ± butona basar basmaz UI'Ä± gÃ¼ncelle
    onMutate: async (userStatusData: CreateUserStatus) => {
      // Ä°lgili query'leri cancel et (refetch'i engelle)
      await queryClient.cancelQueries({ queryKey: userStatusKeys.all });

      // Mevcut cache'i al
      const previousStatuses: UserStatusWithStatus[] = [];
      if (userStatusData.group_id) {
        const previousGroupStatuses = queryClient.getQueryData<UserStatusWithStatus[]>(
          userStatusKeys.group(userStatusData.group_id)
        );
        if (previousGroupStatuses) {
          previousStatuses.push(...previousGroupStatuses);
        }
      }

      // Optimistic update: Cache'i hemen gÃ¼ncelle
      if (userStatusData.group_id) {
        queryClient.setQueryData<UserStatusWithStatus[]>(
          userStatusKeys.group(userStatusData.group_id),
          (old = []) => {
            // Eski status'u kaldÄ±r, yenisini ekle
            const filtered = old.filter(
              s => !(s.user_id === userStatusData.user_id && s.group_id === userStatusData.group_id)
            );
            // Status bilgisini almak iÃ§in geÃ§ici bir obje oluÅŸtur
            // GerÃ§ek status bilgisi mutation tamamlandÄ±ÄŸÄ±nda gelecek
            return [
              ...filtered,
              {
                ...userStatusData,
                updated_at: new Date().toISOString(),
                status: null, // Status bilgisi henÃ¼z yok, mutation sonrasÄ± gelecek
                user: null, // User bilgisi henÃ¼z yok
              } as any,
            ];
          }
        );
      }

      // Rollback iÃ§in context dÃ¶ndÃ¼r
      return { previousStatuses };
    },
    // Hata durumunda rollback
    onError: (err, userStatusData, context) => {
      console.error('âŒ Status update hatasÄ±, rollback yapÄ±lÄ±yor:', err);
      if (context?.previousStatuses && userStatusData.group_id) {
        queryClient.setQueryData(
          userStatusKeys.group(userStatusData.group_id),
          context.previousStatuses
        );
      }
    },
    // BaÅŸarÄ±lÄ± veya hatalÄ± olsun, son durumu kontrol et
    onSettled: (data, error, userStatusData) => {
      // Query'leri invalidate et (gerÃ§ek data ile senkronize et)
      queryClient.invalidateQueries({ queryKey: userStatusKeys.all });
      if (userStatusData.group_id) {
        queryClient.invalidateQueries({ queryKey: userStatusKeys.group(userStatusData.group_id) });
      }
      if (data) {
        queryClient.invalidateQueries({
          queryKey: userStatusKeys.user(data.user_id, data.group_id)
        });
      }
    },
    mutationFn: async (userStatusData: CreateUserStatus): Promise<UserStatus> => {
      // Composite key iÃ§in upsert: user_id ve group_id
      const conflictColumns = userStatusData.group_id
        ? 'user_id,group_id'
        : 'user_id';

      const { data, error } = await supabase
        .from('user_statuses')
        .upsert(userStatusData, {
          onConflict: conflictColumns
        })
        .select()
        .single();

      if (error) throw error;

      // EÄŸer grup iÃ§in status deÄŸiÅŸtirildiyse ve notifies: true ise, pending notification oluÅŸtur/gÃ¼ncelle
      // Custom status'ler iÃ§in de aynÄ± mantÄ±k geÃ§erlidir (statuses tablosunda notifies ve messages kontrol edilir)
      if (data.group_id) {
        try {
          // Status bilgisini al (notifies ve messages kontrolÃ¼ iÃ§in)
          // Custom status'ler iÃ§in de messages array'i kullanÄ±labilir
          const { data: statusData } = await supabase
            .from('statuses')
            .select('notifies, messages, is_custom')
            .eq('id', data.status_id)
            .single();

          // notifies: true ise bildirim gÃ¶nder (custom veya default status fark etmez)
          if (statusData?.notifies) {
            // Grup Ã¼yelerini al (kendisi hariÃ§)
            const { data: members } = await supabase
              .from('group_members')
              .select('user_id')
              .eq('group_id', data.group_id)
              .neq('user_id', data.user_id);

            if (members && members.length > 0) {
              const receiverIds = members.map(m => m.user_id);
              const scheduledAt = new Date(Date.now() + 60 * 1000).toISOString(); // 1 dakika sonra

              // Pending notification oluÅŸtur veya gÃ¼ncelle (sender_id, group_id unique)
              // Bu sayede kullanÄ±cÄ± sÃ¼rekli status deÄŸiÅŸtirirse, sadece son status iÃ§in bildirim gÃ¶nderilir (debounce)
              const { error: pendingError } = await supabase
                .from('pending_notifications')
                .upsert({
                  sender_id: data.user_id,
                  receiver_ids: receiverIds,
                  group_id: data.group_id,
                  status_id: data.status_id,
                  scheduled_at: scheduledAt,
                }, {
                  onConflict: 'sender_id,group_id'
                });

              if (pendingError) {
                console.error('Pending notification oluÅŸturma/gÃ¼ncelleme hatasÄ±:', pendingError);
                // Hata olsa bile status gÃ¼ncellemesi baÅŸarÄ±lÄ± sayÄ±lÄ±r (non-blocking)
              } else {
                console.log('âœ… Pending notification oluÅŸturuldu/gÃ¼ncellendi:', {
                  sender_id: data.user_id,
                  group_id: data.group_id,
                  status_id: data.status_id,
                  receiver_count: receiverIds.length,
                  is_custom: statusData.is_custom,
                  has_messages: !!(statusData.messages && statusData.messages.length > 0),
                });
              }
            }
          } else {
            console.log('â„¹ï¸ Status notifies false, bildirim gÃ¶nderilmeyecek:', {
              status_id: data.status_id,
              is_custom: statusData?.is_custom,
            });
          }
        } catch (error) {
          console.error('Pending notification iÅŸlemi hatasÄ± (non-blocking):', error);
        }
      }

      return data;
    },
  });
};

export const useRemoveUserStatus = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ userId, groupId }: { userId: string; groupId?: string }): Promise<void> => {
      let query = supabase
        .from('user_statuses')
        .delete()
        .eq('user_id', userId);

      if (groupId) {
        query = query.eq('group_id', groupId);
      } else {
        query = query.is('group_id', null);
      }

      const { error } = await query;

      if (error) throw error;
    },
    onSuccess: (_, { userId, groupId }) => {
      queryClient.invalidateQueries({ queryKey: userStatusKeys.all });
      queryClient.invalidateQueries({ queryKey: userStatusKeys.user(userId, groupId) });
      if (groupId) {
        queryClient.invalidateQueries({ queryKey: userStatusKeys.group(groupId) });
      }
    },
  });
};

// Realtime Subscription Hooks
export const useStatusesRealtime = () => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['statuses-realtime'],
    queryFn: () => {
      const channel = supabase
        .channel('statuses-changes')
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'statuses',
          },
          () => {
            queryClient.invalidateQueries({ queryKey: statusKeys.all });
          }
        )
        .subscribe();

      return channel;
    },
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};

export const useUserStatusesRealtime = () => {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ['user-statuses-realtime'],
    queryFn: () => {
      const channel = supabase
        .channel('user-statuses-changes')
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'user_statuses',
          },
          () => {
            queryClient.invalidateQueries({ queryKey: userStatusKeys.all });
          }
        )
        .subscribe();

      return channel;
    },
    staleTime: Infinity,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
};

// SeÃ§ili grup iÃ§in realtime subscription
export const useGroupStatusesRealtime = (groupId: string) => {
  const queryClient = useQueryClient();

  React.useEffect(() => {
    if (!groupId) {
      console.log('âš ï¸ useGroupStatusesRealtime: groupId yok, subscription kurulmuyor');
      return;
    }

    console.log('ğŸ”Œ Setting up realtime subscription for group:', groupId);
    const channelName = `group-statuses-changes-${groupId}`;
    const channel = supabase
      .channel(channelName)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'user_statuses',
          // Filter kaldÄ±rÄ±ldÄ±: Client-side filtering yapacaÄŸÄ±z
        },
        async (payload) => {
          console.log('ğŸ”„ Realtime status update received:', payload);

          // Client-side filtering: Sadece ilgili grup iÃ§in iÅŸle
          const newRecord = payload.new as any;
          const oldRecord = payload.old as any;

          // group_id kontrolÃ¼: NULL (global) veya seÃ§ili grup
          const isRelevant =
            newRecord?.group_id === groupId ||
            newRecord?.group_id === null ||
            oldRecord?.group_id === groupId ||
            oldRecord?.group_id === null;

          if (!isRelevant) {
            console.log('â­ï¸ Realtime update ignored (farklÄ± grup):', {
              new_group_id: newRecord?.group_id,
              old_group_id: oldRecord?.group_id,
              target_group_id: groupId,
            });
            return;
          }

          console.log('âœ… Realtime status update (relevant):', payload.eventType, {
            user_id: newRecord?.user_id || oldRecord?.user_id,
            group_id: newRecord?.group_id || oldRecord?.group_id,
            status_id: newRecord?.status_id || oldRecord?.status_id,
          });

          // Direkt cache gÃ¼ncelleme (invalidate'den Ã¶nce, daha hÄ±zlÄ± UI update)
          if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
            // Status ve user bilgilerini fetch et
            try {
              const { data: statusData } = await supabase
                .from('statuses')
                .select('*')
                .eq('id', newRecord.status_id)
                .single();

              const { data: userData } = await supabase
                .from('users')
                .select('*')
                .eq('id', newRecord.user_id)
                .single();

              const updatedStatus: UserStatusWithStatus = {
                ...newRecord,
                status: statusData || undefined,
                user: userData || undefined,
              } as UserStatusWithStatus;

              // Cache'i direkt gÃ¼ncelle
              queryClient.setQueryData<UserStatusWithStatus[]>(
                userStatusKeys.group(groupId),
                (old = []) => {
                  if (payload.eventType === 'INSERT') {
                    // Yeni status ekle
                    return [...old, updatedStatus];
                  } else {
                    // Mevcut status'u gÃ¼ncelle
                    return old.map(s =>
                      s.user_id === updatedStatus.user_id &&
                        (s.group_id === updatedStatus.group_id || (s.group_id === null && updatedStatus.group_id === null))
                        ? updatedStatus
                        : s
                    );
                  }
                }
              );
            } catch (error) {
              console.error('âŒ Cache update hatasÄ± (fallback to invalidate):', error);
            }
          } else if (payload.eventType === 'DELETE') {
            // Status silindi, cache'den kaldÄ±r
            queryClient.setQueryData<UserStatusWithStatus[]>(
              userStatusKeys.group(groupId),
              (old = []) =>
                old.filter(s =>
                  !(s.user_id === oldRecord.user_id &&
                    (s.group_id === oldRecord.group_id || (s.group_id === null && oldRecord.group_id === null)))
                )
            );
          }

          // Invalidate et (tam senkronizasyon iÃ§in)
          queryClient.invalidateQueries({
            queryKey: userStatusKeys.group(groupId),
            refetchType: 'active'
          });
          queryClient.invalidateQueries({
            queryKey: userStatusKeys.all,
            refetchType: 'active'
          });
        }
      )
      .subscribe((status, err) => {
        console.log('ğŸ“¡ Realtime subscription status (statuses):', status, err);
        if (status === 'SUBSCRIBED') {
          console.log('âœ… Realtime subscription baÅŸarÄ±yla kuruldu:', channelName);
        } else if (status === 'CHANNEL_ERROR') {
          console.error('âŒ Realtime subscription hatasÄ±:', err);
        } else if (status === 'TIMED_OUT') {
          console.error('â±ï¸ Realtime subscription timeout:', channelName);
        } else if (status === 'CLOSED') {
          console.warn('âš ï¸ Realtime subscription kapandÄ±:', channelName);
        }
      });

    return () => {
      console.log('ğŸ”Œ Unsubscribing from status changes for group:', groupId);
      supabase.removeChannel(channel);
    };
  }, [groupId, queryClient]);
};
</file>

<file path="app/index.tsx">
import { SplashScreen as CustomSplashScreen } from "@/components/shared";
import * as SplashScreen from 'expo-splash-screen';
import { useEffect } from "react";

export default function Index() {
  useEffect(() => {
    SplashScreen.hideAsync();
  }, []);

  return <CustomSplashScreen />;
}
</file>

<file path="components/dashboard/DashboardView.tsx">
import { useGroupMembers } from '@/api/groups';
import { useGroupUserMoods, useUserGroupMood } from '@/api/moods';
import { useGroupNicknames } from '@/api/nicknames';
import { useGroupUserStatuses, useUserStatus } from '@/api/statuses';
import CurrentUserHeader from '@/components/dashboard/CurrentUserHeader';
import MemberCard from '@/components/dashboard/MemberCard';
import MoodSelector from '@/components/dashboard/MoodSelector';
import StatusSelector from '@/components/dashboard/StatusSelector';
import { Typography } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useTheme } from '@/contexts/ThemeContext';
import type { GroupMemberWithUser, GroupWithOwner } from '@/types/database';
import { groupTypeSelector } from '@/utils/group-type-selector';
import React from 'react';
import { ActivityIndicator, FlatList, StyleSheet, View } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

interface DashboardViewProps {
  group: GroupWithOwner;
}

export default function DashboardView({ group }: DashboardViewProps) {
  const { colors } = useTheme();
  const { user } = useAuth();
  const insets = useSafeAreaInsets();

  // Verileri Ã§ek (React Query hooks)
  const { data: allMembers, isLoading: membersLoading } = useGroupMembers(group.id);
  const { data: groupStatuses } = useGroupUserStatuses(group.id);
  const { data: groupMoods } = useGroupUserMoods(group.id);
  const { data: nicknames = [] } = useGroupNicknames(group.id);

  // Benim ÅŸu anki statusum (StatusSelector iÃ§in)
  const { data: myStatus } = useUserStatus(user?.id || '', group.id);
  // Benim ÅŸu anki mood'um (MoodSelector iÃ§in)
  const { data: myMood } = useUserGroupMood(user?.id || '', group.id);

  // Her member iÃ§in nickname'i bul (setter: current user, target: member user)
  const getNicknameForMember = (targetUserId: string): string | undefined => {
    if (!user?.id) return undefined;
    const nickname = nicknames.find(
      n => n.setter_user_id === user.id && n.target_user_id === targetUserId
    );
    return nickname?.nickname;
  };

  if (membersLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator color={colors.primary} size="large" />
      </View>
    );
  }

  // Ãœyeleri ayÄ±r: Ben ve DiÄŸerleri
  const myMemberInfo = allMembers?.find(m => m.user_id === user?.id);
  const otherMembers = allMembers?.filter(m => m.user_id !== user?.id) || [];
  // FlatList Header: Stacked Layout Components
  const DashboardHeader = () => (
    <View style={styles.headerContainer}>
      {/* 1. Current User Header */}
      {myMemberInfo && (
        <View style={styles.paddedSection}>
          <CurrentUserHeader
            member={myMemberInfo}
            status={myStatus || undefined}
            mood={myMood || undefined}
          />
        </View>
      )}

      {/* 2. Status Selector - Edge to Edge */}
      <StatusSelector
        groupId={group.id}
        currentStatusId={myStatus?.status_id}
        onAddPress={() => console.log('Add Status Pressed')}
      />

      {/* 3. Mood Selector - Edge to Edge */}
      <MoodSelector
        groupId={group.id}
        currentMoodId={myMood?.mood_id}
        onAddPress={() => console.log('Add Mood Pressed')}
      />

      {/* 4. Section Title for Other Members */}
      <View style={styles.paddedSection}>
        <Typography variant="h5" color={colors.text} style={styles.sectionTitle}>
          {groupTypeSelector(group.type)} ({otherMembers.length})
        </Typography>
      </View>
    </View>
  );

  const statusMap = React.useMemo(() => {
    const map: Record<string, typeof groupStatuses[0]> = {};
    groupStatuses?.forEach(s => map[s.user_id] = s);
    return map;
  }, [groupStatuses]);

  const moodMap = React.useMemo(() => {
    const map: Record<string, typeof groupMoods[0]> = {};
    groupMoods?.forEach(m => map[m.user_id] = m);
    return map;
  }, [groupMoods]);

  const renderItem = ({ item }: { item: GroupMemberWithUser }) => {
    const memberStatus = statusMap[item.user_id]; // O(1) - AnÄ±nda eriÅŸim
    const memberMood = moodMap[item.user_id];     // O(1) - AnÄ±nda eriÅŸim
    const nickname = getNicknameForMember(item.user_id);

    return (
      <View style={styles.paddedSection}>
        <MemberCard
          member={item}
          status={memberStatus}
          mood={memberMood}
          isMe={false}
          nickname={nickname}
        />
      </View>
    );
  };

  return (
    <View style={[styles.container]}>
      <FlatList
        data={otherMembers}
        keyExtractor={(item) => item.user_id}
        contentContainerStyle={[styles.listContent, { paddingBottom: insets.bottom + 20 }]}
        ListHeaderComponent={DashboardHeader}
        renderItem={renderItem}
        ListEmptyComponent={
          <Typography variant="body" color={colors.secondaryText} style={{ textAlign: 'center', marginTop: 20 }}>
            Bu grupta baÅŸka kimse yok.
          </Typography>
        }
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  listContent: {
    paddingHorizontal: 0, // Removed global padding
    paddingTop: 0,
  },
  headerContainer: {
    marginBottom: 8,
  },
  paddedSection: {
    paddingHorizontal: 8,
  },
  sectionTitle: {
    marginBottom: 4,
    marginLeft: 4,
    marginTop: 20,
  },
});
</file>

<file path="components/dashboard/MoodSelector.tsx">
import { useMoods, useSetUserGroupMood } from '@/api/moods';
import AddStatusMoodModal from '@/components/dashboard/AddStatusMoodModal';
import { GeliomButton } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useTheme } from '@/contexts/ThemeContext';
import { useManageStatusMood } from '@/hooks/useManageStatusMood';
import React, { useMemo, useState } from 'react';
import { ActivityIndicator, FlatList, StyleSheet, View } from 'react-native';

interface MoodSelectorProps {
  groupId: string;
  currentMoodId?: number;
  onAddPress?: () => void;
}

export default function MoodSelector({ groupId, currentMoodId, onAddPress }: MoodSelectorProps) {
  const { colors } = useTheme();
  const { user } = useAuth();
  const [isModalVisible, setIsModalVisible] = useState(false);

  // Management Hook
  const { handleAddMood, checkSubscriptionAndProceed } = useManageStatusMood(groupId);

  // Fetch all moods
  const { data: allMoods = [], isLoading } = useMoods(groupId);

  const setMoodMutation = useSetUserGroupMood();

  const handleMoodSelect = (moodId: number) => {
    if (!user) return;
    setMoodMutation.mutate({
      user_id: user.id,
      mood_id: moodId,
      group_id: groupId || undefined,
    });
  };

  // Sort moods: Custom first, then default
  const sortedMoods = useMemo(() => {
    return [...allMoods].sort((a, b) => {
      const aIsCustom = a.group_id != null;
      const bIsCustom = b.group_id != null;
      if (aIsCustom && !bIsCustom) return -1;
      if (!aIsCustom && bIsCustom) return 1;
      return a.text.localeCompare(b.text);
    });
  }, [allMoods]);

  if (isLoading) {
    return <ActivityIndicator size="small" color={colors.primary} />;
  }

  return (
    <View style={styles.container}>
      <FlatList
        data={[...sortedMoods, { id: -1, text: 'Ekle', emoji: 'â•', group_id: null }]} // Add dummy item for "+" button
        keyExtractor={(item) => item.id.toString()}
        horizontal
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.listContent}
        renderItem={({ item }) => {
          // Render "+" Button
          if (item.id === -1) {
            return (
              <GeliomButton
                state="passive"
                onPress={() => checkSubscriptionAndProceed(() => setIsModalVisible(true))}
                size="small"
                layout="icon-only"
                icon="add"
                style={{ borderColor: colors.stroke, borderWidth: 1, borderStyle: 'dashed' }}
              />
            );
          }

          const isSelected = currentMoodId === item.id;

          return (
            <View style={[
              styles.buttonContainer,
              isSelected && styles.buttonContainerSelected
            ]}>
              {/* Background */}
              <View style={[StyleSheet.absoluteFill, { borderRadius: 12, overflow: 'hidden' }]}>
                <View style={[
                  StyleSheet.absoluteFill,
                  { backgroundColor: colors.secondaryBackground }
                ]} />
              </View>

              <GeliomButton
                state={isSelected ? 'active' : 'passive'}
                onPress={() => handleMoodSelect(item.id)}
                size="small"
                backgroundColor="transparent"
                textColor={isSelected ? colors.tertiary : colors.text}
                textStyle={isSelected ? {  fontWeight: 'bold' } : undefined}
                style={[
                  styles.button,
                  { borderColor: 'transparent' }
                ] as any}
              >
                {item.emoji} {item.text}
              </GeliomButton>
            </View>
          );
        }}
      />

      <AddStatusMoodModal
        visible={isModalVisible}
        type="mood"
        onClose={() => setIsModalVisible(false)}
        onSave={(text, emoji) => handleAddMood(text, emoji)}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
  },
  listContent: {
    paddingLeft: 12, // Only left padding as requested
    paddingRight: 12,
    gap: 12,
    paddingBottom: 8,
  },
  buttonContainer: {
    marginBottom: 4,
    borderRadius: 12,
  },
  buttonContainerSelected: {
    transform: [{ translateY: 1 }],
  },
  button: {
    minWidth: 80,
    borderRadius: 12,
    borderWidth: 1,
    height: 40,
    zIndex: 2,
    marginBottom: 0,
  },
});
</file>

<file path="components/dashboard/StatusSelector.tsx">
import { useCustomStatuses, useDefaultStatuses, useSetUserStatus } from '@/api/statuses';
import AddStatusMoodModal from '@/components/dashboard/AddStatusMoodModal';
import { GeliomButton } from '@/components/shared';
import { useAuth } from '@/contexts/AuthContext';
import { useTheme } from '@/contexts/ThemeContext';
import { useManageStatusMood } from '@/hooks/useManageStatusMood';
import React, { useMemo, useState } from 'react';
import { ActivityIndicator, FlatList, StyleSheet, View } from 'react-native';

interface StatusSelectorProps {
  groupId: string;
  currentStatusId?: number;
  onAddPress?: () => void;
}

export default function StatusSelector({ groupId, currentStatusId, onAddPress }: StatusSelectorProps) {
  const { colors } = useTheme();
  const { user } = useAuth();
  const [isModalVisible, setIsModalVisible] = useState(false);

  // Management Hook
  const { handleAddStatus, checkSubscriptionAndProceed } = useManageStatusMood(groupId);

  // Fetch default and custom statuses
  const { data: defaultStatuses = [], isLoading: isLoadingDefault } = useDefaultStatuses();
  const { data: customStatuses = [], isLoading: isLoadingCustom } = useCustomStatuses(groupId, user?.id);

  const setStatusMutation = useSetUserStatus();

  const handleStatusSelect = (statusId: number) => {
    if (!user) return;
    setStatusMutation.mutate({
      user_id: user.id,
      group_id: groupId,
      status_id: statusId,
    });
  };

  const isLoading = isLoadingDefault || isLoadingCustom;

  // Merge and sort statuses
  const sortedStatuses = useMemo(() => {
    const all = [...customStatuses, ...defaultStatuses];
    return all.sort((a, b) => {
      // Custom statuses first
      if (a.is_custom && !b.is_custom) return -1;
      if (!a.is_custom && b.is_custom) return 1;
      // Then alphabetical
      return a.text.localeCompare(b.text);
    });
  }, [customStatuses, defaultStatuses]);

  if (isLoading) {
    return <ActivityIndicator size="small" color={colors.primary} />;
  }

  return (
    <View style={styles.container}>
      <FlatList
        data={[...sortedStatuses, { id: -1, text: 'Ekle', is_custom: false }]} // Add dummy item for "+" button
        keyExtractor={(item) => item.id.toString()}
        horizontal
        showsHorizontalScrollIndicator={false}
        contentContainerStyle={styles.listContent}
        renderItem={({ item }) => {
          // Render "+" Button
          if (item.id === -1) {
            return (
              <GeliomButton
                state="passive"
                onPress={() => checkSubscriptionAndProceed(() => setIsModalVisible(true))}
                size="small"
                layout="icon-only"
                icon="add"
                style={{ borderColor: colors.stroke, borderWidth: 1, borderStyle: 'dashed' }}
              />
            );
          }

          const isSelected = currentStatusId === item.id;

          return (
            <View style={[
              styles.buttonContainer,
              isSelected && styles.buttonContainerSelected
            ]}>
              {/* Background */}
              <View style={[StyleSheet.absoluteFill, { borderRadius: 12, overflow: 'hidden' }]}>
                <View style={[
                  StyleSheet.absoluteFill,
                  { backgroundColor: colors.secondaryBackground }
                ]} />
              </View>

              <GeliomButton
                state={isSelected ? 'active' : 'passive'}
                onPress={() => handleStatusSelect(item.id)}
                size="small"
                layout="icon-left"
                icon={isSelected ? "radio-button-on" : "radio-button-off"}
                backgroundColor="transparent"
                textColor={isSelected ? colors.secondary : colors.text}
                textStyle={isSelected ? { fontWeight: 'bold' } : undefined}
                style={[
                  styles.button,
                  { borderColor: 'transparent' }
                ] as any}
              >
                {item.text}
              </GeliomButton>
            </View>
          );
        }}
      />

      <AddStatusMoodModal
        visible={isModalVisible}
        type="status"
        onClose={() => setIsModalVisible(false)}
        onSave={handleAddStatus}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
  },
  listContent: {
    paddingLeft: 12, // Only left padding as requested
    paddingRight: 12,
    gap: 12,
    paddingBottom: 8,
  },
  buttonContainer: {
    marginBottom: 4,
    borderRadius: 12,
  },
  buttonContainerSelected: {
    transform: [{ translateY: 1 }],
  },
  button: {
    minWidth: 100,
    borderRadius: 12,
    borderWidth: 1,
    height: 40,
    zIndex: 2,
    marginBottom: 0, // Removed extra margin since edge is gone
  },
});
</file>

<file path="components/shared/GeliomButton.tsx">
import { Ionicons } from '@expo/vector-icons';
import React, { ReactNode } from 'react';
import {
  ActivityIndicator,
  StyleSheet,
  Text,
  View,
  ViewStyle,
} from 'react-native';
import { useTheme } from '../../contexts/ThemeContext';
// Yeni animasyon bileÅŸenini import ediyoruz
import { BouncyButton } from '../anim/AnimatedComponents';

export type GeliomButtonState = 'active' | 'passive' | 'loading';
export type GeliomButtonSize = 'small' | 'medium' | 'large' | 'xl';
export type GeliomButtonLayout = 'default' | 'icon-left' | 'icon-right' | 'icon-only' | 'full-width';

export interface GeliomButtonProps {
  children?: ReactNode;
  state?: GeliomButtonState;
  size?: GeliomButtonSize;
  layout?: GeliomButtonLayout;
  icon?: keyof typeof Ionicons.glyphMap;
  onPress?: () => void;
  disabled?: boolean;
  style?: ViewStyle;
  textColor?: string;
  backgroundColor?: string;
  textStyle?: any;
}

const GeliomButton: React.FC<GeliomButtonProps> = ({
  children,
  state = 'active',
  size = 'medium',
  layout = 'default',
  icon,
  onPress,
  disabled = false,
  style,
  textColor,
  backgroundColor,
  textStyle,
}) => {
  const { colors } = useTheme();

  // Organik boyutlandÄ±rma
  const buttonSizeConfig = {
    small: {
      paddingHorizontal: 14,
      paddingVertical: 8,
      borderRadius: 14,
      fontSize: 14,
      iconSize: 16,
      minHeight: 32,
      gap: 6,
    },
    medium: {
      paddingHorizontal: 18,
      paddingVertical: 12,
      borderRadius: 18,
      fontSize: 16,
      iconSize: 18,
      minHeight: 42,
      gap: 8,
    },
    large: {
      paddingHorizontal: 24,
      paddingVertical: 16,
      borderRadius: 22,
      fontSize: 18,
      iconSize: 20,
      minHeight: 52,
      gap: 10,
    },
    xl: {
      paddingHorizontal: 32,
      paddingVertical: 20,
      borderRadius: 26,
      fontSize: 20,
      iconSize: 24,
      minHeight: 62,
      gap: 12,
    },
  };

  const currentConfig = buttonSizeConfig[size];

  const getStateColors = () => {
    // Tema renklerinden gÃ¼venli eriÅŸim
    const activeColor = colors.primary;
    const passiveColor = colors.tertiary;
    const loadingColor = colors.secondary;

    switch (state) {
      case 'active':
        return {
          backgroundColor: backgroundColor || activeColor,
          textColor: textColor || '#FFFFFF',
          shadowColor: activeColor,
          borderColor: 'transparent',
        };
      case 'passive':
        return {
          backgroundColor: backgroundColor || passiveColor + '40', // %40 opaklÄ±k
          textColor: textColor || colors.primary,
          shadowColor: 'transparent',
          borderColor: 'transparent',
        };
      case 'loading':
        return {
          backgroundColor: backgroundColor || loadingColor,
          textColor: textColor || '#FFFFFF',
          shadowColor: loadingColor,
          borderColor: 'transparent',
        };
      default:
        return {
          backgroundColor: backgroundColor || activeColor,
          textColor: textColor || '#FFFFFF',
          shadowColor: activeColor,
          borderColor: 'transparent',
        };
    }
  };

  const stateColors = getStateColors();

  const getLayoutStyle = (): ViewStyle => {
    const baseStyle: ViewStyle = {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      paddingHorizontal: currentConfig.paddingHorizontal,
      paddingVertical: currentConfig.paddingVertical,
      borderRadius: currentConfig.borderRadius,
      minHeight: currentConfig.minHeight,
      gap: currentConfig.gap,
      backgroundColor: stateColors.backgroundColor,
      borderColor: stateColors.borderColor,
      opacity: disabled ? 0.6 : 1,
    };

    switch (layout) {
      case 'icon-left':
        return { ...baseStyle, flexDirection: 'row' };
      case 'icon-right':
        return { ...baseStyle, flexDirection: 'row-reverse' };
      case 'icon-only':
        return {
          ...baseStyle,
          paddingHorizontal: 0,
          width: currentConfig.minHeight, // Kare form
          justifyContent: 'center',
        };
      case 'full-width':
        return { ...baseStyle, width: '100%' };
      default:
        return baseStyle;
    }
  };

  const buttonStyle = getLayoutStyle();

  const renderIcon = () => {
    if (!icon) return null;
    return (
      <Ionicons
        name={icon}
        size={currentConfig.iconSize}
        color={stateColors.textColor}
      />
    );
  };

  const renderText = () => {
    if (layout === 'icon-only') return null;
    if (state === 'loading') return null;

    return (
      <Text style={[styles.text, {
        color: stateColors.textColor,
        fontSize: currentConfig.fontSize,
      }, textStyle]}>
        {children}
      </Text>
    );
  };

  const renderLoading = () => {
    if (state !== 'loading') return null;
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="small" color={stateColors.textColor} />
      </View>
    );
  };

  // TouchableOpacity yerine BouncyButton kullanÄ±yoruz
  return (
    <BouncyButton
      onPress={onPress}
      disabled={disabled || state === 'loading'}
      style={[
        buttonStyle,
        state === 'active' && styles.shadow, // Sadece active iken gÃ¶lge
        { shadowColor: stateColors.shadowColor },
        style,
      ]}
    >
      {state === 'loading' ? (
        renderLoading()
      ) : (
        <>
          {(layout === 'icon-left' || layout === 'icon-only') && renderIcon()}
          {renderText()}
          {layout === 'icon-right' && renderIcon()}
        </>
      )}
    </BouncyButton>
  );
};

const styles = StyleSheet.create({
  text: {
    fontFamily: 'Comfortaa-SemiBold',
    textAlign: 'center',
    fontWeight: '600',
  },
  shadow: {
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.25,
    shadowRadius: 8,
    elevation: 4,
  },
  loadingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
});

export default GeliomButton;
</file>

<file path="components/shared/GroupHeader.tsx">
import { Ionicons } from '@expo/vector-icons';
import React from 'react';
import { StyleSheet, View } from 'react-native';
import { useTheme } from '../../contexts/ThemeContext';
import type { GroupWithOwner } from '../../types/database';
import { BouncyButton } from '../anim/AnimatedComponents';
import Typography from './Typography';

interface GroupHeaderProps {
  group: GroupWithOwner | null;
  onPress: () => void;
}

export default function GroupHeader({ group, onPress }: GroupHeaderProps) {
  const { colors } = useTheme();

  // Grup adÄ±nÄ± max 15 karakter gÃ¶ster
  const displayName = group?.name
    ? group.name.length > 15
      ? group.name.substring(0, 15) + '...'
      : group.name
    : 'Grup OluÅŸtur';

  return (
    <BouncyButton
      onPress={onPress}
      style={[styles.container]}
    >
      <View style={styles.content}>
        <View style={[styles.iconBox, { backgroundColor: colors.primary }]}>
          <Ionicons name="people" size={14} color="white" />
        </View>

        <Typography
          variant="h6"
          color={colors.text}
          style={styles.groupName}
          numberOfLines={1}
        >
          {displayName}
        </Typography>

        <Ionicons
          name="chevron-down"
          size={16}
          color={colors.secondaryText}
          style={styles.icon}
        />
      </View>
    </BouncyButton>
  );
};

const styles = StyleSheet.create({
  container: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
    alignSelf: 'flex-start', // Sadece kendi iÃ§eriÄŸini kaplasÄ±n
  },
  content: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  iconBox: {
    width: 24,
    height: 24,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  groupName: {
    fontSize: 14,
    maxWidth: 120, // Max geniÅŸlik sÄ±nÄ±rÄ± (15 karakter iÃ§in yeterli)
  },
  icon: {
    marginLeft: 2,
  },
});
</file>

<file path="components/shared/index.ts">
export { default as AvatarSelector } from './AvatarSelector';
export { default as BaseLayout } from './BaseLayout';
export { default as BlurButton } from './BlurButton';
export { default as Button } from './Button';
export { default as GeliomButton } from './GeliomButton';
export { default as GroupHeader } from './GroupHeader';
export { default as GroupListBottomSheet } from './GroupListBottomSheet';
export { default as Popover } from './Popover';
export { SplashScreen } from './SplashScreen';
export { default as CustomText } from './Text';
export { default as Typography } from './Typography';
</file>

<file path="theme/colors.ts">
/**
 * Theme Interface
 * Light ve Dark mod arasÄ±nda tutarlÄ±lÄ±ÄŸÄ± garanti eder.
 */
export interface ThemeColors {
  // Ana Marka Renkleri
  primary: string;
  secondary: string;
  tertiary: string;

  // Component DurumlarÄ± (GeliomButton vb. iÃ§in)
  activeState: string; // Active State
  passiveState: string;   // Passive State
  loadingState: string;   // Loading State
  
  // Gradyanlar
  linearGradient: string[];

  // Tipografi
  text: string;
  secondaryText: string;
  lightText: string;

  // Arkaplanlar
  background: string;
  secondaryBackground: string;
  cardBackground: string;

  // Durum Renkleri
  success: string;
  warning: string;
  error: string;
  info: string;

  // NÃ¶tr Renkler
  black: string;
  white: string;
  gray: string;
  lightGray: string;

  // EtkileÅŸim ElemanlarÄ±
  disabled: string;
  stroke: string;
  shadow: string;
  passiveButton: string;

  // Katmanlar
  overlay: string;
  blurBackground: string;
}

/**
 * Light Theme - Social Harmony (Temiz, Ä°ndigo & GÃ¼l)
 */
export const lightColors: ThemeColors = {
  // Marka - Modern, GÃ¼venilir, Enerjik
  primary: '#4F46E5',        // Indigo 600
  secondary: '#E11D48',      // Rose 600
  tertiary: '#8B5CF6',       // Violet 500
  
  // Component DurumlarÄ±
  activeState: '#4338CA',         // Indigo 700 (Aktif/GÃ¼Ã§lÃ¼)
  passiveState: 'rgba(99, 102, 241, 0.15)', // Indigo 500 @ 15% (Pasif/Hafif)
  loadingState: '#6366F1',           // Indigo 500 (YÃ¼kleniyor/CanlÄ±)
  
  linearGradient: ['#4F46E5', '#7C3AED'], // Indigo'dan Violet'e
  
  // Tipografi - Slate Serisi (YÃ¼ksek Okunabilirlik)
  text: '#0F172A',           // Slate 900
  secondaryText: '#475569',  // Slate 600
  lightText: '#94A3B8',      // Slate 400
  
  // Arkaplanlar
  background: '#F8FAFC',     // Slate 50
  secondaryBackground: '#F1F5F9', // Slate 100
  cardBackground: '#FFFFFF', // Saf Beyaz
  
  // Durumlar
  success: '#10B981',        // Emerald 500
  warning: '#F59E0B',        // Amber 500
  error: '#EF4444',          // Red 500
  info: '#3B82F6',           // Blue 500
  
  // NÃ¶trler
  black: '#020617',          // Slate 950
  white: '#FFFFFF',
  gray: '#64748B',           // Slate 500
  lightGray: '#E2E8F0',      // Slate 200
  
  // EtkileÅŸim
  disabled: '#CBD5E1',       // Slate 300
  stroke: '#E2E8F0',         // Slate 200
  shadow: 'rgba(79, 70, 229, 0.15)', // Ä°ndigo tonlu gÃ¶lge
  passiveButton: 'rgba(57, 62, 70, 0.3)', // #393E46 @ 80%
  
  // Katmanlar
  overlay: 'rgba(15, 23, 42, 0.6)',     // Koyu Slate Overlay
  blurBackground: 'rgba(255, 255, 255, 0.85)',
};

/**
 * Dark Theme - Deep Night Social (GÃ¶z yormayan Slate & Neon)
 */
export const darkColors: ThemeColors = {
  // Marka - KaranlÄ±k modda gÃ¶rÃ¼nÃ¼rlÃ¼k iÃ§in daha aÃ§Ä±k/neon tonlar
  primary: '#818CF8',        // Indigo 400
  secondary: '#FB7185',      // Rose 400
  tertiary: '#A78BFA',       // Violet 400
  
  // Component DurumlarÄ±
  activeState: '#6366F1',         // Indigo 500 (Aktif)
  passiveState: 'rgba(129, 140, 248, 0.2)', // Indigo 400 @ 20% (Pasif)
  loadingState: '#4F46E5',           // Indigo 600 (YÃ¼kleniyor)
  
  linearGradient: ['#6366F1', '#8B5CF6'],
  
  // Tipografi
  text: '#F8FAFC',           // Slate 50
  secondaryText: '#CBD5E1',  // Slate 300
  lightText: '#64748B',      // Slate 500
  
  // Arkaplanlar
  background: '#020617',     // Slate 950 (Derin Lacivert/Siyah)
  secondaryBackground: '#0F172A', // Slate 900
  cardBackground: '#1E293B', // Slate 800
  
  // Durumlar
  success: '#34D399',        // Emerald 400
  warning: '#FBBF24',        // Amber 400
  error: '#F87171',          // Red 400
  info: '#60A5FA',           // Blue 400
  
  // NÃ¶trler
  black: '#000000',
  white: '#F8FAFC',
  gray: '#94A3B8',           // Slate 400
  lightGray: '#334155',      // Slate 700
  
  // EtkileÅŸim
  disabled: '#334155',       // Slate 700
  stroke: '#334155',         // Slate 700
  shadow: 'rgba(0, 0, 0, 0.5)', // Derin siyah gÃ¶lge
  passiveButton: '#DBE2EF', // #393E46 @ 80%
  
  // Katmanlar
  overlay: 'rgba(0, 0, 0, 0.7)',
  blurBackground: 'rgba(30, 41, 59, 0.8)', // Slate 800 bazlÄ±
};

// Styled-components veya hook'larda kullanÄ±m iÃ§in export
export type Colors = ThemeColors;
</file>

<file path="app/(drawer)/_layout.tsx">
import { useGroupJoinRequestsRealtime } from '@/api/groups';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { Drawer } from 'expo-router/drawer';
import React, { useCallback } from 'react';
import { ActivityIndicator, StyleSheet, TouchableOpacity, View } from 'react-native';
import { CustomDrawerContent } from '../../components';
import { GroupHeader, GroupListBottomSheet } from '../../components/shared';
import { useAuth } from '../../contexts/AuthContext';
import { useBottomSheet } from '../../contexts/BottomSheetContext';
import { useGroupContext } from '../../contexts/GroupContext';
import { useTheme } from '../../contexts/ThemeContext';

export default function DrawerLayout() {
    const { isLoading, session } = useAuth();
    const { selectedGroup, groups } = useGroupContext();
    const { openBottomSheet } = useBottomSheet();
    const { colors } = useTheme();
    const router = useRouter();
    
    // Realtime subscription
    useGroupJoinRequestsRealtime(selectedGroup?.id || '');

    const createHandleGroupHeaderPress = useCallback((navigation: any) => {
        return () => {
            if (!selectedGroup || groups.length === 0) {
                router.push('/(drawer)/(group)/create-group');
                return;
            }
            
            // Her aÃ§Ä±lÄ±ÅŸta yeni key ile render et - context gÃ¼ncellemelerini almak iÃ§in
            openBottomSheet(<GroupListBottomSheet key={Date.now()} />, {
                snapPoints: ['60%'],
                enablePanDownToClose: true,
            });
        };
    }, [openBottomSheet, selectedGroup, groups, router]);

    const handleGroupManagementPress = () => {
        if (selectedGroup) {
            router.push('/(drawer)/(group)/group-management');
        }
    };

    const handleJoinRequestsPress = () => {
        if (selectedGroup) {
            router.push('/(drawer)/(group)/join-requests');
        }
    };

    if (isLoading) {
        return (
            <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: colors.background }}>
                <ActivityIndicator size="large" color={colors.primary} />
            </View>
        );
    }

    if (!session) return null;

    return (
        <Drawer
            drawerContent={(props) => <CustomDrawerContent {...props} />}
            screenOptions={{
                headerShown: true,
                headerStyle: {
                    backgroundColor: colors.background,
                },
                headerTintColor: colors.text,
                headerTitleStyle: {
                    fontFamily: 'Comfortaa-SemiBold',
                },
                headerTitleAlign: 'center', // BaÅŸlÄ±ÄŸÄ± ortala
                drawerStyle: {
                    backgroundColor: colors.background,
                },
                drawerActiveTintColor: colors.primary,
                drawerInactiveTintColor: colors.secondaryText,
                drawerLabelStyle: {
                    fontFamily: 'Comfortaa-Medium',
                    fontSize: 16,
                },
            }}
        >
            <Drawer.Screen
                name="home"
                options={({ navigation }) => ({
                    headerTitle: () => <GroupHeader group={selectedGroup} onPress={createHandleGroupHeaderPress(navigation)} />,
                    headerRight: () => (
                        <View style={styles.headerRight}>
                            {selectedGroup && (
                                <TouchableOpacity
                                    onPress={handleGroupManagementPress}
                                    style={[styles.actionButton, { backgroundColor: colors.cardBackground + '80', borderColor: colors.stroke }]}
                                >
                                    <Ionicons name="settings-outline" size={18} color={colors.text} />
                                </TouchableOpacity>
                            )}
                        </View>
                    ),
                    drawerLabel: 'Ana Sayfa',
                    drawerIcon: ({ color, size }) => (
                        <Ionicons name="home-outline" size={size} color={color} />
                    ),
                })}
            />
            {/* DiÄŸer ekranlarÄ± gizliyoruz, single page hissi iÃ§in */}
            <Drawer.Screen
                name="showroom"
                options={{
                    drawerItemStyle: { display: 'none' }
                }}
            />
            <Drawer.Screen
                name="api-test"
                options={{
                    drawerItemStyle: { display: 'none' }
                }}
            />
            <Drawer.Screen
                name="(group)"
                options={{
                    headerShown: false,
                    drawerItemStyle: { display: 'none' },
                }}
            />
            <Drawer.Screen
                name="search-user"
                options={{
                    drawerItemStyle: { display: 'none' },
                }}
            />
            <Drawer.Screen
                name="help-support"
                options={{
                    drawerItemStyle: { display: 'none' },
                }}
            />
            <Drawer.Screen
                name="settings"
                options={{
                    drawerItemStyle: { display: 'none' },
                }}
            />
        </Drawer>
    );
}

const styles = StyleSheet.create({
    headerRight: {
        flexDirection: 'row',
        alignItems: 'center',
        gap: 8,
        paddingRight: 16,
    },
    actionButton: {
        width: 36,
        height: 36,
        borderRadius: 18,
        borderWidth: 1,
        justifyContent: 'center',
        alignItems: 'center',
        position: 'relative',
    },
    badge: {
        position: 'absolute',
        top: -4,
        right: -4,
        minWidth: 18,
        height: 18,
        borderRadius: 9,
        justifyContent: 'center',
        alignItems: 'center',
        paddingHorizontal: 4,
    },
    badgeText: {
        fontSize: 10,
        fontWeight: 'bold',
    },
});
</file>

<file path="app/_layout.tsx">
import { useAuth } from '@/contexts/AuthContext';
import { useAppInitialization } from '@/hooks/useAppInitialization';
import { Slot, useRouter, useSegments } from 'expo-router';
import React, { useEffect } from 'react';
import Provider from './Provider';

// Ana Layout Component'i - Auth state'e gÃ¶re routing yapar
function RootLayoutContent() {
  const { session } = useAuth();
  const { isInitialized, isLoading } = useAppInitialization();
  const segments = useSegments();
  const router = useRouter();

  useEffect(() => {
    // Initialization tamamlanmadÄ±ysa bekle (auth + groups)
    if (!isInitialized || isLoading) {
      console.log('ğŸ”µ Layout: Initialization devam ediyor, bekliyor...');
      return;
    }

    console.log('ğŸ”µ Layout: Initialization tamamlandÄ±, routing yapÄ±lÄ±yor...');

    const inAuthGroup = segments[0] === '(auth)';

    // Session yoksa ve login sayfasÄ±nda deÄŸilse, login'e yÃ¶nlendir
    if (!session && !inAuthGroup) {
      console.log('ğŸ”µ Layout: Session yok, login\'e yÃ¶nlendiriliyor');
      router.replace('/(auth)/login');
    }
    // Session varsa ve login sayfasÄ±ndaysa, home'a yÃ¶nlendir
    else if (session && inAuthGroup) {
      console.log('ğŸ”µ Layout: Session var, home\'a yÃ¶nlendiriliyor');
      router.replace('/(drawer)/home');
    }
  }, [session, isInitialized, isLoading, segments]);

  return <Slot />;
}

// Provider ile sarmalanmÄ±ÅŸ ana layout
export default function RootLayout() {
  return (
    <Provider>
      <RootLayoutContent />
    </Provider>
  );
}
</file>

<file path="package.json">
{
  "name": "geliom",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "lint": "expo lint",
    "dios": "npx expo run:ios -d"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.2",
    "@gorhom/bottom-sheet": "^5.2.6",
    "@legendapp/list": "^2.0.13",
    "@react-native-async-storage/async-storage": "2.2.0",
    "@react-native-community/netinfo": "11.4.1",
    "@react-navigation/bottom-tabs": "^7.4.0",
    "@react-navigation/drawer": "^7.5.0",
    "@react-navigation/elements": "^2.6.3",
    "@react-navigation/native": "^7.1.8",
    "@supabase/supabase-js": "^2.75.1",
    "@tanstack/react-query": "^5.90.5",
    "@tanstack/react-query-devtools": "^5.90.2",
    "expo": "54.0.23",
    "expo-apple-authentication": "~8.0.7",
    "expo-application": "~7.0.7",
    "expo-auth-session": "~7.0.8",
    "expo-blur": "~15.0.7",
    "expo-build-properties": "~1.0.9",
    "expo-clipboard": "~8.0.7",
    "expo-constants": "~18.0.9",
    "expo-crypto": "~15.0.7",
    "expo-device": "~8.0.9",
    "expo-font": "~14.0.9",
    "expo-haptics": "~15.0.7",
    "expo-image": "~3.0.10",
    "expo-linear-gradient": "~15.0.7",
    "expo-linking": "~8.0.8",
    "expo-localization": "~17.0.7",
    "expo-notifications": "~0.32.13",
    "expo-router": "~6.0.14",
    "expo-sharing": "~14.0.7",
    "expo-splash-screen": "~31.0.10",
    "expo-status-bar": "~3.0.8",
    "expo-symbols": "~1.0.7",
    "expo-system-ui": "~6.0.8",
    "expo-web-browser": "~15.0.9",
    "i18next": "^25.6.0",
    "lottie-react-native": "^7.3.4",
    "onesignal-expo-plugin": "^2.0.3",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-i18next": "^16.0.1",
    "react-native": "0.81.5",
    "react-native-adapty": "^3.11.2",
    "react-native-draggable-flatlist": "^4.0.3",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-onesignal": "^5.2.14",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-url-polyfill": "^3.0.0",
    "react-native-web": "~0.21.0",
    "react-native-worklets": "0.5.1"
  },
  "devDependencies": {
    "@tanstack/eslint-plugin-query": "^5.91.2",
    "@types/react": "~19.1.0",
    "eslint": "^9.25.0",
    "eslint-config-expo": "~10.0.0",
    "typescript": "~5.9.2"
  },
  "private": true
}
</file>

<file path="app.json">
{
  "expo": {
    "name": "Geliom",
    "slug": "geliom",
    "version": "0.0.1",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "geliom",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.eoist.geliom",
      "googleServicesFile": "./GoogleService-Info.plist",
      "entitlements": {
        "aps-environment": "production",
        "com.apple.developer.networking.wifi-info": true,
        "com.apple.security.application-groups": [
          "group.com.eoist.geliom.onesignal",
          "group.com.eoist.geliom.onesignal"
        ]
      },
      "infoPlist": {
        "UIBackgroundModes": [
          "remote-notification",
          "remote-notification"
        ],
        "ITSAppUsesNonExemptEncryption": false
      },
      "appleTeamId": "NHKQ38KYTV"
    },
    "android": {
      "adaptiveIcon": {
        "backgroundColor": "#E6F4FE",
        "foregroundImage": "./assets/images/android-icon-foreground.png",
        "backgroundImage": "./assets/images/android-icon-background.png",
        "monochromeImage": "./assets/images/android-icon-monochrome.png"
      },
      "googleServicesFile": "./google-services.json",
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false,
      "package": "com.eoist.geliom"
    },
    "web": {
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff",
          "dark": {
            "backgroundColor": "#000000"
          }
        }
      ],
      [
        "onesignal-expo-plugin",
        {
          "mode": "production"
        }
      ],
      [
        "expo-build-properties",
        {
          "ios": {
            "deploymentTarget": "15.1"
          },
          "android": {
            "compileSdkVersion": 35,
            "targetSdkVersion": 35,
            "buildToolsVersion": "35.0.0"
          }
        }
      ],
      "expo-localization",
      [
        "expo-font",
        {
          "fonts": [
            "./assets/fonts/Comfortaa-Light.ttf",
            "./assets/fonts/Comfortaa-Regular.ttf",
            "./assets/fonts/Comfortaa-Medium.ttf",
            "./assets/fonts/Comfortaa-SemiBold.ttf",
            "./assets/fonts/Comfortaa-Bold.ttf"
          ]
        }
      ],
      "expo-web-browser",
      [
        "expo-notifications",
        {
          "icon": "./assets/images/icon.png",
          "color": "#2E7D32"
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true,
      "reactCompiler": true
    },
    "extra": {
      "router": {},
      "oneSignalAppId": "c3a9e24a-d8ef-42cb-8278-f171d2056a4d",
      "eas": {
        "projectId": "f2d7bad9-aa20-473b-ba30-acbdf499245c"
      }
    },
    "owner": "eoist"
  }
}
</file>

</files>
